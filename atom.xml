<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[whtis's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.whtis.com/"/>
  <updated>2017-07-29T06:36:53.372Z</updated>
  <id>http://www.whtis.com/</id>
  
  <author>
    <name><![CDATA[whtis]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用python爬虫框架scrapy对实时新闻进行抓取并存入数据库]]></title>
    <link href="http://www.whtis.com/2017/07/28/%E4%BD%BF%E7%94%A8python%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6scrapy%E5%AF%B9%E5%AE%9E%E6%97%B6%E6%96%B0%E9%97%BB%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8F%96%E5%B9%B6%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://www.whtis.com/2017/07/28/使用python爬虫框架scrapy对实时新闻进行抓取并存入数据库/</id>
    <published>2017-07-28T14:15:20.000Z</published>
    <updated>2017-07-29T06:36:53.372Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>每天的新闻更新很快，如果要全面了解非常困难，更可恶的是一些门户网站还经常取一些乱七八糟的标题，点进去是文不对题。所以萌生了一个想法：自己抓取不同门户网站的新闻更新信息，然后将这些内容进行整合，推送一些当日的热点新闻。<br>想的很简单，真的做起来，发现自己还是太年轻，到写这篇博客为止，我也就是完成了一个基本的抓取框架，连内容都没有获得多少。不过本来就是抱着学习<code>python</code>的想法使用<code>scrapy</code>来抓取新闻，既然已经有了个差不多的框架，也该写写使用<code>scrapy</code>过程中的遇到的一些问题了。</p>
<h3 id="明确需求和技术路线">明确需求和技术路线</h3><ul>
<li>需求：很简单，抓取每天最新的新闻内容（文本），按照一定的格式存入数据库<code>mysql</code>中。</li>
<li>技术路线：之前一直在使用<code>java</code>语言开发的<code>webmagic</code>开源爬虫框架进行爬虫开发。但一直听说<code>python</code>下有个大名鼎鼎的爬虫框架<code>scrapy</code>,所以抱着学习的态度，使用<code>scrapy</code>进行爬虫的开发。</li>
</ul>
<h3 id="简单的技术介绍和入门">简单的技术介绍和入门</h3><p>之前只是使用<code>python</code>写过一些简单的脚本，这次为了使用<code>scrapy</code>,看了一遍<strong>廖雪峰大大</strong>的<code>python3</code><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">教程</a><br>看完后没记住多少，不过有个概念就是了。然后开始查看一些讲<code>scrapy</code>入门的博客，自己实现博客中的例子，算是对<code>scrapy</code>有个大概的了解。我复现的例子是这个：<a href="http://www.jianshu.com/p/fa614bea98eb" target="_blank" rel="external">【图文详解】scrapy安装与真的快速上手——爬取豆瓣9分榜单</a></p>
<h3 id="需求的再分析及让scrapy与需求相关">需求的再分析及让<code>scrapy</code>与需求相关</h3><ul>
<li>需求分析：新闻内容很多，获取的方式也不同。最笨的方式就是复现浏览器的行为：针对不同的信息源获取不同的页面进行解析；其次好一点的方法：由于某些新闻网站提供了rss订阅接口，因此可以解析此接口页面获得内容。下面分析下这两种方法的优缺点：<ul>
<li>模拟浏览器行为：<ul>
<li>优点：能够精准解析到需要的内容</li>
<li>缺点：解析难度高，主流新闻网站都有一系列反爬虫机制；代码与页面结构高度相关，如页面改版，代码改动较大</li>
</ul>
</li>
<li>rss接口：<ul>
<li>优点：不同网站的接口页面结构基本相同，可以使用一套解析逻辑进行解析</li>
<li>缺点：并不是所有网站都会提供该接口，且该接口返回的数据，有些仅有正文摘要，还需要再进一次网站获取完整的正文内容</li>
</ul>
</li>
</ul>
</li>
<li>明确需求下的<code>scrapy</code>:上一节提到的入门内容如果看完后，应该对<code>scrapy</code>会有一个大概的整体认识。在我这需求下，似乎单独创建一个爬虫无法完成所有的需求。因此我创建了两个爬虫文件：<code>rss_news_spider.py</code>和<code>web_news_spider.py</code>，下面会对这两个文件进行详细解释。</li>
</ul>
<h3 id="开始写爬虫">开始写爬虫</h3><h4 id="使用scrapy基础模板来爬取rss接口的新闻内容">使用scrapy基础模板来爬取rss接口的新闻内容</h4><p>终于，振奋人心的时刻到了。可以开始我们的爬虫了。首先我们创建<code>runRss.py</code>,然后写上如下启动爬虫的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># run rssSpider</span></div><div class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</div><div class="line"></div><div class="line">cmdline.execute(<span class="string">"scrapy crawl rss"</span>.split())</div></pre></td></tr></table></figure>
<p>是不是很熟悉，对，这条命令启动了名为<code>rss</code>的爬虫（<strong>注意，在scrapy中创建的每一个爬虫必须有自己唯一的<code>name</code>，否则无法启动</strong>）。我的<code>rss</code>爬虫位于<code>rss_news_spider.py</code>这个文件当中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RssSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">'rss'</span></div><div class="line">    start_urls = [</div><div class="line">        <span class="string">'http://www.wyzxwk.com/e/web/?type=rss2&amp;classid=0'</span>,</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        <span class="keyword">if</span> response.url.find(<span class="string">'rss'</span>) != <span class="number">-1</span>:</div><div class="line">            <span class="keyword">yield</span> Request(response.url, callback=self.parse_rss)</div><div class="line">        <span class="keyword">elif</span> response.url.find(<span class="string">'Article'</span>) != <span class="number">-1</span>:</div><div class="line">            <span class="keyword">yield</span> Request(response.url, callback=self.parse_details)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.logger.info(<span class="string">'start urls is not useful, please check it!'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_rss</span><span class="params">(self, response)</span>:</span></div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        contents = selector.xpath(<span class="string">'//channel/item'</span>)</div><div class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</div><div class="line">            title = content.xpath(<span class="string">'title/text()'</span>).extract()[<span class="number">0</span>]</div><div class="line">            link = content.xpath(<span class="string">'link/text()'</span>).extract()[<span class="number">0</span>]</div><div class="line">            ……</div><div class="line">            article = ArticleItem()</div><div class="line">            article[<span class="string">'table_name'</span>] = <span class="string">'article_'</span> + table_name.lower()</div><div class="line">            article[<span class="string">'title'</span>] = title</div><div class="line">            article[<span class="string">'url'</span>] = link</div><div class="line">            <span class="keyword">if</span> link <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                <span class="keyword">yield</span> scrapy.http.Request(url=link, meta=&#123;<span class="string">'item'</span>: article&#125;, callback=self.parse_details)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_details</span><span class="params">(self, response)</span>:</span></div><div class="line">        article = response.meta[<span class="string">'item'</span>]</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        content = selector.xpath(<span class="string">'//div[@class="m-article s-shadow"]/article/p'</span>).extract().__str__()</div><div class="line">        content = content.replace(<span class="string">"', '"</span>, <span class="string">""</span>).replace(<span class="string">"\\u3000"</span>, <span class="string">"  "</span>).replace(<span class="string">"'"</span>, <span class="string">""</span>).replace(<span class="string">"\\xa0"</span>, <span class="string">""</span>)</div><div class="line">            .replace(<span class="string">"▍"</span>, <span class="string">""</span>)</div><div class="line">        article[<span class="string">'content'</span>] = content</div><div class="line">        <span class="keyword">return</span> article</div></pre></td></tr></table></figure></p>
<p>来认真看下这段代码：</p>
<ul>
<li>设置<code>name</code>、<code>start_urls</code>和<code>parse</code>函数我们都很熟悉。那<code>parse_rss</code>和<code>parse_details</code>是干嘛用的？<ul>
<li>在本文的例子中，我们用了<a href="http://www.wyzxwk.com/" target="_blank" rel="external">乌有之乡</a>的<code>rss</code>接口作为例子。这个<code>rss</code>接口的特点是给出的正文内容是 摘要，如果要查看详细的正文内容需要访问相应的<code>url</code>,因此两个函数的作用就非常明显了：<code>parse_rss</code>函数是处理接口页面的信息并获取正文的链接，然后使用<code>parse_details</code>函数对正文做解析。</li>
<li>这个地方比较重要的是函数之间如何传递参数？也就是我想把<code>parse_rss</code>中解析到的内容传递给<code>parse_details</code>。从代码中可以看出，我们在传递链接的时候使用的<code>scrapy.http.Request</code>中可以附加参数：<code>url</code>是链接；<code>meta</code>是一个字典，可以包含所有希望下一个函数获得的内容；<code>callback</code>是回调函数，用于指定这些内容由哪个函数进行处理。</li>
</ul>
</li>
<li><code>start_urls</code>中注释的url是干啥用的？<ul>
<li>如我们在需求分析中所说，rss接口页面结构是相同的，因此理论上来说，在<code>parse_details</code>之前的逻辑，适用于任何实现了rss接口的网站。</li>
</ul>
</li>
</ul>
<p>现在有个问题？如果我爬取的网站比较多，那么<code>parse_details</code>的逻辑我是不是要根据不同的网站去分别实现？按道理来说是这样的，但<code>scrapy</code>还为我们提供了另外一种实现思路。下面的内容主要参考了如下几篇博客：</p>
<ul>
<li><a href="http://www.code123.cc/1431.html" target="_blank" rel="external">Python爬虫框架Scrapy教程(1)—入门</a></li>
<li><a href="http://www.code123.cc/1432.html" target="_blank" rel="external">Python爬虫框架Scrapy教程(2)—动态可配置</a></li>
<li><a href="http://www.code123.cc/1434.html" target="_blank" rel="external">Python爬虫框架Scrapy教程(3)—使用Redis和SQLAlchemy</a></li>
</ul>
<h4 id="读取数据库配置动态生成爬虫">读取数据库配置动态生成爬虫</h4><p>我们知道，爬虫的核心其实就是发送请求与接收请求。那么如果我们要从网络上获取到新闻内容，浏览器发送这两个请求就可以：<br>1、请求新闻的列表页，解析出每一篇新闻的详细链接<br>2、访问每一篇新闻的详细链接，然后解析返回的内容，就可以得到新闻的标题、发表时间、正文等内容了。<br>（<strong>以上两步其实是爬虫领域很经典的列表+详情页爬取逻辑</strong>）<br>在这个过程中，浏览器（或者代码）的执行步骤是相同的，不同的只是访问的链接，以及对不同链接内容的解析（主要是<code>xpath</code>和<code>正则表达式</code>）。因此假设访问的链接和解析方法都能够动态加载（从数据库中读取），那么我们就可以写一个爬虫来加载这些配置，实现多个网站内容的抓取了。<br>我们创建一个<code>runWeb.py</code>文件，写入下面内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># run webSpider</span></div><div class="line">settings = Settings()</div><div class="line">settings.set(<span class="string">"ITEM_PIPELINES"</span>, &#123;</div><div class="line">    <span class="comment"># 'pipelines.DuplicatesPipeline': 200,</span></div><div class="line">    <span class="comment"># 'pipelines.CountDropPipline': 100,</span></div><div class="line">    <span class="string">'pipelines.DataBasePipeline'</span>: <span class="number">300</span>,</div><div class="line">&#125;)</div><div class="line"><span class="comment"># crawl settings</span></div><div class="line">settings.set(<span class="string">"USER_AGENT"</span>,</div><div class="line">             <span class="string">"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1667.0 Safari"</span></div><div class="line">             <span class="string">"/537.36"</span>)</div><div class="line"></div><div class="line">process = CrawlerProcess(settings)</div><div class="line"></div><div class="line">db = DBSession()</div><div class="line">rules = db.query(Rule).filter(Rule.enable == <span class="number">1</span>)</div><div class="line"><span class="keyword">for</span> rule <span class="keyword">in</span> rules:</div><div class="line">    process.crawl(WebSpider, rule)</div><div class="line">process.start()</div></pre></td></tr></table></figure></p>
<p>加载完自定义<code>settings</code>后，对每一个<code>rule</code>生成一个进程，运行<code>webSpider</code>。我的<code>webSpider</code>在<code>web_news_spider</code>中。可以看下这里面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSpider</span><span class="params">(CrawlSpider)</span>:</span></div><div class="line">    name = <span class="string">"web"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rule)</span>:</span></div><div class="line">        self.rule = rule</div><div class="line">        self.name = rule.site_name</div><div class="line">        self.allowed_domains = rule.allow_domains.split(<span class="string">","</span>)</div><div class="line">        self.start_urls = rule.start_urls.split(<span class="string">","</span>)</div><div class="line">        rule_list = []</div><div class="line">        <span class="comment"># 添加`下一页`的规则</span></div><div class="line">        <span class="keyword">if</span> rule.next_page:</div><div class="line">            rule_list.append(Rule(LinkExtractor(restrict_xpaths=rule.next_page)))</div><div class="line">        <span class="comment"># 添加抽取文章链接的规则</span></div><div class="line">        rule_list.append(Rule(LinkExtractor(</div><div class="line">            allow=[rule.allow_url],</div><div class="line">            restrict_xpaths=[rule.extract_from]),</div><div class="line">            callback=<span class="string">'parse_item'</span>, follow=<span class="keyword">True</span>))</div><div class="line">        self.rules = tuple(rule_list)</div><div class="line">        super(WebSpider, self).__init__()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span><span class="params">(self, response)</span>:</span></div><div class="line">        self.log(<span class="string">'Hi, this is a web page! %s'</span> % response.url)</div><div class="line"></div><div class="line">        content = infos.xpath(self.rule.content_xpath).extract()</div><div class="line">        article[<span class="string">"content"</span>] = content[<span class="number">0</span>] <span class="keyword">if</span> content <span class="keyword">else</span> <span class="string">""</span></div><div class="line"></div><div class="line">        publish_time = infos.xpath(self.rule.publish_time_xpath).extract()</div><div class="line">        article[<span class="string">"publish_time"</span>] = publish_time[<span class="number">0</span>] <span class="keyword">if</span> publish_time <span class="keyword">else</span> <span class="string">""</span></div><div class="line">        ……</div></pre></td></tr></table></figure></p>
<p>其中<code>__init__</code>函数很关键，除了从数据库读取配置外，它使用<code>Rule(LinkExtractor(……))</code>指定了对新闻列表页的解析规则：<code>allow</code>指定了加入下载队列中url的格式；<code>restrict_xpaths</code>指定了寻找url的页面范围;<code>callback</code>指定了处理后续url（新闻详情页）的方法。</p>
<ul>
<li><code>allow</code>和<code>restrict_xpaths</code>从<code>正则表达式</code>和<code>xpath</code>共同对后续帖子详情页url进行限制；</li>
<li><code>callback</code>指定的是解析详情页的方法，顾名思义，列表页的处理是由爬虫自己处理的（使用参数，这也是我没搞懂的地方，因为不是自己处理，在爬虫无法抽取详情页url时很难定位到哪里出错了）</li>
</ul>
<p>如果你的<code>allow</code>和<code>restrict_xpaths</code>设置无误，且列表页返回的信息很完整，你就可以使用<code>parse_item</code>函数制定解析详情页的逻辑了。<br><strong>1、初始接触这种方法时，极其建议使用已经有的例子进行学习，上面提到的博客中的代码，在本文书写时仍能正常运行</strong><br><strong>2、这种方法对动态加载的列表页是无效的</strong></p>
<h3 id="把抓取到的内容存入数据库">把抓取到的内容存入数据库</h3><p>网上大部分使用的<code>mysql</code>驱动是<code>mysqlDb</code>，但是它不支持<code>python3.x</code>。因此本文使用的是<code>pymysql</code>,<code>orm</code>框架是<a href="https://www.sqlalchemy.org/" target="_blank" rel="external"><code>SQLAlchemy</code></a><br>本文仅对一些缺少资料地方进行说明：</p>
<ul>
<li><code>SQLAlchemy</code>连接数据库的方法（参考自官方文档）：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 初始化数据库连接:</span></div><div class="line">engine = create_engine(<span class="string">'mysql+pymysql://user:passwd@localhost:3306/spider?charset=utf8mb4'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建DBSession类型:</span></div><div class="line">DBSession = sessionmaker(bind=engine)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，初始化<code>engine</code>时需要指定数据库。本文使用的代码，数据库信息存储在<code>scrapy</code>的默认<code>settings</code>中。</p>
<ul>
<li>SQLAlchemy存储信息时动态指定表名<br>我们有这个一个需求，不同的网站内容我们需要存储到不同的表当中。但学习<code>SQLAlchemy</code>用法的时候，我们可以看到，在创建<code>model</code>类时就必须指定<code>__tablename__</code>,否则无法存储。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleModel</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'none'</span></div><div class="line"></div><div class="line">    aid = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    title = Column(String)</div><div class="line">    url = Column(String)</div><div class="line">    ……</div></pre></td></tr></table></figure>
</li>
</ul>
<p>那我们总不能创建多个除了<code>__tablename__</code>不同其他都相同的<code>modle</code>类吧。还好，我们可以使用如下方法在向数据库插入数据的时候（pipeline中）动态指定表名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ArticleModel.__table__.name = item[<span class="string">'table_name'</span>]</div><div class="line">a = ArticleModel(title=item[<span class="string">"title"</span>].encode(<span class="string">"utf-8"</span>),</div><div class="line">                 url=item[<span class="string">"url"</span>],</div><div class="line">                 ……</div><div class="line">                ）</div></pre></td></tr></table></figure></p>
<h3 id="其他">其他</h3><p>本来以为<code>mysql</code>中的<code>timestamp</code>对应于<code>python</code>中的<code>date</code>类型，今天向数据库中插入时间戳的时候，才发现对应的是<code>str</code>类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pub_float = time.mktime(time.strptime(pubDate, <span class="string">'%a, %d %b %Y %X %z'</span>))</div><div class="line">timestamp = time.strftime(<span class="string">'%Y-%m-%d %X'</span>, time.localtime(pub_float))</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>type(timestamp) → str</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="后记">后记</h3><p>本文所写内容为这段时间学习成果之记录，开头所提到的需求离实际完成还很远。文中提到的第二种方法在具体到本文中需求中使用时并没有成功，具体原因由于本人水平所限，并未查出来。如果有对这方面感兴趣的可以一同研究学习。本文提到的完整代码可以在我的<a href="https://github.com/whtis/news_scrapy" target="_blank" rel="external">github</a>上找到。</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>每天的新闻更新很快，如果要全面了解非常困难，更可恶的是一些门户网站还经常取一些乱七八糟的标题，点进去是文不对题。所以萌生了一个想法：自己抓取不同门户网站的新闻更新信息，然后将这些内容进行整合，推送一些当日的热点新闻。<br>想的]]>
    </summary>
    
      <category term="python，scrapy，mysql，新闻抓取" scheme="http://www.whtis.com/tags/python%EF%BC%8Cscrapy%EF%BC%8Cmysql%EF%BC%8C%E6%96%B0%E9%97%BB%E6%8A%93%E5%8F%96/"/>
    
      <category term="python" scheme="http://www.whtis.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最近要做的几件事]]></title>
    <link href="http://www.whtis.com/2017/06/30/%E6%9C%80%E8%BF%91%E8%A6%81%E5%81%9A%E7%9A%84%E5%87%A0%E4%BB%B6%E4%BA%8B/"/>
    <id>http://www.whtis.com/2017/06/30/最近要做的几件事/</id>
    <published>2017-06-30T07:12:31.102Z</published>
    <updated>2017-06-19T03:23:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>有时候想到要做一些跟技术有关的东西，但很多时候都会忘记。一直觉得<strong>兴趣是最好的老师</strong>这句话很对，既然有兴趣，那么最好动手做一做。写这篇文章，提醒自己的同时也是希望认识志同道合的朋友，虽然刚开始做的东西很low，但慢慢积累，总能获得成就感不是？<br><br>这篇文章会不断更新，我也想看看，我最后到底能做几件自己喜欢的事情，嘻嘻(●’◡’●)</p>
<h5 id="2016-09-19日凌晨">2016-09-19日凌晨</h5><ul>
<li>学习安卓开发，写一个app，具体需求如下：（已实现第一步）<ul>
<li><del>能够实现实时监测手机短信的功能。当手机A收到新短信后，能立刻调用系统短信app将短信内容发送给B</del></li>
<li>如果有可能，转发这一步调用微信完成（省钱啊）</li>
<li><del>界面，能凑合用就行，别出bug就行（没写。。）</del></li>
</ul>
</li>
<li>给这博客添加几个功能：<ul>
<li><del>添加网易云音乐插件（最终还是觉得不加好一些）</del></li>
<li><del>添加一个新分区，类似于微信朋友圈或者qq空间发状态的功能。（因为自己有时候有些话憋不住，按照博文发出来又太短了=。=）</del></li>
<li><del>之前好像见过博客同步instagram的功能，如果上面两个都完成了，可以在博客上添加一个专门的图片分区（看过效果，类似于图床，没啥实用性，还是直接上传instagram，等积累到一定量直接放链接就行）</del></li>
</ul>
</li>
</ul>
<h5 id="2016-11-07日夜">2016-11-07日夜</h5><ul>
<li><del>续上次的需求，学习微信公众号开发（转发手机短信到公众号再下发）</del></li>
<li><del>学习javascript，自己写一个简易的网站（博客新分区的提高要求）</del></li>
</ul>
<h5 id="2017-6-19">2017-6-19</h5><ul>
<li>接去年11月的需求，学习微信公众号开发，建立自己的微信公众号，提供信息的聚合，包括新闻和招聘信息</li>
<li>学习<code>spring</code>框架，运用所学的知识在腾讯云上搭建一个自己的网站。采用技术为<code>java+spring+mybatis</code></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>有时候想到要做一些跟技术有关的东西，但很多时候都会忘记。一直觉得<strong>兴趣是最好的老师</strong>这句话很对，既然有兴趣，那么最好动手做一做。写这篇文章，提醒自己的同时也是希望认识志同道合的朋友，虽然刚开始做的东]]>
    </summary>
    
      <category term="待完成" scheme="http://www.whtis.com/tags/%E5%BE%85%E5%AE%8C%E6%88%90/"/>
    
      <category term="未完成" scheme="http://www.whtis.com/categories/%E6%9C%AA%E5%AE%8C%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ubuntu过程中的一些命令集合]]></title>
    <link href="http://www.whtis.com/2017/06/19/%E4%BD%BF%E7%94%A8ubuntu%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
    <id>http://www.whtis.com/2017/06/19/使用ubuntu过程中的一些命令集合/</id>
    <published>2017-06-19T01:57:27.000Z</published>
    <updated>2017-06-19T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ubuntu命令备忘">ubuntu命令备忘</h1><p>用ubuntu时，经常会用到一些有用的命令，但回头好久不用又忘了。而我又是那种不喜欢查手册的人，百度一下又得费时，所以干脆开篇博客记下来，以后直接来这查好了。</p>
<h2 id="ubuntu使用tar命令备份系统命令合集"><code>ubuntu</code>使用<code>tar</code>命令备份系统命令合集</h2><p>这里的备份和恢复都是针对同一硬盘下的备份与恢复。</p>
<h3 id="备份">备份</h3><ul>
<li><code>tar cvpzf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys /</code></li>
<li>或者是 <code>tar cvpjf backup.tgz.gz2 --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys /</code><br>两条命令的区别在于第二条的压缩率高于第一条。</li>
</ul>
<h3 id="恢复">恢复</h3><ul>
<li><code>tar xvpfz backup.tgz -C /</code> or <code>tar xvpfj backup.tar.bz2 -C /</code></li>
</ul>
<h2 id="ubuntu使用dd命令备份硬盘命令合集"><code>ubuntu</code>使用<code>dd</code>命令备份硬盘命令合集</h2><p>这里的备份和恢复可以在不同硬盘下进行，但是要注意硬盘大小的问题，即恢复的硬盘大小不得小于备份的硬盘大小。这些操作请在<code>live CD</code>环境下进行。</p>
<h3 id="备份-1">备份</h3><ul>
<li><code>fdisk -u -l</code> 查看磁盘信息</li>
<li><code>dd if=/dev/sda of=/ubuntu/media/xxx/ghost.img</code> 备份到外接u盘中</li>
<li><code>kill -USR1 `pgrep ^dd` </code>显示上一条命令的进度（请在另外的终端中运行）</li>
<li><code>dd if=/ubuntu/media/xxx/ghost.img of=/dev/sda</code> 恢复到指定的硬盘中<tab> kill -USR1 <code>pgrep ^dd</code> </tab>

</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ubuntu命令备忘">ubuntu命令备忘</h1><p>用ubuntu时，经常会用到一些有用的命令，但回头好久不用又忘了。而我又是那种不喜欢查手册的人，百度一下又得费时，所以干脆开篇博客记下来，以后直接来这查好了。</p>
<h2 id="ubuntu使用ta]]>
    </summary>
    
      <category term="ubuntu" scheme="http://www.whtis.com/tags/ubuntu/"/>
    
      <category term="收集整理" scheme="http://www.whtis.com/tags/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="ubuntu" scheme="http://www.whtis.com/categories/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ubuntu16.04删除当前用户密码文件/etc/shadow后无法进入系统的解决方法]]></title>
    <link href="http://www.whtis.com/2017/04/08/ubuntu16-04%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E6%96%87%E4%BB%B6-etc-shadow%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2017/04/08/ubuntu16-04删除当前用户密码文件-etc-shadow后无法进入系统的解决方法/</id>
    <published>2017-04-08T07:48:02.000Z</published>
    <updated>2017-04-08T08:55:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>最近项目用到了dspace，在windows中向dspace中导入item时会报解压错误的<code>error</code>,后来经过排查，确定是windows平台编码问题导致。于是转战ubuntu，在安装了16.04版本，配置了<code>java</code>环境、安装编译器等等一系列工作、差不多可以进行开发的时候，我手贱删除了这个文件<code>/etc/shadow</code>，为什么会删除它，这就涉及到安装shadowsocks了，这里不详说。反正是在编辑<code>/etc/shadowsocks.json</code>文件时，我觉得<code>/etc/shadow</code>可能是个临时文件，就用root权限删除了。这样一删不要紧，重启机器以后傻眼了，输入正确的用户名密码后，无法登陆到图形界面，提示也是说密码不对。类似于下图：<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//558d1f9e0e1dcda9c9001b15c0b4d63d.png" alt="ubuntu密码错误"></p>
<h4 id="原因">原因</h4><p>解决这个问题之前，需要了解下ubuntu登陆图形界面时的用户认证过程。以下是个人理解，可能会有错误，还请指正。</p>
<ul>
<li>ubuntu会在<code>/etc</code>目录下保存用户的登陆信息，当然是加密后的，但是不像我们认为的那样只有一个文件，而是包含两个文件：<code>/etc/passwd</code>、<code>/etc/shadow</code>，登陆时ubuntu会自动比对两个文件的信息，如果一直则允许用户登陆，否则就会拒绝。我因为删除了<code>/etc/shadow</code>这个文件，所以在比对时会出错。</li>
</ul>
<h4 id="解决">解决</h4><p>找到了原因，就很好办了。网上有很多遗忘了ubuntu密码后找回的教程，但是很遗憾，我所能找到的没有一个教程是完全正确的，因为大多数都是互相抄，这种现象确实可悲。以下解决思路是我本人亲测，转载时请附带ubuntu版本信息及出处。</p>
<ul>
<li><del>第一种解决方法：既然我是误删了<code>/etc/shadow</code>，那么我想办法在命令行登陆，拷贝<code>/etc/passwd</code>文件为<code>/etc/shadow</code>不就可以绕过俩文件校验了么？（事实证明这个想法行不通，如果你查看两个文件的内容，你会发现实际上两个文件的内容是不同的，但登陆时具体怎么校验的，没有深入研究过）</del></li>
<li><del>第二种方法：想办法在命令行登陆，使用命令行更改用户密码，然后就可以使用原用户名+新密码登陆了（这种方法看似可行，而且命令行中更改密码时也会提示更改成功，但仍然无法登陆图形界面。ps：此时可以在shell中登陆）</del></li>
<li>第三种方法：想办法在命令行登陆，然后创建一个新的用户，将老用户文件拷贝到新用户目录下，重启后就可以使用新用户登陆了。（事实证明这种方法可行，唯一的问题是之前用户的某些配置会丢失，这也没办法了。。）</li>
</ul>
<h5 id="实际操作">实际操作</h5><p>可能有人注意到，上面的解决方法都有一点是相同的，<strong>想办法在命令行登陆</strong>。但当机器出现这问题时，<code>CTRL+ALT+F2~F6</code>都已经无法进入命令行了。下面说下正确的做法，截图来自网络。<br>1、开机按ESC，出现如下界面<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//ef0ff36421090d6e1227c8c3cdfabefb.png" alt="ubuntu开机画面"></p>
<p>2、按回车键进入如下界面，然后选中有recovery mode的选项<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//5ce0970a7d9d6cc2bcd68b4ae256fb47.png" alt="ubuntu-recovery-mode"></p>
<p>3、这一步不要按回车，按下<code>e</code>进行编辑状态，找到图中红色框的<code>recovery nomodeset</code>并删除，修改<code>ro</code>为<code>rw</code>（不改的话进入命令行无法输入命令）,并在后面输入<code>quiet splash rw init=/bin/bash</code>后，按<code>F10</code>或<code>CTRL+X</code>重启<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//e512c666c1780ade758e424890e8973c.png" alt="edit-grub"><br><strong>注意，网上大多数教程就是这一步操作不对，导致重启后要么无法进入命令行，要么无法编辑</strong></p>
<p>4、重启后如果看到下图，则说明我们可以开始尝试上面提到的三种方法了。<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//4c37c3c29de17d562411db499f3a3bd1.png" alt="root-temp"></p>
<h4 id="后记">后记</h4><ul>
<li>请注意本文全程的解决是基于ubuntu没有开启<code>root</code>用户图形界面登陆的前提，关于如何开启root用户登陆，可以自行<code>google</code>。如果开启了<code>root</code>用户，则以上的讨论都可以省略，因为以<code>root</code>用户登陆后，更改用户等操作都不会遇到任何困难。因此强烈建议：<code>使用ubuntu桌面版时请开启root用户登陆，方便遇到问题后能及时解决。</code></li>
<li>附上我在测试以上三种方法时，使用的一些<code>ubuntu</code>指令：<ul>
<li>递归拷贝用户目录：<code>sudo cp -r sourceFold_path targetFold_path</code></li>
<li>递归指定用户目录所有者：<code>sudo chown user usergroup</code></li>
<li>增加用户并且在<code>/home</code>目录下生成相应文件夹：<code>sudo adduser user</code>，该命令会自动创建用户主目录，创建用户同名的组</li>
<li>修改密码：<code>sudo passwd</code>，然后输入两次密码即可。如果要修改特定用户的密码，可以在后面加上用户名 <code>sudo passwd user</code></li>
</ul>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>最近项目用到了dspace，在windows中向dspace中导入item时会报解压错误的<code>error</code>,后来经过排查，确定是windows平台编码问题导致。于是转战ubuntu，在安装了16.04版本，配]]>
    </summary>
    
      <category term="ubuntu" scheme="http://www.whtis.com/tags/ubuntu/"/>
    
      <category term="搜集整理" scheme="http://www.whtis.com/tags/%E6%90%9C%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="ubuntu" scheme="http://www.whtis.com/categories/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个可以链式使用正则的类]]></title>
    <link href="http://www.whtis.com/2017/03/23/%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E9%93%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E7%9A%84%E7%B1%BB/"/>
    <id>http://www.whtis.com/2017/03/23/一个可以链式使用正则的类/</id>
    <published>2017-03-23T07:52:01.000Z</published>
    <updated>2017-06-19T01:58:35.000Z</updated>
    <content type="html"><![CDATA[<p>最近使用webMgaic爬虫框架的时候，发现链式调用真的很好用，能省掉很多套路性的代码，所以也自己动手写了一个可以链式调用进行正则筛选的工具类。下面上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.regex.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by wht on 2017/3/18.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RexString</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>  String string = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RexString</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RexString</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.string = string;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> RexString <span class="title">getRex</span><span class="params">(String rex)</span> </span>&#123;</div><div class="line">        Pattern p = Pattern.compile(rex);</div><div class="line">        Matcher m = p.matcher(string);</div><div class="line">        <span class="keyword">if</span> (m.find()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RexString(m.group());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RexString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.string;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RexString rexString = <span class="keyword">new</span> RexString(<span class="string">"xxx"</span>);</div><div class="line">RexString rs = rexString.getRex(rex1).getRex(rex2).getRex(rex3) ···</div><div class="line">String result = rs.toString();</div></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近使用webMgaic爬虫框架的时候，发现链式调用真的很好用，能省掉很多套路性的代码，所以也自己动手写了一个可以链式调用进行正则筛选的工具类。下面上代码：</p>
<figure class="highlight java"><table><tr><td class="g]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="总结，原创" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93%EF%BC%8C%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo博客主题--material折腾笔记]]></title>
    <link href="http://www.whtis.com/2016/11/20/hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-material%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.whtis.com/2016/11/20/hexo博客主题-material折腾笔记/</id>
    <published>2016-11-20T12:56:17.000Z</published>
    <updated>2016-11-20T13:21:22.000Z</updated>
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;好久没怎么照看博客了，昨天突然发现，以前用的<code>Next</code>主题挂了。因为用的别人的东西，不知道问题。本着折腾的想法，重新换了一个主题<code>material</code>。该主题算是满足了我大部分的需求吧。但还是有吐槽的地方……（虽然不会写js，不妨碍我吐槽。。原作者看到估计会气的吐血）</p>
<h4 id="添加谷歌和百度统计代码">添加谷歌和百度统计代码</h4><p>按照<a href="https://material.vss.im/expert/" target="_blank" rel="external">使用文档</a>可以自行添加代码，但我添加百度统计代码时报错，所以直接把百度统计代码写到<code>layout/_partial/head.ejs</code>文件中了。</p>
<h4 id="在文章详情页添加回主页的方法">在文章详情页添加回主页的方法</h4><ul>
<li>可以直接点击缩略图返回首页</li>
<li>分享按钮下增加回主页</li>
</ul>
<h4 id="此主题的一些想法">此主题的一些想法</h4><ul>
<li>好的方面<ul>
<li>背景支持bing图片，这个想法点赞</li>
<li>每篇文章都提供缩略图<code>thumbnail</code>的设置，很棒</li>
</ul>
</li>
<li>可以改进的地方<ul>
<li>侧边栏很不完美。包括样式和调出方式（鼠标点击改为鼠标滑过会好很多，尝试过更改，然而太菜，没有找到正确修改的方法）</li>
<li>缺少文章分类页，看github上的issue，感觉作者根本没想到这个需求，但我之前用的主题都有，强迫症伤不起</li>
</ul>
</li>
</ul>
<p>突然想到，改了作者的文件，以后<code>pull</code>的时候又有得折腾了。anyway，自己菜就得忍受这些问题了。</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<p>&nbsp;&nbsp;好久没怎么照看博客了，昨天突然发现，以前用的<code>Next</code>主题挂了。因为用的别人的东西，不知道问题。本着折腾的想法，重新换了一个主题<code>material</code>。该主题算是满足了我大部分的需求吧。但还是有吐槽的地方…]]>
    </summary>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="hexo" scheme="http://www.whtis.com/tags/hexo/"/>
    
      <category term="hexo" scheme="http://www.whtis.com/categories/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将百度搜索结果的长url链接转换为真实的url地址]]></title>
    <link href="http://www.whtis.com/2016/09/19/%E5%B0%86%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E9%95%BFurl%E9%93%BE%E6%8E%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%9C%9F%E5%AE%9E%E7%9A%84url%E5%9C%B0%E5%9D%80/"/>
    <id>http://www.whtis.com/2016/09/19/将百度搜索结果的长url链接转换为真实的url地址/</id>
    <published>2016-09-18T16:37:15.000Z</published>
    <updated>2017-06-19T01:58:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>最近写爬虫的时候，想调用百度的搜索结果，于是有了这个问题。需要注意的是，本篇内容转化是仅针对百度跳转到非百度链接的，百度内部链接的跳转，如百度搜索主入口跳转到百度知道、百度文库等情况不再讨论之列。</p>
<h3 id="问题描述">问题描述</h3><ul>
<li>百度搜索入口：<code>https://www.baidu.com/s?wd=</code>,后面加上需要的搜索内容即可。如需要进行更加精确的搜索，可以使用百度的<a href="http://imgs.xinhuanet.com/js/baidu/gj.htm" target="_blank" rel="external">高级搜索</a>功能。</li>
<li>百度搜索结果示例：<code>https://www.baidu.com/link?url=NsJrxOylR5il9kO2p7IJZu9RdvqdWgobSo1W7n29FIu&amp;amp;wd=&amp;amp;eqid=e4c01daf0006800b0000000357debb6c</code>,实际的url为<code>www.whtis.com</code>。</li>
<li>原因：百度为什么要实行加密跳转，网上有很多有意思的文章，感兴趣可以看看。这里仅从技术角度进行说明。<br><br>百度的这种跳转采用的是302重定向。虽然有时候状态码不是302，但原理差不多一样：当你点击了百度的加密链接后，会向百度内部的服务器发送请求，这个时候服务器会根据你提交的百度链接使用重定向技术自动跳转到相应的真实url。</li>
</ul>
<h3 id="拿到真实的URL链接">拿到真实的URL链接</h3><p>网上有很多博客都提到过这事，既然知道了302跳转的原理，那么可以采用这种思路拿到真实的URL：模拟一个请求，在百度服务器进行重定向的时候获得重定向的地址即可。<br><br>原理很简单，但是我在网上找了很多，基本都是互相抄，抄的代码怎么说呢，用的工具都是httpclient，但是都是httpclient已经废弃的方法，虽然不报错，但是没法实现这功能了。所以这也告诉我们写博客的人，一定要注明自己的代码基于的是哪个版本的工具，虽然这只是一点小事，但却能让自己和他人节约很多时间。<br><br>下面上代码：</p>
<p><strong>使用版本：httpclient 4.3.3</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealUrl</span><span class="params">(String url)</span> </span>&#123;</div><div class="line"></div><div class="line">        String realUrl = <span class="string">""</span>;</div><div class="line"></div><div class="line">        HttpClient client = HttpClientBuilder.create().build();</div><div class="line">        RequestConfig config = RequestConfig.custom()</div><div class="line">        <span class="comment">//禁止自动重定向</span></div><div class="line">                .setRedirectsEnabled(<span class="keyword">false</span>)</div><div class="line">                .build();</div><div class="line"><span class="comment">//302跳转</span></div><div class="line">        HttpGet get = <span class="keyword">new</span> HttpGet(url);</div><div class="line">        get.setConfig(config);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//对url进行utf-8解码</span></div><div class="line">            url = URLDecoder.decode(url, <span class="string">"utf-8"</span>);</div><div class="line">            HttpResponse rs = client.execute(get);</div><div class="line">            Header h = rs.getFirstHeader(<span class="string">"Location"</span>);</div><div class="line">            realUrl = h.getValue().trim();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printstacktrace();</div><div class="line">            <span class="keyword">return</span> url;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (realUrl.equals(<span class="string">""</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> url;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> realUrl;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>最近写爬虫的时候，想调用百度的搜索结果，于是有了这个问题。需要注意的是，本篇内容转化是仅针对百度跳转到非百度链接的，百度内部链接的跳转，如百度搜索主入口跳转到百度知道、百度文库等情况不再讨论之列。</p>
<h3 id="问题描]]>
    </summary>
    
      <category term="java，原创" scheme="http://www.whtis.com/tags/java%EF%BC%8C%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PostgreSQL使用手记]]></title>
    <link href="http://www.whtis.com/2016/09/14/PostgreSQL%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/"/>
    <id>http://www.whtis.com/2016/09/14/PostgreSQL使用手记/</id>
    <published>2016-09-14T14:29:13.000Z</published>
    <updated>2017-03-23T09:58:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p><blockcode><br>&emsp;&emsp;因为项目需要，要将本来的<code>mybatis+mysql</code>改为<code>mybatis+postgresql</code>,使用途中难免遇到坑，以下是我遇到的，记录下来供参考。好久没写blog，感觉都快长草了，目前在想要不要开一个分类，写点日常废话😂<br></blockcode><br>&emsp;&emsp;好了，言归正传。</p>
<h3 id="为什么要用PostgreSQL">为什么要用PostgreSQL</h3><p>为什么要用呢,上面已经说了，项目需要。postgresql经常被拿来和mysql进行比较，postgresql可以用来存储较大的对象数据（文本、视频、图片等），符合项目要求。</p>
<h3 id="什么是PostgreSQL">什么是PostgreSQL</h3><p>念都不知道怎么念的一个词，确实第一感觉没有mysql好。看下官方的说法：</p>
<blockquote>
<p>PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。(摘自百度百科)</p>
</blockquote>
<h3 id="使用版本">使用版本</h3><p>本文总结基于PostgreSQL 9.4版本</p>
<h3 id="安装及使用">安装及使用</h3><p>推荐下阮一峰写的这篇博客<a href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html" target="_blank" rel="external">PostgreSQL新手入门</a></p>
<h3 id="使用中出现的错误及解决方案">使用中出现的错误及解决方案</h3><h4 id="错误一：_java-sql-SQLException:_No_suitable_driver_found_for_jdbc:postgresql://yourhost:port">错误一： <code>java.sql.SQLException: No suitable driver found for jdbc:postgresql://yourhost:port</code></h4><ul>
<li>可能的错误原因：<ul>
<li>使用的postgresql的驱动与当前使用的jdk版本不兼容。具体兼容情况参见官方文档，本文仅作摘录：</li>
<li>系统环境没有配置classpath路径，使的程序无法找到驱动的位置。（使用java IDE编写代码时一般不会出现这种情况）</li>
<li><strong>连接jdbc时url没写正确，一定要再三检查下正确的url</strong>（这一条很恶心，url错误时的提示我遇到过两种，一种是本条目列出的错误，另一种是提示字符编码有问题）</li>
</ul>
</li>
</ul>
<h4 id="错误二：_Error_querying_database-_Cause:_org-postgresql-util-PSQLException:_ERROR:_CREATE_DATABASE_cannot_run_inside_a_transaction_block">错误二： <code>Error querying database.  Cause: org.postgresql.util.PSQLException: ERROR: CREATE DATABASE cannot run inside a transaction block</code></h4><ul>
<li><p>可能的错误原因：</p>
<ul>
<li><p>根据网上查到的资料，单独使用postgresql时，出现这个错误的原因是因为没有打开自动提交。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = DriverManager.getConnection(<span class="string">"jdbc:postgresql://yourhost"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>);</div><div class="line">     c.setAutoCommit(<span class="keyword">true</span>); <span class="comment">// 把自动提交设置为true</span></div></pre></td></tr></table></figure>
</li>
<li><p>我在项目中单独使用Mybatis进行事务管理，管理<code>PostgreSQL</code>时也会出现这个错误，因为Mybatis封装了<code>java.sql.*</code>相关的类,因此无法按照上面方式进行更改，在Mybatis中打开一个会话时，也应该将其设置为自动提交（mysql无需设置）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>总结：出现这个问题，网上给的解决方法大多是因为没有打开自动提交，但是仅仅在portgresql控制台上执行<code>SET AUTOCOMMIT = on</code>是无用的，至于为什么需要打开自动提交才能创建数据库，这个不太清楚，可能跟<code>PostgreSQL</code>自己的事务管理逻辑有关，而且这样改动后，暂时不知道会不会对之后的数据库操作造成影响</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="错误三：在拷贝excel中数据到pgsql中时，使用语句时有以下问题需要注意：">错误三：在拷贝excel中数据到pgsql中时，使用语句时有以下问题需要注意：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COPY excel.csv FROM <span class="string">'address'</span> WITH (FORMAT CSV, HEADER TRUE, QUOTE <span class="string">'"'</span>, DELIMITER <span class="string">','</span>, ENCODING <span class="string">'UTF8'</span> );</div></pre></td></tr></table></figure>
<ul>
<li><code>ERROR: must be superuser to COPY to or from a file,建议：Anyone can COPY to stdout or from stdin. psql&#39;s copy command also works for anyone.</code><ul>
<li>这是因为当前登陆pgsql的用户不具有向数据库copy数据的权限所致。需要切换到superuser进行此操作。</li>
</ul>
</li>
<li><code>ERROR: invalid input syntax for integer:</code><ul>
<li>这个错误是网上使用<code>COPY excel.csv FROM &#39;address&#39; WITH DELIMITER &#39;,&#39;</code>所致，如果在copy命令中指定选项header为true. 另外，将format指定为csv, 文件格式指定为utf8，就能避免这错误。</li>
</ul>
</li>
</ul>
<h3 id="使用PostgreSQL存储大文件">使用PostgreSQL存储大文件</h3><p>待编辑</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p><blockcode><br>&emsp;&emsp;因为项目需要，要将本来的<code>mybatis+mysql</code>改为<code>mybatis+postgresql</code>,使用途中难免遇到坑，以下是我遇]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="数据库，PostgreSQL" scheme="http://www.whtis.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8CPostgreSQL/"/>
    
      <category term="SQL" scheme="http://www.whtis.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习笔记--设置代理及打开外部程序]]></title>
    <link href="http://www.whtis.com/2016/05/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E5%8F%8A%E6%89%93%E5%BC%80%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.whtis.com/2016/05/29/Java学习笔记-设置代理及打开外部程序/</id>
    <published>2016-05-29T12:14:59.000Z</published>
    <updated>2016-09-14T15:50:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="设置系统代理">设置系统代理</h3><ul>
<li><p>系统设置全局代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.getProperties().setProperty(<span class="string">"proxySet"</span>, <span class="string">"true"</span>);</div><div class="line">System.getProperties().setProperty(<span class="string">"http.proxyHost"</span>, <span class="string">"ip"</span>);</div><div class="line">System.getProperties().setProperty(<span class="string">"http.proxyPort"</span>, port);</div></pre></td></tr></table></figure>
</li>
<li><p>使用了selenium的chrome驱动，webdriver设置代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"webdriver.chrome.driver"</span>, <span class="string">"filepath"</span>);</div><div class="line">String proxyIpAndPort = ip + <span class="string">":"</span> + port;</div><div class="line"></div><div class="line"><span class="comment">// 代理配置</span></div><div class="line">DesiredCapabilities cap = <span class="keyword">new</span> DesiredCapabilities();</div><div class="line">org.openqa.selenium.Proxy proxy = <span class="keyword">new</span> org.openqa.selenium.Proxy();</div><div class="line"></div><div class="line"><span class="comment">// 配置http、ftp、ssl代理（注：当前版本只支持所有的协议公用http协议，下述代码等同于只配置http）</span></div><div class="line">proxy.setHttpProxy(proxyIpAndPort)</div><div class="line">        .setFtpProxy(proxyIpAndPort)</div><div class="line">        .setSslProxy(proxyIpAndPort);</div><div class="line"></div><div class="line"><span class="comment">// 以下三行是为了避免localhost和selenium driver的也使用代理，务必要加，否则无法与iedriver通讯</span></div><div class="line">cap.setCapability(CapabilityType.ForSeleniumServer.AVOIDING_PROXY, <span class="keyword">true</span>);</div><div class="line">cap.setCapability(CapabilityType.ForSeleniumServer.ONLY_PROXYING_SELENIUM_TRAFFIC, <span class="keyword">true</span>);</div><div class="line">System.setProperty(<span class="string">"http.nonProxyHosts"</span>, <span class="string">"localhost"</span>);</div><div class="line"></div><div class="line">cap.setCapability(CapabilityType.PROXY, proxy);</div><div class="line"></div><div class="line">WebDriver webDriver = <span class="keyword">new</span> ChromeDriver(cap);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="打开外部程序">打开外部程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Process p = Runtime.getRuntime().exec(<span class="string">"cmd command"</span>);</div></pre></td></tr></table></figure>
<p><strong>如果外部程序放在一个单独的线程中执行，需要注意的是：该线程执行完并不代表着外部程序也执行完相应的任务。</strong></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="设置系统代理">设置系统代理</h3><ul>
<li><p>系统设置全局代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</d]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java学习笔记" scheme="http://www.whtis.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HttpClient4.x使用中出现的几个问题及解决方法]]></title>
    <link href="http://www.whtis.com/2016/05/05/HttpClient4-x%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2016/05/05/HttpClient4-x使用中出现的几个问题及解决方法/</id>
    <published>2016-05-05T14:38:39.000Z</published>
    <updated>2016-09-14T15:46:45.000Z</updated>
    <content type="html"><![CDATA[<p>最近才开始接触这个工具包，官网上目前已经更新到<a href="http://hc.apache.org/downloads.cgi" target="_blank" rel="external">HttpClient4.5.2</a>了。google的时候看到HttpClient从4.0版本改了底层，因此使用时会出现一些方法不再适用的问题，这里记录出现的一些问题以及相应替代的方法。</p>
<p>1、 创建HttpClient时使用下面的语句，会出现<code>org.apache.http.impl.client.DefaultHttpClient&#39; is deprecated</code><br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</div></pre></td></tr></table></figure></p>
<p>   可以使用如下语句代替：<a href="http://stackoverflow.com/questions/15336477/deprecated-java-httpclient-how-hard-can-it-be" target="_blank" rel="external">来源</a><br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpClient httpClient = HttpClientBuilder.create().build();</div></pre></td></tr></table></figure></p>
<p>   或者<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建HttpClientBuilder</span></div><div class="line">HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();</div><div class="line"><span class="comment">// HttpClient</span></div><div class="line">CloseableHttpClient httpClient = httpClientBuilder.build();</div></pre></td></tr></table></figure></p>
<p>2、 设置代理，HttpClient4.5.2版本可以使用如下语句：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建代理</span></div><div class="line">HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">"your proxy IP"</span>, port);</div><div class="line">RequestConfig config = RequestConfig.custom().setProxy(proxy).build();</div><div class="line"></div><div class="line"><span class="comment">//设置HttpPost/HttpGet使用代理</span></div><div class="line">httpost.setConfig(config);</div></pre></td></tr></table></figure></p>
<p>3、get或post时，如果访问的网站是https协议的，可以用如下方式访问：信任所有证书，如果可以具体到每个证书，就更好了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">            SSLContext sslContext = <span class="keyword">new</span> SSLContextBuilder().loadTrustMaterial(<span class="keyword">null</span>, <span class="keyword">new</span> TrustStrategy() &#123;</div><div class="line">                <span class="comment">//信任所有</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTrusted</span><span class="params">(X509Certificate[] chain,</span></span></div><div class="line">                                         String authType) <span class="keyword">throws</span> CertificateException &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;).build();</div><div class="line">            SSLConnectionSocketFactory sslsf = <span class="keyword">new</span> SSLConnectionSocketFactory(sslContext);</div><div class="line">            <span class="keyword">return</span> HttpClients.custom().setSSLSocketFactory(sslsf).build();</div><div class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (KeyStoreException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> HttpClients.createDefault();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>最近才开始接触这个工具包，官网上目前已经更新到<a href="http://hc.apache.org/downloads.cgi" target="_blank" rel="external">HttpClient4.5.2</a>了。google的时候看到HttpCl]]>
    </summary>
    
      <category term="HttpClient" scheme="http://www.whtis.com/tags/HttpClient/"/>
    
      <category term="Web相关" scheme="http://www.whtis.com/categories/Web%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java阶段性总结]]></title>
    <link href="http://www.whtis.com/2016/04/21/Java%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://www.whtis.com/2016/04/21/Java阶段性总结/</id>
    <published>2016-04-21T10:29:08.000Z</published>
    <updated>2016-09-14T15:50:25.000Z</updated>
    <content type="html"><![CDATA[<p>花了大半年的时间，算是彻底从头看了一遍Java的基本知识，参考书籍是《Java语言程序设计》原书第五版，作者为Y.daniel Liang，基础篇和提高篇中的重要内容都摘录在了之前的文章中。本文就是对之前的Java总结做个分类，方便自己以后回顾。</p>
<h3 id="第一篇_程序设计基础（1~5章）">第一篇 程序设计基础（1~5章）</h3><h5 id="第一章_计算机、程序和Java概述"><a href="http://www.whtis.com/2015/12/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E7%A8%8B%E5%BA%8F%E5%92%8CJava%E6%A6%82%E8%BF%B0/">第一章 计算机、程序和Java概述</a></h5><h5 id="第二章_基本数据类型和基本操作"><a href="http://www.whtis.com/2015/12/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">第二章 基本数据类型和基本操作</a></h5><h5 id="第三章_控制语句"><a href="http://www.whtis.com/2016/01/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/">第三章 控制语句</a></h5><h5 id="第四章_方法"><a href="http://www.whtis.com/2016/01/11/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%B9%E6%B3%95/">第四章 方法</a></h5><h5 id="第五章_数组"><a href="http://www.whtis.com/2016/01/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E7%BB%84/">第五章 数组</a></h5><h3 id="第二篇_面向对象程序设计（6~10章）">第二篇 面向对象程序设计（6~10章）</h3><h5 id="第六章_对象和类"><a href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/">第六章 对象和类</a></h5><h5 id="第七章_字符串"><a href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/">第七章 字符串</a></h5><h5 id="第八章_继承和多态"><a href="http://www.whtis.com/2016/01/27/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">第八章 继承和多态</a></h5><h5 id="第九章_抽象类和接口"><a href="http://www.whtis.com/2016/01/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">第九章 抽象类和接口</a></h5><h5 id="第十章_面向对象建模"><a href="http://www.whtis.com/2016/01/29/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/">第十章 面向对象建模</a></h5><h3 id="第三篇_图形用户界面设计（11~13章）">第三篇 图形用户界面设计（11~13章）</h3><h5 id="第十一章_图形用户界面程序设计"><a href="http://www.whtis.com/2016/02/05/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">第十一章 图形用户界面程序设计</a></h5><h5 id="第十二章_事件驱动程序"><a href="http://www.whtis.com/2016/02/09/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/">第十二章 事件驱动程序</a></h5><h5 id="第十三章_创建图形用户界面"><a href="http://www.whtis.com/2016/02/15/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/">第十三章 创建图形用户界面</a></h5><h3 id="第四篇_异常处理、I/O（15~16章）">第四篇 异常处理、I/O（15~16章）</h3><h5 id="第十五章_异常和断言"><a href="http://www.whtis.com/2016/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80/">第十五章 异常和断言</a></h5><h5 id="第十六章_简单输入输出"><a href="http://www.whtis.com/2016/02/18/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%AE%80%E5%8D%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">第十六章 简单输入输出</a></h5><h3 id="第五篇_数据结构与集合架构">第五篇 数据结构与集合架构</h3><h5 id="第十七章_面向对象数据结构"><a href="http://www.whtis.com/2016/03/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">第十七章 面向对象数据结构</a></h5><h5 id="第十八章_Java集合架构"><a href="http://www.whtis.com/2016/04/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-Java%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84/">第十八章 Java集合架构</a></h5><h3 id="第六篇_多线程">第六篇 多线程</h3><h5 id="第十九章_多线程"><a href="http://www.whtis.com/2016/04/10/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">第十九章 多线程</a></h5><h3 id="网络">网络</h3><h5 id="第二十八章_网络"><a href="http://www.whtis.com/2016/04/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E7%BD%91%E7%BB%9C/">第二十八章 网络</a></h5><hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>花了大半年的时间，算是彻底从头看了一遍Java的基本知识，参考书籍是《Java语言程序设计》原书第五版，作者为Y.daniel Liang，基础篇和提高篇中的重要内容都摘录在了之前的文章中。本文就是对之前的Java总结做个分类，方便自己以后回顾。</p>
<h3 id="第]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第二十八章 网络]]></title>
    <link href="http://www.whtis.com/2016/04/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.whtis.com/2016/04/16/Java学习总结-第二十八章-网络/</id>
    <published>2016-04-16T13:43:48.000Z</published>
    <updated>2016-09-14T15:47:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p><code>基于套接字的通信</code>可以使程序通过指定的套接字进行通信。<code>套接字（socket）</code>是两个主机之间逻辑连接的端点，可以用于发送和接收数据。<br>Java支持流套接字和数据报套接字。<code>流套接字（stream socket）</code>使用传输控制协议（Transmission Control Protocol，TCP）进行数据传输，而<code>数据报套接字（datagram socket）</code>使用的是用户数据报协议（User Datagram Protocol，UDP）。</p>
<h3 id="客户/服务器计算模式">客户/服务器计算模式</h3><ul>
<li>服务器和客户一旦建立连接，客户和服务器就可以通过套接字进行通信。</li>
<li><p>创建<code>服务器套接字（server socket）</code>，并把它附加到一个端口上，服务器从端口监听连接。端口标识套接字上的TCP服务，端口号的范围从0到65536，但是0到1024号是为特权服务保留的端口。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</div><div class="line"><span class="comment">//监听</span></div><div class="line">Socket socket = serverSocket.accept();</div></pre></td></tr></table></figure>
<p><strong>如果企图在已经使用的端口上创建服务器套接字，将会引起<code>java.net.BindException</code>异常。</strong></p>
</li>
<li><p>服务器的监听语句会一直等待，直到一个客户与服务器套接字建立连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket socket = <span class="keyword">new</span> Socket(serverName,port);</div></pre></td></tr></table></figure>
<p>serverName是服务器的域名或IP地址。</p>
</li>
<li><p>通过得到socket的输入输出流，接可以进行数据传输了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InputStream input = socket.getInputStream();</div><div class="line">OutputStream output = socket.getOutputStream();</div></pre></td></tr></table></figure>
<p><strong>建议使用二进制I/O在服务器和客户间进行数据传输，以便提高效率。</strong></p>
</li>
</ul>
<h3 id="网络地址类InetAddress">网络地址类InetAddress</h3><ul>
<li><p>可以使用类InetAddress来求得客户的主机名和IP地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">InetAddress inetAddress = socket.getInetAddress();</div><div class="line">String hostname = inetAddress.getHostName();</div><div class="line">String ip = inetAddress.getHostAddress();</div></pre></td></tr></table></figure>
</li>
<li><p>可以使用静态方法getByName通过主机名或IP地址创建InetAddress的一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InetAddress address = InetAddress.getByName(<span class="string">"www.google.com"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多客户服务">多客户服务</h3><ul>
<li><p>可以使用线程处理服务器上多个客户的同步问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">	Socket socket = serverSocket.accept();</div><div class="line">	Thread thread = <span class="keyword">new</span> ThreadClass(socket);</div><div class="line">	thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务器套接字可以有多个连接。while循环的每次迭代创建一个新的连接。</p>
</li>
</ul>
<h3 id="发送和接收对象">发送和接收对象</h3><ul>
<li>可以在套接字流上使用ObjectInputStream和ObjectOutputStream接收和发送对象。为了能够进行传输，这些对象必须实现<code>Serializable</code>接口。</li>
</ul>
<h3 id="从Web服务器上读取文件">从Web服务器上读取文件</h3><ul>
<li>可以创建一个<code>java.net.URL</code>对象，然后打开一个输入流：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"www.whtis.com"</span>);</div><div class="line">InputStream inputStream = url.openStream();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JEditorPanel类">JEditorPanel类</h3><ul>
<li>Swing提供了一个名叫javax.swing.JEditorPanel的GUI组件，它能够自动地显示普通文本文件、HTML文件和RTF文件。 </li>
<li><p>要显示文件的内容，可以使用setPage（URL）方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPage</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException</span></div></pre></td></tr></table></figure>
</li>
<li><p>当单击编辑窗格中的一个超链接时，JEditorPanel产生<code>javax.swing.event.HyperLink Event</code>事件，通过该事件，我们可以得到超链接的URL，并使用setPage(url)方法显示它。</p>
</li>
</ul>
<h3 id="数据报套接字">数据报套接字</h3><ul>
<li>我们编写的有些网络通信不要求TCP提供可靠的、点对点的通道，这种情况下，数据报通信效率更高。</li>
<li>数据是用<code>分组（packet，或称为包）</code>进行传输的。数据报套接字使用<code>用户数据报协议（User Datagram Protocol，UDP）</code>，该协议不能保证分组不会丢失、或者不会重复接收、或者接收的顺序与发送的顺序不同。</li>
<li><code>数据报（datagram）</code>是独立的，包含自身网络上的传输信息，它的到达、到达的时间和内容都没有保证。</li>
</ul>
<h4 id="DatagramPacket类和DatagramSocket类">DatagramPacket类和DatagramSocket类</h4><ul>
<li>DatagramPacket表示数据报的分组。要为来自客户的传送创建DatagramPacket对象，可以使用构造方法<code>DatagramPacket(byte[] buf,int length,InetAddress host,int prot)</code>。要创建其他所有的DatagramPacket对象，使用构造方法<code>DatagramPacket(byte[] buf,int length)</code>。一旦创建了一个数据报分组，就可以使用getData()方法和setData()方法获取和设置分组中的数据。</li>
<li>数据报套接字类DatagramSocket表示发送和接收数据报分组的套接字。数据报套接字是分组传输服务的发送和接收点。每个在套接字上发送和接收的分组都是独立编址和路由的。<ul>
<li>要创建服务器上的数据报套接字，使用构造方法DatagramSocket(int port),它将套接字绑定到本地主机指定的端口上。</li>
<li>要创建客户上的数据报套接字，使用构造方法DatagramSocket()，它将套接字绑定到本地主机任意一个可用的端口上。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>流套接字的端口号和数据报套接字的端口号是互不相关的。流套接字和数据报套接字能够同时使用同一个端口号。</li>
<li>数据报套接字使用<code>send(DatagramSocket)</code>发送分组，使用<code>receive(DatagramSocket)</code>接收分组。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题28.1 28.3 28.6 28.8 28.9 28.10源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter28/src" target="_blank" rel="external">chapter28</a></li>
<li><p>习题28.6 </p>
<ul>
<li><p>服务器端的输入输出流应该和客户端的对应。</p>
<ul>
<li><p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</div></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器端的顺序应该为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如何判断ObjectInputStream类中readObject()方法是否到达末尾:</p>
<ul>
<li><p>readObject()方法读取数据流到末尾时会抛出<code>java.io.EOFException</code>异常，可以捕获到这个异常并由此判断对象数据读取完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"Address.dat"</span>);</div><div class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        ObjectInputStream InFromFile = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            lists.add(InFromFile.readObject());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (EOFException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">        jTextArea.append(<span class="string">"Data read completed!"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>可以在数据流中添加标识，当读取到标识后，则关闭输出流。例如：可以在写入数据完成后附加<code>null</code>作为标识。</p>
</li>
</ul>
</li>
<li>异常<code>java.io.StreamCorruptedException: invalid type code: AC</code>的出现原因及解决方案<ul>
<li>原因：新建一个ObjecOutputStream类后，在第一次写入时，会附加一个头文件信息，随后的数据不会附加头文件。新建一个ObjectInputStream，在第一次读取时会寻找头文件，之后读取时就不会寻找头文件直接读取数据。如果写入数据时每次都附加头文件，而读取时仅第一次读取头文件，就会抛出上述异常。</li>
<li>解决方案：写文件和读文件要统一，写文件时不能每次都附带头文件，也就是用一个输出流写数据，不要每次写入对象都新建一个输出流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p><code>基于套接字的通信</code>可以使程序通过]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java学习总结-第十九章 多线程]]></title>
    <link href="http://www.whtis.com/2016/04/10/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.whtis.com/2016/04/10/java学习总结-第十九章-多线程/</id>
    <published>2016-04-10T15:17:34.000Z</published>
    <updated>2016-09-14T15:48:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java支持<code>多线程（multithreading）</code>。多线程是指在一个程序中允许同时运行多个任务的能力。</p>
<h3 id="线程的概念">线程的概念</h3><ul>
<li><code>一个线程（thread）</code>是指程序中完成一个任务的有始有终的执行流。使用Java，可以在一个程序中并发的运行多个线程。</li>
<li>多线程可以使程序反应更快，交互性更强，执行效率更高。</li>
<li>Java对多线程程序的开发和运行提供了非常好的支持，包括锁定资源以避免冲突。</li>
<li>每个新线程都是一个对象，它的类实现<code>Runnable</code>接口或者扩展实现了<code>Runnable</code>接口，这种新对象称为<code>可运行对象（runnable object）</code>。</li>
</ul>
<h3 id="创建线程的两种方式">创建线程的两种方式</h3><h4 id="扩展Thread类创建线程">扩展Thread类创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//do something</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现runnable接口创建线程">实现runnable接口创建线程</h4><ul>
<li><p>实现接口：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> run &#123;</div><div class="line">		<span class="comment">//do something</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建线程：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnThread());</div><div class="line">t.start();</div></pre></td></tr></table></figure>
</li>
<li><p>如果用户线程要实现多继承，应该选择实现Runnable接口这种方式。</p>
</li>
</ul>
<h3 id="线程的控制与通信">线程的控制与通信</h3><ul>
<li>Thread类中提供的控制线程的方法：<ul>
<li>start()</li>
<li>interrupt()  中断该线程。如果该线程处于阻塞状态，它就进入重新运行的就绪状态</li>
<li>isAlive()  该方法判断线程是否正处于运行状态</li>
<li>setPriority(int p)</li>
<li>join()  等待该线程结束</li>
<li>sleep(long millis)  </li>
<li>yield()  让该线程暂停执行，允许其他线程开始运行</li>
<li>isinterrupted()</li>
<li>currentThread()  返回当前正在运行的线程对象的引用<br><strong>Thread类还包含stop()、suspend()和resume()。但是这些线程具有内在的不安全因素，因此不建议使用。要替代stop()方法，可以给线程变量赋值为null，指明要停止它的运行。</strong></li>
</ul>
</li>
<li>方法wait()、notify()、notifyAll()定义在Object类中，也可以用于促进活动线程之间的通信。<ul>
<li>wait()  该方法强迫线程等待，直到对调用wait方法的对象调用notify或notifyAll方法。</li>
</ul>
</li>
</ul>
<h4 id="线程的状态">线程的状态</h4><ul>
<li>线程有五种状态：新建、就绪、运行、阻塞或结束。<br><img src="线程的状态.jpg" alt="线程的状态"></li>
<li>有几种原因会使线程进入<code>阻塞状态（Blocked state）</code>：<ul>
<li>可能是它自己调用了join()、sleep()或wait()方法</li>
<li>可能是其他方法调用了如上方法</li>
<li>可能是该线程在等待一个I/O操作的完成</li>
</ul>
</li>
<li>方法interrupt按下列方式中断一个线程：当线程处于就绪状态或运行状态时，给它设置一个中断标志；当线程处于阻塞状态时，它将会被唤醒并进入就绪状态，同时抛出异常java.lang.InterruptedException。即：<strong>中断不仅打断执行过程，也可以打断不执行过程。</strong></li>
</ul>
<h4 id="线程的优先级">线程的优先级</h4><ul>
<li>Java给每个线程指定一个优先级。</li>
<li>Thread类有int型常量MIN_PRIOTITY、NORM_PRIORITY和MAX_PRIORITY，分别代表1、5、10、主线程的优先级是Thread.NORM_PRIORITY。<br><strong>如果总有一个优先级较高的线程在运行，或者有一个相同优先级的线程不退出，那么一个线程可能永远也没有运行的机会。这种情况称为<code>竞争（contention）</code>或<code>资源缺乏（starvation）</code>状态。</strong></li>
</ul>
<h3 id="线程组">线程组</h3><ul>
<li>一个<code>线程组（thread group）</code>是线程的一个集合。可以同时对一个线程组进行唤醒和挂起操作。</li>
<li>可以把一个线程组添加到另一个线程组，构成一个树形结构，除了起始组以外，树中的每个线程组都有一个父线程组。</li>
<li>每个线程都属于一个线程组。</li>
<li>线程组的创建：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ThreadGroup g = <span class="keyword">new</span> ThreadGroup(<span class="string">"thread group"</span>);  <span class="comment">//组名必须是唯一的字符串</span></div><div class="line">Thread t = <span class="keyword">new</span> Thread(g,<span class="keyword">new</span> ThreadClass(),<span class="string">"label for the thread"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>线程组里的线程必须分别启动</strong></p>
<h3 id="线程之间的同步与协作">线程之间的同步与协作</h3><p>多个线程同时访问一个共享资源会引起<code>资源冲突（race condition）</code>。如果一个类的对象在多线程程序中没有引起资源冲突，则称这样的类为<code>线程安全的（thread-safe）</code>。</p>
<h4 id="同步化实例与静态方法">同步化实例与静态方法</h4><ul>
<li>为避免资源冲突，应该防止多个线程同时进入程序的某一特定部分，程序中这样的部分称为<code>临界区（critical region）</code>。</li>
<li>可以使用关键字<code>Synchronized</code>来使方法的通信同步，以便一次只有一个线程可以访问该方法。</li>
<li>一个同步方法在执行前需要加锁：对于实例方法，要给调用该方法的对象加锁；对于静态方法，要给这个类加锁。</li>
</ul>
<h4 id="同步语句">同步语句</h4><ul>
<li><p>当执行方法中某一个代码块（也成为体）时，同步语句不仅仅可以用于获准给该对象加锁，而且可以用于要求对任何对象加锁。这个代码块称为<code>同步块（synchronized block）</code>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (expr) &#123;  <span class="comment">//表达式expr必须能求出对象的引用</span></div><div class="line">	语句组；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>同步语句允许对任何对象加锁，所以可以同步地访问一个对象而不仅仅是一个方法。</p>
</li>
<li><p>任何同步的实例方法都可以转化为同步语句。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">xMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//方法体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		<span class="comment">//方法体</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="线程之间的协作">线程之间的协作</h4><ul>
<li>通过在临界区上多个线程的相互排斥，线程同步完全可以避免资源冲突的发生，但是有时候我们还需要线程之间的相互协作。</li>
<li>wait、notify和notifyAll方法可以用来实现线程之间的相互通信。这些方法必须在同步方法中调用，或者在接受这些方法的对象的同步块中调用；否则会抛出异常<code>IllegalMonitorStateException</code>。</li>
</ul>
<h4 id="死锁">死锁</h4><ul>
<li>使用一种名为<code>资源排序（resource ordering）</code>的简单技术可以轻易的避免死锁的发生。该技术是给每一个需要锁定的对象定义一个顺序，确保每个线程都按这个顺序来锁定对象。</li>
</ul>
<h3 id="进程条JProcessBar">进程条JProcessBar</h3><ul>
<li>进程条JProcessBar是一个图形组件，用来以图示的方式显示有界区间内的一个值。</li>
<li>进程条的常用属性有orientation、minimum、value和maximum等。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>线程对象从来不会直接引用run方法，到了执行某个线程的时候，Java虚拟机调用该线程的run方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li><p>习题19.2 19.3 19.4 19.6 19.7 19.8 19.9 19.11源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter19/src" target="_blank" rel="external">chapter19</a></p>
</li>
<li><p>习题19.7要求使用同步集合解决习题19.6多线程出现异常java.util.ConcurrentModificationException的问题。当完成这个题并且多次执行时，会出现下面这个问题，暂时不知道是否是错误：<br>向规则集添加数字时使用如下语句：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hashSet.add(((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>)) + <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>  控制台输出为以下结果：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>也就是说，随机数在规则集内被重新排序了，并且在使用迭代算子遍历时被打印到控制台。排序的原因猜测是同步规则集的方法导致的：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.synchronizedSet(hashSet);</div></pre></td></tr></table></figure>
</li>
<li><p>习题19.9要求写一个死锁程序，形成死锁的条件如下：</p>
<ul>
<li><blockquote>
<p>互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。</p>
</blockquote>
</li>
<li><blockquote>
<p>不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。</p>
</blockquote>
</li>
<li><blockquote>
<p>占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。</p>
</blockquote>
</li>
<li><blockquote>
<p>循环等待条件。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。</p>
</blockquote>
</li>
</ul>
<p>根据这个原则，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $19<span class="title">_9</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      DeadThread t1 = <span class="keyword">new</span> DeadThread();</div><div class="line">      DeadThread t2 = <span class="keyword">new</span> DeadThread();</div><div class="line">      t1.flag = <span class="number">0</span>;</div><div class="line">      t2.flag = <span class="number">1</span>;</div><div class="line">      t1.start();</div><div class="line">      t2.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">  * 线程1锁定o1后休眠1s，使得有机会执行线程2，线程2锁定o2后，等待线程1释放o1，线程1此时锁定了o1，等待线程2</div><div class="line">  * 释放o2，形成死锁。</div><div class="line">  *</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (flag==<span class="number">0</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"flag="</span> + flag);</div><div class="line">          <span class="keyword">synchronized</span> (o1) &#123;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  Thread.sleep(<span class="number">1000</span>);</div><div class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">synchronized</span> (o2) &#123;</div><div class="line">                  System.out.println(<span class="string">"o2 locked"</span>);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (flag==<span class="number">1</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"flag="</span> + flag);</div><div class="line">          <span class="keyword">synchronized</span> (o2) &#123;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  Thread.sleep(<span class="number">1000</span>);</div><div class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">synchronized</span> (o1) &#123;</div><div class="line">                  System.out.println(<span class="string">"o2 locked"</span>);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java支持<code>多线程（multithreadi]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第十八章 Java集合架构]]></title>
    <link href="http://www.whtis.com/2016/04/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-Java%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.whtis.com/2016/04/01/Java学习总结-第十八章-Java集合架构/</id>
    <published>2016-04-01T03:41:32.000Z</published>
    <updated>2016-09-14T15:49:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数组线性表和链表是Java中的预定义结构。除此之外，Java还引入了几种可以有效组织和处理数据的接口和类，这些接口和类组成了<code>Java集合架构（Java Collection Framework）</code>。<br>一个<code>集合（collection）</code>就是一个存储一组对象的容器，一般将这些对象称为集合的<code>元素（element）</code>。Java集合构架支持三种类型的集合：<code>规则集（set）、线性表（list）和图（map）</code>，它们分别定义在接口Set、List与Map中。Set的实例存储一组互不相同的元素，List的实例存储一组顺序排列的元素，Map的实例存储一组对象，每个对象都有一个关联的键值。</p>
<p><img src="Set&amp;List类.png" alt="Set和List接口是Collection接口的子接口"><br><img src="Map类.png" alt="Map的实例存储一组对象以及与它们关联的键值"></p>
<h3 id="Collection接口和AbstractCollection类">Collection接口和AbstractCollection类</h3><ul>
<li>Collection接口是处理对象集合的根接口。它的方法详见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="external">API</a>。AbstractCollection类是提供对Collection接口部分实现的便利类。除了size方法和iterator方法之外，它实现了Collection接口中的所有方法。</li>
<li>Iterator接口提供next（）方法，可以依次访问集合中存储的元素。<br><strong>Collection接口中有些方法不能在具体子类中实现。这种情况下，这些方法会抛出异常<code>java.lang.UnsupportedOperationException</code>，该异常是RuntimeException异常的一个子类。</strong></li>
</ul>
<h3 id="规则集Set">规则集Set</h3><ul>
<li>Set接口扩展Collection接口，它没有引入新的方法和常量，只规定它的实例不能包含相同的元素。</li>
<li>AbstractSet类是一个便利类，它扩展了AbstractCollection类并实现了Set接口。</li>
<li>Set接口的三个具体类是HashSet、LinkedHashSet和TreeSet。</li>
</ul>
<h4 id="散列集HashSet">散列集HashSet</h4><ul>
<li>HashSet类可以用来存储互不相同的任何元素。考虑效率的因素，添加到散列集之中的对象必须实现hashCode方法，适当地散列分布散列码。</li>
<li>两个不等的对象可能有相同的散列码。</li>
</ul>
<h4 id="链式散列集LinkedHashSet">链式散列集LinkedHashSet</h4><ul>
<li>在HashSet中元素是没有顺序的，而在LinkedHashSet中，可以按元素插入集合的顺序进行提取。</li>
<li>LinkedHashSet中的元素存储时保持插入的顺序，要想自定义顺序，可以使用<code>TreeHashSet</code>。<br><strong>如果不需要使元素按其插入的顺序进行存储，应该使用HashSet，它的效率要比LinkedHashSet高。</strong></li>
</ul>
<h4 id="树形集TreeSet">树形集TreeSet</h4><p>SortSet是Set的一个子接口，它保证规则集中的元素是有序的。TreeSet是实现SortedSet接口的一个具体类。只有当对象之间可以互相比较是，才可以将它们添加到树形集TreeSet中。</p>
<ul>
<li>有两种方法实现对象的比较：<ul>
<li>使用Comparable接口。如果添加到规则集中的对象是Comparable的实例，就可以使用compareTo方法来比较。这种方法定义的序通常称为<code>自然顺序（natural order）</code>。<strong>参见习题18.7</strong></li>
<li>如果该类不支持Comparable接口，或者在实现Comparable接口的类中不想使用compareTo方法进行比较，可以给规则集的元素创建一个比较器。这种方法定义的序称为<code>比较器顺序（order by comparator）</code>。</li>
</ul>
</li>
<li>创建树形集的好的方法是使用构造方法<code>TreeSet(Collection c)</code>，这样只需要对规则集进行一次排序，效率较高。<br>**如果向树形集添加一个与集合中已有元素不可比的对象，将会发生运行错误<code>ClassCastException</code>。</li>
</ul>
<h3 id="比较器接口Comparator">比较器接口Comparator</h3><ul>
<li>有时想把不同类型的元素添加到同一个树形集内，可以定义一个比较器来比较这些元素。可以创建一个<code>java.util.Comparator</code>接口的类。其方法如下：<ul>
<li>public int compare(Object element1,Object element2)  </li>
<li>public boolean equals(Object element)<br>**Object类也定义了equals方法，因此实现接口时不实现equals方法也不会报错，但是实现该方法可以快速的判断，提高效率。</li>
</ul>
</li>
<li>树形集要想使用一个比较器，必须使用构造方法TreeSet（Comparator comparator）来创建一个有序集。</li>
</ul>
<h3 id="线性表List">线性表List</h3><p>线性表允许在一个集合中存储重复的元素。</p>
<ul>
<li>List接口扩展Collection接口，添加了<code>面向位置（position-oriented）</code>的操作，并且添加了能够双向遍历线性表的新迭代探子。（ListIterator）</li>
</ul>
<h4 id="数组线性表ArrayList和链表LinkedList">数组线性表ArrayList和链表LinkedList</h4><ul>
<li>如果需要使用下标随机访问元素，并且处理在末尾之外，不在其他位置插入或删除元素，使用ArrayList。</li>
<li>如果需要在线性表的任意位置上插入或删除元素，应该选择LinkedList。</li>
<li>如不要求在线性表中插入或删除元素，数组是效率最高的数据结构。</li>
</ul>
<h4 id="向量类Vector">向量类Vector</h4><ul>
<li>Vector类除了包含用于访问和修改向量的同步方法外，它与ArrayList是相同的。同步方法用于防止两个或多个线程同时访问向量时引起数据冲突。</li>
<li>当不需要同步时，最好使用ArrayList，它比Vector快得多。</li>
</ul>
<h4 id="栈类stack">栈类stack</h4><p>栈类stack是最为Vector类的扩展实现的。</p>
<h3 id="一般类型的使用">一般类型的使用</h3><ul>
<li>所有的集合都支持一般类型，可以用记号<code>&lt;&gt;</code>给任一集合中的元素指定一个特定的类型。</li>
<li>从一个只有一种指定元素类型的集合中取值时，不需要进行类型转换。</li>
</ul>
<h3 id="图Map">图Map</h3><ul>
<li>Map接口建立元素和键值的一个映射关系。键值就是下标。</li>
<li>一个图中不能有重复的键值，每个键值对应一个值。</li>
<li>AbstractMap类是一个实现Map接口的便利类，除了entrySet()方法外，它实现了Map接口中的其他方法。SortedMap接口扩展Map接口，其中的映像是以键值升序的方式排列的。</li>
<li>散列图HashMap、链式散列图LinkedHashMap和树形图TreeMap三种类是实现Map接口的具体类。</li>
</ul>
<h4 id="HashMap">HashMap</h4><p>对于定位查找一个值、插入一个映像或删除一个映像，HashMap的效率是很高的。</p>
<h4 id="LinkedHashMap">LinkedHashMap</h4><ul>
<li>它支持图中元素排序。在LinkedHashMap中，元素既可以按照它们插入的顺序排序（称为<code>插入排序（insertion order）</code>），也可以按它们最后一次访问时间的顺序，从最早到最晚（称为<code>访问顺序（access order）</code>）。<ul>
<li>无参构造方法是以插入顺序创建LinkedHashMap对象的。</li>
<li>使用构造方法LinkedHashMap（initialCapacity，loadFactor，true）可以以访问顺序创建LinkedHashMap对象。</li>
</ul>
</li>
</ul>
<h4 id="TreeMap">TreeMap</h4><ul>
<li>它实现了SortedMap接口，它可以按照键值排好的顺序遍历图。键值可以使用Comparable接口或Comparator接口来排序。</li>
<li>构造方法：<ul>
<li>TreeMap（）如果实现了Comparable接口，就可以使用compareTo方法来对集合内中的元素进行排序。</li>
<li>TreeMap（Comparator comparator）可以使用指定比较器来对图中元素进行排序。</li>
</ul>
</li>
</ul>
<p><strong>Map接口不含有迭代探子，为遍历一个图，可以用Map接口的方法<code>enrtySet()</code>来创建一个映像的规则集。该规则集内的每个元素都是一个字符串，它是由代表键值对象的字符串与其对应的映像用等号连接而成的。</strong></p>
<h3 id="Collections类">Collections类</h3><p>Collections类包含管理集合与图、创建同步集合类、创建只读集合类等<code>静态方法</code>。</p>
<h3 id="Arrays类">Arrays类</h3><p>Arrays类中包含对数组进行排序、查找、比较和填充元素的各种<code>静态方法</code>。它还包含了将数组转为线性表的方法。</p>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>Java集合架构中的所有具体类都实现了Cloneable和Serializable接口，所以它们的实例都是可复制和可复制的。</li>
<li>Collections类和Arrays类提供的方法都是静态方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题18.1 18.2 18.3 18.5 18.6 18.7 18.9源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter18/src" target="_blank" rel="external">chapter18</a></li>
<li><p>18.5按字典升序显示单词的实现思路：使用线性表存储每个单词，使用构造方法sort（Comparator comparator）对表中的对象排序，比较器的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DicComparable</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">        String s1 = ((String) (o1)).toLowerCase();</div><div class="line">        String s2 = ((String) (o2)).toLowerCase();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s1.compareTo(s2) &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1.compareTo(s2) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>18.7将单词按出现频率升序显示，实现思路：创建一个实现Comparable接口的类Wordoccurrence,该类包含两个域word和count，使用compareTo方法来比较单词的出现次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordOccurrence</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</div><div class="line"></div><div class="line">    String word;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordOccurrence</span><span class="params">(String word, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.word = word;</div><div class="line">        <span class="keyword">this</span>.count = count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (count &gt; ((WordOccurrence) o).count) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; ((WordOccurrence) o).count) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数组线性表和链表是Java中的预定义结构。除此之外，Ja]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第十七章 面向对象数据结构]]></title>
    <link href="http://www.whtis.com/2016/03/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.whtis.com/2016/03/22/Java学习总结-第十七章-面向对象数据结构/</id>
    <published>2016-03-22T15:44:38.000Z</published>
    <updated>2016-09-14T15:48:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数据结构是按某种方式组织的数据集合。用面向对象的观点来看，一个数据结构就是一个存储着其他对象的对象，存储在数据结构内的对象称为数据或元素。因此数据结构又被称为<code>容器对象（container object）</code>或<code>集合对象（collection object）</code>。<br>本章介绍线性表、堆栈、队列和二叉树等四种动态数据结构。</p>
<h3 id="线性表">线性表</h3><ul>
<li>线性表是存储顺序排列的数据时最常用的数据结构。</li>
<li>线性表可以由数组或者链表实现。这两种类具有相同的操作，但是具有不同的数据域，这些相同的操作可以由接口或抽象类生成。在设计时同时提供接口与抽象类是把它们的优点结合到一起的好策略，这样的抽象类称为<code>便利类</code>。</li>
<li>数组线性表<ul>
<li>数组是一种固定大小的数据结构。但仍然可以采用如下方法实现动态改变：当数组不能再存储线性表中的新元素时，创建一个更大的数组来代替当前数组。这样的数组线性表是一个动态的数据结构。</li>
</ul>
</li>
<li>链表<ul>
<li>由数据创建的线性表，在特定位置进行插入和删除操作效率是很低的，因此可以采用链表结构来提高效率。</li>
<li>链表的遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Node temp = first;</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</div><div class="line">     temp = temp.next;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="栈和队列">栈和队列</h3><ul>
<li>栈（stack）可以看做是一种特殊的线性表，访问、插入和删除它的元素只能在栈的一端（栈顶）进行。队列可以表示一个排队等待的队伍。它可以看做是一种特殊的线性表，它的元素只能从队列的末端（队列尾）插入，从开始端（队列头）访问和删除。</li>
<li>栈：使用数组线性表来实现栈效率较高。</li>
<li>队列：用链表实现。</li>
</ul>
<h3 id="二叉树">二叉树</h3><ul>
<li>线性表、栈和队列都是由一列元素构成的线型结构。二叉树是一个层次结构，它要么是空集，要么由一个被称为<code>根（root）</code>的元素和两棵不同的子树组成，这两个子树分别称为<code>左子树（left subtree）</code>和<code>右子树（right subtree）</code>。</li>
<li>一个结点的左（右）子树的根节点称为该结点的<code>左（右）孩子（left（right）child）</code>。没有孩子的结点称为<code>叶结点（leaf）</code>。<code>二叉搜索树（binary search tree）</code>是一种常用的特殊二叉树。二叉搜索树的特征是：对它的每一个结点来说，左子树中结点的值都小于该结点的值，右子树中的结点的值都大于该节点的值。</li>
</ul>
<h4 id="二叉树的遍历">二叉树的遍历</h4><ul>
<li><p><code>中序遍历（inorder）:</code>首先访问当前结点的左子树，然后访问当前结点，最后访问该结点的右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       inorder(root.left);</div><div class="line">       System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">       inorder(root.right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>后序遍历（postorder）：</code>首先访问当前结点的左子树，然后访问该结点的右子树，最后访问该结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">       postorder(root.left);</div><div class="line">       postorder(root.right);</div><div class="line">       System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>前序遍历（preorder）：</code>首先访问当前结点，然后访问该结点的左子树，最后访问该结点的右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">       System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">       preorder(root.left);</div><div class="line">       preorder(root.right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>深度优先遍历（depth-first）：</code>与前序遍历相同。</p>
</li>
<li><code>广度遍历法（breadth-first）：</code>一层一层的访问树的结点。<br><strong>如果元素的插入顺序不同，树看起来可能不一样，但是只要元素的集合相同，中序序列是一样的。</strong></li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>基本类型的数据不能作为对象存储，但是可以给基本数据类型值创建对应包装类的对象。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题17.1、17.2、17.3、17.6源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter17/src" target="_blank" rel="external">chapter17</a></li>
<li>写双向链表时，在执行下列方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    TreeNode current = first;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    TreeNode target = current.next;</div><div class="line">    target.pravious.next = target.next;</div><div class="line">    target.next.pravious = target.pravious;</div><div class="line">    size--;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>执行到第7行语句时：list的状态是<code>Method threw &#39;java.lang.NullPointerException&#39; exception. Cannot evaluate _17_3.DoubleLinkedList.toString()</code>,但是整个方法执行完后，不会报错，原因暂时不知道。</p>
<ul>
<li>习题17.6中需要写一个方法，返回二叉树的深度，深度是指二叉树最长路径的结点个数。代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> left = treeDepth(root.left);</div><div class="line">    <span class="keyword">int</span> right = treeDepth(root.right);</div><div class="line">    <span class="keyword">return</span> left &gt; right ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数据结构是按某种方式组织的数据集合。用面向对象的观点来看]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[base64编码和解码示例代码]]></title>
    <link href="http://www.whtis.com/2016/03/05/base64%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.whtis.com/2016/03/05/base64编码和解码示例代码/</id>
    <published>2016-03-05T15:55:01.000Z</published>
    <updated>2016-09-14T15:46:10.000Z</updated>
    <content type="html"><![CDATA[<p>写密码管理器时，一直在找一种加密方式，除了自己实现外，我还在网上发现了一个不错的方法，<a href="http://www.q3060.com/list6/list144/2717.html" target="_blank" rel="external">源地址在这里</a>。这里仅作抄录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sun.misc.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.regex.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ht on 2016/2/24.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testorigin</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">        TransformBS1 transformBS = <span class="keyword">new</span> TransformBS1();</div><div class="line">        transformBS.testS2B();</div><div class="line">        transformBS.testB2S();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 今天在网上看到一个程序游戏，只要目的是为了能够将文件中的01二进制数据读取到程序然后通过base64解码，再转换成程序</div><div class="line"> * 所以，自己写了个程序：（1）将一段字符串进行base64处理，然后转换成二进制输出。（2）将一段二进制数据转换成字符串，然后base64解码到对应的字符串</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformBS1</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @ see 字符串进行base64编码后转换为二进制形式,如：（h(原字符)-&gt;a(编码后)-&gt;01100001010000010011110100111101(二进制形式)）</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testS2B</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"=========字符串到二进制！============="</span>);</div><div class="line">        BASE64Encoder e = <span class="keyword">new</span> BASE64Encoder();</div><div class="line"><span class="comment">//编码器</span></div><div class="line">        String s = <span class="string">"我爱你"</span>;</div><div class="line">        System.out.println(<span class="string">"尚未编码的数据："</span> + s);</div><div class="line">        s = e.encode(s.getBytes());</div><div class="line"><span class="comment">//获得base64编码后的字符串</span></div><div class="line">        System.out.println(<span class="string">"编码后的数据："</span> + s);</div><div class="line">        System.out.print(<span class="string">"二进制数据："</span>);</div><div class="line">        String s1 = <span class="string">"whtis\n"</span> + <span class="string">"我爱你\n"</span> + s;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1.toCharArray()) &#123;</div><div class="line"><span class="comment">//对字符串中的字符逐个转换成二进制数据</span></div><div class="line">            String binaryStr = Integer.toBinaryString(c);</div><div class="line"><span class="comment">//单个字符转换成的二进制字符串</span></div><div class="line">            String format = String.format(<span class="string">"%8s"</span>, binaryStr);</div><div class="line"><span class="comment">//因为上面转换成二进制后的位数不够8位所以不足的前面补空格，这里是考虑到能够从数据文件批量读取。</span></div><div class="line">            format = format.replace(<span class="string">" "</span>, <span class="string">"0"</span>);</div><div class="line"><span class="comment">//高位空格替换成0，其实编码后的数据最大范围为2的6次方，首位一定是空格，不然就要用format.startWith(" ");来判断</span></div><div class="line">            System.out.print(format);</div><div class="line"><span class="comment">//输出</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"\n=========字符串到二进制结束！============="</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @ see 二进制形式转换为字符串后进行base64解码的字符串如：(01100001010000010011110100111101-&gt;a-&gt;h)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB2S</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"=========二进制到字符串开始！============="</span>);</div><div class="line">        StringBuffer results = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="comment">//保存尚未解码的数据结果</span></div><div class="line">        String binaryStr = <span class="string">"01110111011010000111010001101001011100110000101011000100001000111100100011000110011110110000000001010001101010110111101101001010100100011010100110100011010010111100000110101010011000011001001100111"</span>;</div><div class="line"><span class="comment">//二进制数据，这里是取用上面程序的最后结果</span></div><div class="line">        System.out.println(<span class="string">"二进制数据："</span> + binaryStr);</div><div class="line"><span class="comment">//这里采用正则表达式来匹配8位长度的数据，然后一个个find()</span></div><div class="line">        Matcher matcher = Pattern.compile(<span class="string">"\\d&#123;8&#125;"</span>).matcher(binaryStr);</div><div class="line"><span class="comment">//定义匹配模式并，获取模式</span></div><div class="line">        BASE64Decoder d = <span class="keyword">new</span> BASE64Decoder();</div><div class="line"><span class="comment">//解码器</span></div><div class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</div><div class="line"><span class="comment">//在binaryStr中找到了8位长度的数据，依次往后面找</span></div><div class="line">            <span class="keyword">int</span> intVal = Integer.valueOf(matcher.group(), <span class="number">2</span>);</div><div class="line"><span class="comment">//matcher.group()中存储了找到匹配模式的数据，这里以2进制的形式转换为整数</span></div><div class="line">            results.append((<span class="keyword">char</span>) intVal);</div><div class="line"><span class="comment">//将整数转换为对应的字符，并添加到结果中</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"尚未解码的数据："</span> + results);</div><div class="line"><span class="comment">//输出尚未解码的数据</span></div><div class="line">        String s = <span class="keyword">new</span> String(d.decodeBuffer(results.toString()));</div><div class="line"><span class="comment">//得到解码后的数据</span></div><div class="line">        System.out.println(<span class="string">"解码后的数据："</span> + s);</div><div class="line"><span class="comment">//输出解码后的数据</span></div><div class="line">        System.out.println(<span class="string">"=========二进制到字符串结束！============="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>写密码管理器时，一直在找一种加密方式，除了自己实现外，我还在网上发现了一个不错的方法，<a href="http://www.q3060.com/list6/list144/2717.html" target="_blank" rel="external">源地址在这里</]]>
    </summary>
    
      <category term="收集整理" scheme="http://www.whtis.com/tags/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GUI练习之二-密码管理器]]></title>
    <link href="http://www.whtis.com/2016/02/20/GUI%E7%BB%83%E4%B9%A0%E4%B9%8B%E4%BA%8C-%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://www.whtis.com/2016/02/20/GUI练习之二-密码管理器/</id>
    <published>2016-02-20T13:31:46.000Z</published>
    <updated>2016-09-14T15:46:30.000Z</updated>
    <content type="html"><![CDATA[<h3 id="功能说明及演示">功能说明及演示</h3><p><del><strong>Swing不是线程安全的，因此使用过程中应避免多开程序，防止出现莫名奇妙的错误。</strong></del><br>北邮人论坛大神给了解决方案，<a href="http://bbs.byr.cn/#!article/Java/47997" target="_blank" rel="external">链接在这</a>，以下内容为复制粘贴：</p>
<blockquote>
<p>Swing不是线程安全的，但也不是大问题。只要把所有的对Swing窗体的的操作都放在专门的线程（event dispatch thread）里做就行了。有一个模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SwingUtilities.invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        createAndShowGUI();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样就线程安全了。这里有详细说明： <a href="http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html" target="_blank" rel="external">http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html</a></p>
</blockquote>
<h4 id="说明">说明</h4><p>综合学习的GUI图形设计和输入输出的知识，实现了一个简易的密码管理器，主要功能如下：</p>
<ul>
<li>可以自己选择密码文件的存放位置</li>
<li>可以选择生成的密码是否可以用文本查看器查看</li>
<li>可以连续的写入新数据</li>
<li>可以根据关键字和密码条件生成相应的密码字符，并提供MD5的显示与查看功能</li>
<li>可以根据网站/网址名进行简单的查看功能</li>
<li>可以同步显示所有存在的密码文件列表</li>
<li>可以选择是否在执行生成按钮后刷新页面，方便直接书写下一个密码文件</li>
<li>其他小功能</li>
</ul>
<h4 id="实现思路">实现思路</h4><p>1、存储密码的同时，将生成密码的条件设置为常量，存储在一个整数数组中（waysOfWirte），并将这值附在生成的密码最后，取值时同时取出来，但是不显示在用户界面上。<br>2、利用文件后缀名的不同区别密码文件的存储格式（二进制存储方式后缀为.w，文本可读后缀名为.wf）。</p>
<h4 id="演示">演示</h4><ul>
<li>初始化设置，程序会在同目录下创建一个名为<code>.pmconfig.w</code>的文件，该文件将密码文件的存放路径写入供以后使用：<br><img src="http://7xnttb.com1.z0.glb.clouddn.com/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C.gif" alt="初始化操作.gif"></li>
<li>主界面的操作：包括密码文件的生成、查看、更新以及删除等操作：<br><img src="http://7xnttb.com1.z0.glb.clouddn.com/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%BB%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C.gif" alt="主界面操作.gif"></li>
</ul>
<h3 id="问题记录">问题记录</h3><ul>
<li>如何回车后使光标出现在下一个输入框中：<br>使用<code>requestFocus（）</code>方法</li>
<li><p>如何创建一个文件夹:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">File fileDir = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\ht\\IdeaProjects\\PasswordGenerated\\PasswdGenetated\\"</span>);</div><div class="line"><span class="keyword">if</span> (!fileDir.isDirectory()) &#123;</div><div class="line"> fileDir.mkdir();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如何获取系统剪切板并设置内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();</div><div class="line"><span class="comment">//复制到剪切板上</span></div><div class="line">StringSelection ss = <span class="keyword">new</span> StringSelection(password);</div><div class="line">clipboard.setContents(ss, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>如何获取当前系统的目录树并选取目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">JFileChooser fileChooser = <span class="keyword">new</span> JFileChooser();</div><div class="line">   fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);</div><div class="line">   <span class="keyword">int</span> i = fileChooser.showOpenDialog(<span class="keyword">null</span>);</div><div class="line">   <span class="keyword">if</span> (i == fileChooser.APPROVE_OPTION) &#123;</div><div class="line">       String path = fileChooser.getSelectedFile().getAbsolutePath();</div><div class="line">       String name = fileChooser.getSelectedFile().getName();</div><div class="line">       System.out.println(path + name);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>为了保证跨平台使用，将windows路径中的”\“替换为”/“</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"/"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>如何实现初始化界面设置密码文件位置后隐藏该界面，继而出现主界面<br>PasswordManger类中initFrame和mainFrame的先后设置。</p>
</li>
<li><p>如何使JList能够实时显示密码文件的个数</p>
<ul>
<li><p>使用<code>setModel（javax.swing.ListModel&lt;E&gt; model）</code>方法。该方法要求传入一个Model对象，ListModel的使用用例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileModel</span> <span class="keyword">extends</span> <span class="title">AbstractListModel</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> String[] files;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileModel</span><span class="params">(String[] files)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.files = files;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> (index + <span class="number">1</span>) + <span class="string">"."</span> + files[index++];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> files.length;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>ListModel是一个接口，如果实现该接口，需要实现一些不必要的方法：<code>void addListDataListener(ListDataListener l)</code>和<code>void removeListDataListener(ListDataListener l)</code>,但是Java提供了一个便捷类AbstractListModel，继承该类，就可以避免实现以上方法。</p>
</li>
<li>除了AbstractListModel类，还有其他抽象类如DefaultListModel，但是DefaultListModel实现了ListModel的所有方法，因此可以做的更改比较小。</li>
<li>为了监听FileModel的变化，可以采用这种方法：在每次JList内容发生变化时重新创建一个FIleModel，传入的是更新后的数组，再使用JList的<code>updateUI()</code>方法，就可以动态显示JList的内容了。<br><em>可以给FileModel添加一个监听器类<code>ListDataListener</code>,并实现该接口的抽象方法。（网上介绍，未做）</em><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateJList</span><span class="params">(String fileDirPath)</span> </span>&#123;</div><div class="line">        String[] files = <span class="keyword">new</span> File(fileDirPath).list();</div><div class="line">        FileModel fileModel = <span class="keyword">new</span> FileModel(files);</div><div class="line">        mainFrame.getJlFileName().setModel(fileModel);</div><div class="line">        mainFrame.getJlFileName().updateUI();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">- 根据指定条件生成密码</div><div class="line">  + 我使用如下方法，返回的字符都是字符<span class="string">'A'</span></div><div class="line">  ```<span class="function">java</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">generateChar</span><span class="params">(<span class="keyword">char</span> aChar, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> &#123;</div><div class="line">        <span class="keyword">char</span> c = <span class="string">'A'</span>;</div><div class="line">        <span class="keyword">int</span> a = aChar + <span class="number">3</span>;</div><div class="line">        <span class="keyword">if</span> (a &gt;= low &amp;&amp; a &lt;= high) &#123;</div><div class="line">            c = (<span class="keyword">char</span>) a;</div><div class="line">  <span class="comment">//          return c;</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; low) &#123;</div><div class="line">  <span class="comment">//          return generateChar((char) (a + 6), low, high);</span></div><div class="line">  			  generateChar((<span class="keyword">char</span>) (a + <span class="number">6</span>), low, high);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; high) &#123;</div><div class="line">  <span class="comment">//          return generateChar((char) (a - 30), low, high);</span></div><div class="line">  		      generateChar((<span class="keyword">char</span>) (a - <span class="number">30</span>), low, high);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>问题原因：递归不设出口，每次递归返回的值都在递归自己这一层，无法返回到最初的一层<br>解决方法：使用注释掉的三条语句，删除相应的错误语句。<br><strong>递归不设出口毫无意义</strong></p>
<ul>
<li>异常<br><code>java.lang.stackOverflow</code> 堆栈溢出，原因是递归太深</li>
</ul>
</li>
<li><p>生成密码的MD5值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5 = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generateMD5</span><span class="params">(String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span>[] bs = md5.digest(password.getBytes());</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">40</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> x : bs) &#123;</div><div class="line">            <span class="keyword">if</span> ((x &amp; <span class="number">0xff</span>) &gt;&gt; <span class="number">4</span> == <span class="number">0</span>) &#123;</div><div class="line">                sb.append(<span class="string">"0"</span>).append(Integer.toHexString(x &amp; <span class="number">0xff</span>));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sb.append(Integer.toHexString(x &amp; <span class="number">0xff</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>初始选取配置文件路径时若该路径存在其他文件，应该避免出现在JList中</p>
</li>
</ul>
<h3 id="源码">源码</h3><p>见我的GitHub：<a href="https://github.com/whtis/PasswordManager/tree/master/src" target="_blank" rel="external">PasswordManager</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="功能说明及演示">功能说明及演示</h3><p><del><strong>Swing不是线程安全的，因此使用过程中应避免多开程序，防止出现莫名奇妙的错误。</strong></del><br>北邮人论坛大神给了解决方案，<a href="http://bbs.by]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="小练习" scheme="http://www.whtis.com/tags/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十六章 简单输入输出]]></title>
    <link href="http://www.whtis.com/2016/02/18/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%AE%80%E5%8D%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://www.whtis.com/2016/02/18/Java学习总结-第十六章-简单输入输出/</id>
    <published>2016-02-18T11:37:58.000Z</published>
    <updated>2016-09-14T15:49:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章主要讨论数据持久化的问题。一般Java程序在结束后所有存储在内存中的数据都会消失，为了保留这些数据，就要学会如何将它们存储到磁盘文件或光盘文件中。<br>本章介绍的主要是两个方面的内容：文本I/O和二进制I/O。为了知识的连贯性，需要先介绍相关的知识，以方便理解。<br><strong>计算机中所有文件都是以二进制格式来存储的。文本I/O是在二进制I/O基础上提供了一层抽象，它封装了字符的编码和解码过程，在文本I/O中自动进行编码和解码。</strong></p>
<h3 id="提前需要知道的一些知识">提前需要知道的一些知识</h3><ul>
<li>windows和Unix文件存储目录的不同。</li>
<li>位、字节、字符、ASCII码和统一码Unicode相关知识。<br>位，英文是bit，是用来表示计算机数据的一种计量单位，8bit为一个字节，ASCII码采用一个字节存储二进制数据，Java中统一码采用两个字节进行存储，统一码的低字节就是ASCII码，因此在Java中，字符是由两个字节构成的。</li>
<li>Java中基本数据类型都占几个字节。如，int类型是4个字节，char类型是2个字节。</li>
</ul>
<h3 id="文件类File">文件类File</h3><p>无论是文本I/O还是二进制I/O的构造方法，都需要传入文件类参数或者文件名参数。</p>
<h4 id="文件系统相关">文件系统相关</h4><ul>
<li>目录路径与文件名全称是平台依赖的。</li>
<li>为了解决不同平台路径与分隔符的问题，File类提供了四个常量：<ul>
<li>File.PathSeparator </li>
<li>File.PathSeparatorChar <code>&quot;/&quot;</code>or<code>&quot;\&quot;</code> </li>
<li>File.Separator </li>
<li>File.SeparatorChar <code>&quot;;&quot;</code>or<code>&quot;:&quot;</code></li>
</ul>
</li>
<li><code>绝对路径（absolute path）</code>名是依赖于系统的，如果想开发平台无关的程序，一定不要用绝对路径。可以使用和平台无关的常量创建一个相对路径。（简单的方法是无论Win还是Linux，相对路径分隔符都使用”/“即可。）</li>
</ul>
<h4 id="File类的常用方法简录">File类的常用方法简录</h4><ul>
<li>构造方法：<ul>
<li>File（pathname：String）<br>······</li>
</ul>
</li>
<li>常用方法<ul>
<li>exists（） 检测文件是否存在</li>
<li>isDirectory（）/isFile（） 是目录/文件</li>
<li>isAbsolute（） 该文件是否由绝对路径创建</li>
<li>getAbsolutePath（） 返回File对象的绝对路径</li>
<li>getCanonicalPath（） 返回值与getAbsolutePath（）相同，但是删除了一些冗余符号</li>
<li>getPath（）</li>
<li>getParent（）<br>······</li>
</ul>
</li>
</ul>
<h3 id="文本I/O类">文本I/O类</h3><ul>
<li>File类不提供从文件中读写数据的方法，因此需要选择适当的输入输出类来进行I/O操作。<strong>输入输出都是对于程序本身而言</strong>。<br><img src="文本IO类.jpg" alt="文本I/O类"></li>
<li>Reader类是文本输入的根类，Writer类是文本输出的根类。</li>
<li>Reader类常用方法：<ul>
<li>read（） 从输入流读取下一个字符，返回值在0到65525之间，表示该字符的统一码。到达流的结尾时返回-1<br>···</li>
</ul>
</li>
<li>Writer类常用方法：<ul>
<li>flush（） 刷新该输出流，并将已经输出到缓冲区的所有字符写入文件<br>···</li>
</ul>
</li>
<li>read（）方法读取字符，如果没有有效字符，那么它将阻塞线程。</li>
<li>处理PrintWriter类，其他文本I/O类中的所有方法都声明抛出异常java.io.IOException。</li>
</ul>
<h4 id="FileReader类和FileWriter类">FileReader类和FileWriter类</h4><ul>
<li>使用主机上默认的字符编码方式进行读写操作。</li>
<li>所有方法均继承自父类，没有新的方法。</li>
<li>FileReader类read（）方法是读取一个<strong>字节</strong></li>
<li>FileWriter构造方法支持参数append：<ul>
<li>FileWriter(File file,booean append) 如果原文件存在，可以通过设置append参数决定是覆盖还是追加</li>
</ul>
</li>
</ul>
<h4 id="InputStreamReader类和OutputStreamWriter类">InputStreamReader类和OutputStreamWriter类</h4><ul>
<li>可以在构造方法中指定使用哪种编码方案进行读写操作。</li>
<li>用于实现字符与字节之间的转化。写入OutputStreamWriter的字符用指定的编码方案翻译为字节。 </li>
<li>除<code>getEncoding()</code>方法外，均继承自父类方法。getEncoding()方法返回这个数据流使用的编码方案名称。<br><strong>Java程序使用的是统一码（Unicode）。从FileReader流中读取一个字符时，返回该字符的统一码。字符在文件中的编码可能不是统一码，Java自动将它转化为统一码，想FileWriter流中写入字符时，Java自动的将统一码转化为文件指定编码。</strong></li>
</ul>
<h4 id="BufferedReader类和BufferedWriter类">BufferedReader类和BufferedWriter类</h4><ul>
<li>用于输出字符与字符串。</li>
<li>BufferedReader类和BufferedWriter类通过减少读写次数来加快输入输出的速度。缓冲区数据流使用一个类似高速缓冲器作用的字符数组。缓冲区默认是<code>8192</code>个字节。</li>
<li>缓冲区输出流只有当它的缓冲区已满或调用<code>flush()</code>方法才调用写入文件的方法。</li>
<li>BufferedReader常用方法：<ul>
<li>readLine（） 整行读取（不带换行符的一行），到达流的末尾时，返回<code>null</code><br>···</li>
</ul>
</li>
<li>BufferedWriter常用方法：<ul>
<li>newLine（） 向文件写入一个依赖平台的换行符。以下方法可以获得系统的换行符：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> String lineSeparator = (String) java.security.AccessController.doPrivileged(<span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>物理输入输出的I/O设备比CPU的速度慢得多，因此读取一个大文件时，使用缓冲区能够较大地提高效率。</strong></p>
<h4 id="PrintWriter类和PrintStream类">PrintWriter类和PrintStream类</h4><ul>
<li>可以将对象、字符串和数值以<code>文本</code>方式输出。</li>
<li>PrintWriter的效率比PrintStream高，功能一样，前者用于替代后者。</li>
<li>打印数值、字符或布尔值，就是将其转化为字符串打印。打印一个对象就是打印该对象用<code>toString()</code>方法返回的描述字符串。</li>
<li>printf（）方法用于格式化输出。</li>
<li><em>System.out解析</em><br>out是定义在System类中类型为PrintStream的一个静态变量。默认情况下，out是标准输出设备，即屏幕。可以使用<code>setOut()</code>方法设置新的out。</li>
<li>常用构造方法：<ul>
<li>public PrintWriter（Writer out，boolean autoFlush） autoFlush为true，println方法会引起缓冲区刷新</li>
</ul>
</li>
</ul>
<h3 id="二进制I/O">二进制I/O</h3><ul>
<li>二进制输入输出不需要进行文本的编码与解码操作，所以要比文本I/O效率高。向文件写入字节，就是将源字节复制到文件中，从文件读取字节，就是将文件中的字节原样返回。<br><img src="二进制IO类.jpg" alt="二进制I/O类"></li>
<li>InputStream和OutputStream的所有方法与Reader和Writer中的方法类似，不同的是前者操作的是字节，后者操作的是字符。</li>
<li>InputStream类和OutputStream类是抽象类。</li>
<li>InputStream类常用方法：<ul>
<li>read（） 从输入流中读取数据的下一个字节，返回值为0~255之间的整数，如果到达流尾，返回-1</li>
<li>available（） 返回可以从该输入流读取的字节数</li>
<li>mark（int readlimit） 在该输入流中标记当前位置<br>···</li>
</ul>
</li>
<li>OutputStream类常用方法：<ul>
<li>write（int b） 将指定字节写到输出流，参数b是int型，写入的值是（byte）b</li>
<li>flush（）<br>···</li>
</ul>
</li>
</ul>
<h4 id="FileInputStream类和FileOutputStream类">FileInputStream类和FileOutputStream类</h4><ul>
<li>继承自父类的方法，没有引进新方法</li>
<li>输入输出均是操作的字节。</li>
</ul>
<h4 id="FilterInputStream类和FilterOutputStream类">FilterInputStream类和FilterOutputStream类</h4><p><code>过滤器数据流（filter stream）</code>是为某种目的过滤字节的数据流。基本字节输入流提供的读取方法只能用来读取字节，如果想要读取整数值、双精度值或字符串，需要一个过滤器类来包装输入流。</p>
<ul>
<li>该类是父类，如果需要处理基本数值类型数据时，可以使用DataInputSteam类和DataOutputStream类来过滤字节。</li>
</ul>
<h4 id="DataInputStream类和DataOutputStream类">DataInputStream类和DataOutputStream类</h4><ul>
<li>DataInputSteam从数据流中读取字节并将它们转化为适当的基本类型值或字符串。DataOutputStream将基本类型的值或字符串转化为字节并将这些字节输出到输出数据流。</li>
<li>DataOutputStream类和DataInputSteam类以平台无关的方式读写Java的基本类型值和字符串。</li>
<li>可以使用<code>input.available()==0</code>方法检测读取是否已经到了结尾。</li>
<li>DataInputSteam扩展<code>FilterInputStream</code>类并实现<code>DataInput</code>接口；DataoutputStream扩展<code>FilterOutputStream</code>类并实现<code>DataOutput</code>接口。</li>
<li>DataInput类常用方法： <ul>
<li>readInt（） 从输入流中读取一个int值（输入流是一个字节一个字节读入，DataInputSteam的作用就是将读入的字节4个4个组合，其他方法类似）</li>
<li>readUTF（） 从UTF格式中读取一个字符串<br>···</li>
</ul>
</li>
<li>Dataoutput类常用方法：<ul>
<li>writeByte（int v） 将参数v的低8位（一个字节）写到输出流（如果参数v是在Java中被赋值，那么v的统一码是16位（两个字节），调用该方法只能将低字节（低8位）写到输出流）</li>
<li>writeBytes（String s） 将字符串中字符的低8位写到输出流，适合由ASCII字符构成的字符串</li>
<li>writeChar（char c） 向输出流中写一个字符（两个字节构成）</li>
<li>writeChars（String s） 将字符串s中的每一个字符依次写到输出流，每个字符占两个字节</li>
<li>writeInt（int v） 向输出流写一个int值</li>
<li>writeUTF（String s） 用UTF格式写出一个字符串<br>···<br><strong>由此可知，如果要使用二进制I/O，必须使用相对应的输入输出方法以及正确的顺序才能得到正确的数据。</strong></li>
</ul>
</li>
<li><em>UTF编码</em><ul>
<li>UTF是一种编码方案，它可以使系统高效的同时处理统一码（Unicode）和ASCII码。ASCII码字符集是统一码字符集的一个子集。</li>
<li>为了解决8位ASCII码转为16位统一码造成的浪费问题，提出来UTF编码。UTF编码方案分别使用1字节、2字节或3字节来存储字符。<ul>
<li>ASCII码的值不会超过0x7F,使用一个字节编码</li>
<li>不超过0x7FF的统一码值编码为两个字节</li>
<li>其余编码为三个字节</li>
</ul>
</li>
<li>UTF字符的开始几位表明该字符的编码是几个字节的：<ul>
<li>首位是0,一个字节的字符</li>
<li>前三位是110，两个字节字符的第一个字节</li>
<li>前四位是1110，它是三字节字符的第一个字节</li>
</ul>
</li>
<li>UTF字符串的前两个字节用来存储字符串中的字符个数。如：writeUTF(“ABCDEF”)写入的是8个字节</li>
<li><strong>如果字符串的大多数字符都是普通的ASCII字符，采用UTF格式存储的效率是很高的。</strong></li>
</ul>
</li>
</ul>
<h4 id="BufferedInputStream类和BufferedOutputStream类">BufferedInputStream类和BufferedOutputStream类</h4><ul>
<li>提供缓冲区，加快读写<code>字节</code>的效率。缓冲区默认大小为<code>512</code>个字节。</li>
</ul>
<h3 id="对象输入输出">对象输入输出</h3><ul>
<li>DataInputSteam类和DataOutputStream类可以实现基本数据类型与字符串的输入输出，在此基础上，ObjectInputStream类和ObjectOutputStream类还允许对象的输入输出。</li>
<li>可以完全用ObjectInputStream类和ObjectOutputStream类替代DataInputSteam类和DataOutputStream类。</li>
<li>ObjectInputStream扩展<code>InputStream</code>类并实现<code>ObjectInput</code>和<code>ObjectStreamConstants</code>接口,<code>ObjectInput</code>是<code>DataInput</code>的子接口；ObjectOutputStream扩展<code>OutputStream</code>类并实现<code>ObjectOutput</code>和<code>ObjectStreamConstants</code>接口,<code>ObjectOutput</code>是<code>DataOutput</code>的子接口。<code>ObjectStreamConstants</code>包含ObjectInputStream类和ObjectOutputStream类中所用的常量。<br><img src="Object输入输出类.jpg" alt="Object输入输出"></li>
<li>常用构造方法：<ul>
<li>public ObjectInputStream（InputStream in）</li>
<li>public ObjectOutputStream（OutputStream out）</li>
</ul>
</li>
<li>可以向数据流中写入多个对象或基本类型数据。从对应的ObjectInputStream中读回这些对象时，必须与其存入时的类型和顺序相同。对于必要的类型，必须使用Java安全性所要求的类型转换。（显式转换）</li>
</ul>
<h4 id="可序列化接口Serializable">可序列化接口Serializable</h4><ul>
<li>并不是每一个对象都可以写到输出流。可以写入到输出流中的对象称为<code>可序列化的（serializable）</code>。</li>
<li>可序列化的对象时java.io.Serializable接口的实例，所以可序列化对象的类必须实现Serializable接口。</li>
<li>Serializable接口是一种标记性接口。它没有方法，要实现这个接口可以启动Java机制，自动执行存储对象或数组的过程。</li>
<li>Java提供了自动进行写对象这个过程的内在机制，这个过程称为<code>对象序列化（object serialization）</code>。与此相反，读取对象的过程称为<code>对象解读序列化（object deserialization）</code>。它是在ObjectInputStream类中实现的。</li>
<li>存储一个可序列化对象时，会对该对象的类进行编码，编码包括类名、类的说明标志、对象实例变量的值以及任何从初始对象引用的其他对象包，但是不存储对象静态变量的值。</li>
<li><p>如果一个对象时Serializable的实例，但它包含一个非序列化的数据域，该对象不是可序列化的。为了是该对象可序列化，可以给这些数据域加上关键字<code>transient</code>，告诉Java虚拟机将对象写入对象流时忽略这些数据域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> v1;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> v2;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> A v3 = <span class="keyword">new</span> A();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125; <span class="comment">//A is not serializable</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果一个对象多次写入对象流，第一次存储一个可序列化对象时，会创建一个序列号，Java虚拟机将对象的所有内容包括序列号一起写入对象输出流，以后的存储，都是存储序列号的一个拷贝，换句话说，只存储引用。</p>
</li>
</ul>
<h4 id="序列化数组">序列化数组</h4><p>当数组中的元素是可序列化的时候，数组也是可序列化的。一个完整的数组可以用writeObject方法存入文件，此后使用readObject方法将它读出。</p>
<h3 id="随机读写文件">随机读写文件</h3><ul>
<li>Java提供了RandomAccessFile类，它允许对文件内的随机位置进行读写。</li>
<li>RandomAccessFile类实现了DataInput和DataOutput接口。</li>
<li>常用方法：<ul>
<li>RandomAccessFile（File file，String mode） 以指定File和模式创建，模式可以是”r”、”rw”等</li>
<li>getFilePointer（） 返回从文件头到发生读写位置的偏移量</li>
<li>length（） 返回文件的字节数</li>
<li>seek（long pos） 设置从文件头到下一次读写位置的偏移量</li>
<li>setLength（long newLength） 给这个文件设置一个新长度<br>···</li>
</ul>
</li>
<li>随机读写文件是由字节序列组成的，在其中某个字节的位置处有一个称为<code>文件指针（file pointer）</code>的特殊标记。文件的读写操作就是在文件指针所指的位置上进行的。</li>
<li><strong>文件指针置于文件的开头。</strong></li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>本章可能出现的异常总结如下：<ul>
<li>企图用一个不存在的文件创建FileReader/FileWriter对象，出现异常<code>FileNotFoundException</code>。</li>
<li>到达文件尾后还想读取数据，报<code>java.io.EOFException</code>异常。</li>
<li>readObject（）方法可能抛出<code>ClassNOtFoundException</code>异常。</li>
</ul>
</li>
<li>FilterInputStream类和FilterOutputStream类的作用在于：基本的字节输入输出流只能操作字节，但是基本类型的数据如int类型是4个字节，如果想要读取正确的int值，仅靠基本的FileInputStream和FileOutputStream类是无法完成的，因此需要在这基础上包装一层Filter Stream，使用该包装类的方法可以正确存取基本类型的数据。</li>
<li>随机读写文件常被用来处理记录型文件，因为记录型文件每条记录的大小可以设置为固定的。这样，每次操作时，就可以确定文件指针的偏移量了。</li>
<li>随机读写虽然说是文件指针位于文件头，但显示的实际情况是：<br><em>在空文件中插入一条记录，此时文件指针位于这条记录末尾，但是显示的却是这条记录，这点要牢记。</em></li>
<li>I/O类可分为文本I/O和二进制I/O。文本I/O将数据解释成字符的序列，二进制I/O将数据解释成原始的二进制数。文本在文件中如何存储依赖于文件的编码方式。Java对文本I/O提供自动编码与解码。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>16.1 单词统计可以使用StringTokenizer类的countTokens（）方法或者使用正则匹配。</li>
<li>16.4 重写Java源代码格式。代码提供了行尾风格和次行风格相互转化的方法。</li>
<li>16.5 使用字符串的<code>replaceAll()</code>方法删除字符。</li>
<li>16.14 代码参考<a href="http://www.whtis.com/2016/02/16/GUI%E5%B0%8F%E7%BB%83%E4%B9%A0-%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/">GUI小练习-简易计算器</a></li>
<li>16.15 代码见文件夹AddressBook。</li>
<li>其余习题16.7 16.8 16.10 16.11源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter16/src" target="_blank" rel="external">chapter16</a></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章主要讨论数据持久化的问题。一般Java程序在结束后所]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GUI小练习-简易计算器]]></title>
    <link href="http://www.whtis.com/2016/02/16/GUI%E5%B0%8F%E7%BB%83%E4%B9%A0-%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://www.whtis.com/2016/02/16/GUI小练习-简易计算器/</id>
    <published>2016-02-16T10:51:30.000Z</published>
    <updated>2016-09-14T15:46:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简易说明">简易说明</h2><ul>
<li>学习了Java图形界面设计，写了一个简易的计算器，实现的功能如下：<ul>
<li>基本的加减乘除四则运算</li>
<li>连续计算</li>
<li>运算结果记忆</li>
<li>程序启动次数统计</li>
</ul>
</li>
<li>本来打算添加其它功能，不过基本框架出来也就不打算在这部分停留太久，暂时写下设计的功能，等以后有更简单的方法处理连续计算的时候再回来重写一下吧：<ul>
<li>显示结果的处理，包括两个整数作运算，结果应该显示为整数、浮点数显示的位数设定等。目前为了方便，统一转为了浮点数进行计算，显示的结果也是浮点数。</li>
<li>初始设计了四个功能键，依次为<code>Ac</code>（清零）、<code>Cv</code>（小数和分数的转化）、<code>Re</code>（最近一次结果记忆），<code>←</code>（删除），目前除<code>Cv</code>外都已实现。</li>
<li>目前显示结果为单行显示，最初考虑的是双行，但因为文本对齐和设置的问题无法处理，最终采用的JTextField进行单行显示。</li>
<li>组件的等比例放大和缩小问题。目前只能做到自动，因此将其设置成为了不可更改大小,避免破坏布局。</li>
</ul>
</li>
</ul>
<h2 id="遇到的问题及解决方案记录">遇到的问题及解决方案记录</h2><h3 id="布局问题">布局问题</h3><ul>
<li>如何拼凑无缝的界面<ul>
<li>解决方法:略</li>
</ul>
</li>
</ul>
<h3 id="加减乘除运算问题">加减乘除运算问题</h3><ul>
<li>第一次就按运算符的处理<ul>
<li>如果是初始操作，无视之</li>
<li>判断StringBuffer对象里是否有东西，如果没有，直接设置运算符compute</li>
</ul>
</li>
<li>多次按运算符的处理<ul>
<li>创建一个string类型的值来存储运算符，但同时只能设置一个</li>
</ul>
</li>
<li>连续运算的问题（貌似链表处理比较简单？没学过，布吉岛…）<ul>
<li>计算器能够正常运行的一系列设计，包括stringbuffer、compute、result等<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">computeAction</span><span class="params">(ActionEvent e, JTextField textField)</span> </span>&#123;</div><div class="line"><span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="小数点的问题">小数点的问题</h3><ul>
<li><p>直接按小数点应该将其设置成正确的小数形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (stringBuffer.toString().startsWith(<span class="string">"."</span>)) &#123;</div><div class="line">            stringBuffer.insert(<span class="number">0</span>, <span class="string">"0"</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>小数点在一次运算中只能出现一次，多按无效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">"."</span>:</div><div class="line">      <span class="keyword">boolean</span> hasDot = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuffer.length(); i++) &#123;</div><div class="line">          <span class="keyword">if</span> (stringBuffer.charAt(i) == <span class="string">'.'</span>) &#123;</div><div class="line">              hasDot = <span class="keyword">true</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (!hasDot) &#123;</div><div class="line">          capicaty++;</div><div class="line">          stringBuffer.append(<span class="string">"."</span>);</div><div class="line">          textField.setText(stringBuffer.toString());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="等于问题">等于问题</h3><ul>
<li>仅仅在初始时输入数字，不进行任何运算，按下等于号应该显示初始输入的数字，并将result设置为相关的值，从而进行下次运算<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(capicaty&lt;=<span class="number">0</span>) &#123;</div><div class="line">	textField.setText(String.valueOf(result));</div><div class="line">    reResult = result;</div><div class="line">    compute = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="除法问题">除法问题</h3><ul>
<li>出现不合法的运算会得到Infinity，为了界面友好，显示为’0’<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">"÷"</span>:</div><div class="line">    result /= Double.parseDouble(stringBuffer.toString());</div><div class="line">    <span class="keyword">if</span> (String.valueOf(result).equals(<span class="string">"Infinity"</span>)) &#123;</div><div class="line">        result = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码">代码</h2><ul>
<li>完整的代码见我的Github：<a href="https://github.com/whtis/Calculator" target="_blank" rel="external">Calculator</a></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简易说明">简易说明</h2><ul>
<li>学习了Java图形界面设计，写了一个简易的计算器，实现的功能如下：<ul>
<li>基本的加减乘除四则运算</li>
<li>连续计算</li>
<li>运算结果记忆</li>
<li>程序启动次数统计</li>
<]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="小练习" scheme="http://www.whtis.com/tags/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十三章 创建图形用户界面]]></title>
    <link href="http://www.whtis.com/2016/02/15/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
    <id>http://www.whtis.com/2016/02/15/Java学习总结-第十三章-创建图形用户界面/</id>
    <published>2016-02-15T14:32:39.000Z</published>
    <updated>2016-09-14T15:48:42.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章综合第十一、十二章的内容，介绍GUI编程中常用的组件。</p>
<h3 id="Swing_GUI组件的公共特性">Swing GUI组件的公共特性</h3><ul>
<li>Component类是所有用户界面组件和容器的根类，Jcomponent类是大多数Swing组件的根类。</li>
<li>GUI组件都有处理字体、颜色、大小、工具提示文本和边框等属性的方法。</li>
<li>可以在Jcomponent类的任何对象上设置边框。<ul>
<li>TitleBorder(String title) 创建标题边框</li>
<li>LineBorder(Color color,int width) 创建线型边框</li>
</ul>
</li>
<li><strong>容器类Container类是Swing GUI组件类的父类。</strong></li>
</ul>
<h3 id="按钮（JButton）">按钮（JButton）</h3><p><code>按钮（button）</code>是一种点击时触发行为事件的组件。Swing提供常规按钮、开关按钮、复选框和单选按钮。</p>
<ul>
<li>Jbutton可以响应多种类型的事件，通常我们只需要响应ActionEvent事件。</li>
<li>按钮可以设置工具提示文本（<code>setToolTipText(xxx)</code>）和热键（<code>setMnemonic(xxx)</code>）。</li>
</ul>
<h4 id="图标">图标</h4><ul>
<li>图标是一个固定大小的图片，典型的图标体型较小，用于装饰组件。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Icon icon = <span class="keyword">new</span> ImageIcon(<span class="string">"xxx"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>java目前支持GIF、PNG、JPEG三种图像格式。</strong></p>
<ul>
<li>每个常规按钮有一个默认图标，一个按下图标和一个在上图标，使用如下方法进行设置：<ul>
<li>setPressedIcon(“XXX”) 设置按钮按下的图标</li>
<li>setRolloverIcon(“xxx”) 设置鼠标停留在按钮上时的图标</li>
</ul>
</li>
</ul>
<h4 id="对齐方式">对齐方式</h4><ul>
<li><p><code>水平对齐（horizontal alignment）</code>指定以什么样的方式在<strong>按钮</strong>上放置文本和图标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setHorizontalAlignment(<span class="keyword">int</span>)</div></pre></td></tr></table></figure>
<ul>
<li>int的取值为：SwingConstants.LEADING(LEFT、CENTER、RIGHT、TRAILING)。默认的是最后一种（右对齐）。</li>
</ul>
</li>
<li><p><code>垂直对齐（vertical alignment）</code>指定以什么样的垂直方式在按钮上放置文本和图标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setVerticalAlignment(<span class="keyword">int</span>)</div></pre></td></tr></table></figure>
<ul>
<li>int的取值为：SwingConstants.TOP(CENTER、BOTTOM)，默认的是CENTER。</li>
</ul>
</li>
</ul>
<h4 id="文本位置">文本位置</h4><ul>
<li><code>水平文本位置（horizontal text position）</code>指定文本相对于图标的水平位置。</li>
<li><code>垂直文本位置（Vertical text position）</code>指定文本相对于图标的垂直位置。</li>
<li>设置方式和默认值与对齐方式相同。</li>
</ul>
<h3 id="复选框（JCheckBox）">复选框（JCheckBox）</h3><ul>
<li>一个<code>开关按钮（toggle button）</code>有两种状态，JToggleButton类继承AbstractButton并实现了一个开关按钮。开关按钮分为两种：<br>1、JCheckBox 复选按钮（方形）<br>2、 JRadionButton 单选按钮（圆形）</li>
<li>JCheckBox先触发的是ItemEvent事件，然后触发ActionEvent事件。要确定复选框是否被选中，使用<code>isSelected()</code>方法。</li>
</ul>
<h3 id="单选按钮（JRadioButton）">单选按钮（JRadioButton）</h3><ul>
<li><code>单选按钮（radio button）</code>，或者叫<code>选择按钮(option button)</code>,让用户从一组选项中选择唯一的一个选项。</li>
<li>单选按钮使用Java.swing.ButtonGroup类的实例进行组织，并使用add方法添加按钮<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ButtonGroup group = <span class="keyword">new</span> ButtonGroup();</div><div class="line">group.add(xx1);</div><div class="line">group.add(xx2);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果没有创建按钮组，就无法达到单选的目的。</p>
<ul>
<li>JRadioButton先触发的是ItemEvent事件，然后触发ActionEvent事件。要确定复选框是否被选中，使用<code>isSelected()</code>方法。</li>
</ul>
<h3 id="标签（JLable）">标签（JLable）</h3><ul>
<li><code>标签（lable）</code>是显示一小段文字、一幅图片或二者皆有的区域。</li>
<li>JLable继承自JComponent类，具有与JButton类似的属性。</li>
</ul>
<h3 id="文本域（JTextField）">文本域（JTextField）</h3><ul>
<li><code>文本域（text field）</code>可以用于输入或显示字符串。（单行）</li>
<li>JTextField继承自JTextComponent类。</li>
<li>JTextField触发的是ActionEvent事件（回车键触发）。</li>
</ul>
<h3 id="文本区（JTextArea）">文本区（JTextArea）</h3><ul>
<li>文本区用户输入多行文本。</li>
<li>可以创建指定行列的文本区，JTextArea继承自JTextComponent类。</li>
<li><p>JTextArea无法滚动，但可以创建一个<code>JScrollPane</code>对象处理滚动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JScrollPane scrollPane = <span class="keyword">new</span> JScrollPane(<span class="keyword">new</span> JTextArea());</div></pre></td></tr></table></figure>
</li>
<li><p>常用属性</p>
<ul>
<li>setLineWrap（boolean b） 是否换行</li>
<li>setWrapStyleWord（boolean b） 是否按单词换行，默认按照字符换行</li>
<li>setEditable（boolean b） 是否可编辑</li>
</ul>
</li>
</ul>
<h3 id="组合框（JComboBox）">组合框（JComboBox）</h3><ul>
<li><code>组合框（combo box）</code>，也叫<code>选择列表（choice list）</code>或<code>下拉式列表（drop-down list）</code>，它包含项目的一个列表，用户能够从中选择。<strong>使用它可以限制用户的选择范围并能避免对输入数据有效性的繁复检查。</strong></li>
<li>JComboBox可以引发ActionEvent和ItemEvent事件。选中一个新的项目是，JComboBox会产生两次ItemEvent事件，一次是取消前一个项目，另一次是选中当前项目。</li>
<li>常用方法<ul>
<li>getSelectedItem（）方法返回已经选定的项目</li>
<li>getSelectedIndex（） 返回选中的项目次序号</li>
</ul>
</li>
</ul>
<h3 id="列表框（JList）">列表框（JList）</h3><ul>
<li><code>列表框（list）</code>是一个组件，与JComboBox类似，但是它允许用户选择一个或多个项目。</li>
<li><p>选择模式属性selectionMode取值如下，默认为多区间选择</p>
<ul>
<li>SINGLE_SELECTION 单项选择</li>
<li>SINGLE_INTERVAL_SETECTION 单区间选择（允许选择多项，但是必须连续）</li>
<li>MULTIPLE_INTERVAL_SETECTION 多区间选择<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JList不能自动滚动，可以参考文本区的方法设置滚动。</p>
</li>
<li>JList触发ListSelectionEvent事件。</li>
<li>常用方法：<ul>
<li>getSelectedIndices（） 以数组形式返回选中的次序号</li>
<li>getSelectedValues（） 以数组形式返回选中的值</li>
<li>getVisibleRowCount（） 返回可见行数</li>
</ul>
</li>
</ul>
<h3 id="滚动条（JScrollbar）">滚动条（JScrollbar）</h3><ul>
<li><code>滚动条（scrollbar）</code>是一个控制器，它使用户能从值得一个范围中进行选择。</li>
<li>JScrolBar的属性如下：<ul>
<li>orientation（方向）：指定滚动条的水平或垂直模式。</li>
<li>maximum（最大值）: 指滚动条的最大值。</li>
<li>minimum（最小值）</li>
<li>visibleAmount（宽度，也叫广度）：是指滚动块的相对宽度。滚动块在屏幕上的显示的实际宽度取决于最大值及visibleAmount的值。</li>
<li>value：表示滚动条当前的值。</li>
<li>blockIncrement（块增量）：是用户点击滚动条的块增加（减少）区时所增加（减少）的值。</li>
<li>unitIncrement（单位增量）：用户点击单位增加（减少）区所增加（减少）的值。</li>
<li>**滚动条上的宽度对应于<code>maximum+visibleAmount</code>。当滚动条设为最大值时，滚动块的左端在maximum处，右端在maximum+visibleAmount处。</li>
</ul>
</li>
<li>用户改变滚动条的值时，滚动条产生AdjustmentEvent的一个实例。</li>
<li>可以使用构造方法或者使用<code>setOrientation</code>方法来指定滚动条的方向。默认情况下，属性maximum的值为100，minimum为0，blockIncrement为10，visibleAmount为10。</li>
</ul>
<h3 id="滑动块（JSlider）">滑动块（JSlider）</h3><ul>
<li>JSlider与JScrollBar类似，但是JSlider具有更多的属性和更多的显示形式。</li>
<li>JSlider允许用户以图形方式在指定的区间中选择一个数值。滑动块可以在主标记以及次标记之间滑动。标记间的像素值是由<code>setMajorTickSpacing</code>和<code>setMinorTickSpacing</code>方法控制的。</li>
<li>Slider可以带或不带标记，可以有或没有标签，可以水平显示或垂直显示。</li>
<li>垂直滚动条的值从上向下增加，但是垂直滑动块的值从上向下减少。</li>
<li>改变滑动块的值时，滑动块产生javax.swing.event.ChangeEvent的一个实例。</li>
</ul>
<h3 id="创建多个窗口">创建多个窗口</h3><p>新开的窗口叫做<code>子窗口（subwindow）</code>，主框架叫<code>主窗口（main window）</code>。</p>
<ul>
<li>从应用程序创建一个子窗口，需要创建JFrame的一个子类，用于定义任务和通知新窗口做什么。然后，在程序中创建该子类的一个实例，通过把它设为可见的即可弹出新窗口。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>可以在任何Swing组件使用边框，边框和图标都可以共享。</li>
<li>AbstractButton类中的常量LEFT、RIGHT……也可以被许多其他Swing组件使用。由于所有的Swing组件都实现了SwingConstants，因此各种组件都可以通过SwingConstants引用这些常量。因此<code>JButton.CENTER和SwingConstants.CENTER</code>作用是一样的。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题13.1 13.4 13.5 13.8 13.10 13.14 13.15源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter13/src" target="_blank" rel="external">chapter13</a></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章综合第十一、十二章的内容，介绍GUI编程中常用的组件]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
</feed>
