<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[whtis's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.whtis.com/"/>
  <updated>2016-09-18T17:10:05.997Z</updated>
  <id>http://www.whtis.com/</id>
  
  <author>
    <name><![CDATA[whtis]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[最近要做的几件事]]></title>
    <link href="http://www.whtis.com/2016/09/19/%E6%9C%80%E8%BF%91%E8%A6%81%E5%81%9A%E7%9A%84%E5%87%A0%E4%BB%B6%E4%BA%8B/"/>
    <id>http://www.whtis.com/2016/09/19/最近要做的几件事/</id>
    <published>2016-09-18T17:10:05.997Z</published>
    <updated>2016-09-18T17:10:05.997Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>有时候想到要做一些跟技术有关的东西，但很多时候都会忘记。一直觉得<strong>兴趣是最好的老师</strong>这句话很对，既然有兴趣，那么最好动手做一做。写这篇文章，提醒自己的同时也是希望认识志同道合的朋友，虽然刚开始做的东西很low，但慢慢积累，总能获得成就感不是？<br><br>这篇文章会不断更新，我也想看看，我最后到底能做几件自己喜欢的事情，嘻嘻(●’◡’●)</p>
<h5 id="2016-09-19日凌晨">2016-09-19日凌晨</h5><ul>
<li>学习安卓开发，写一个app，具体需求如下：<ul>
<li>能够实现实时监测手机短信的功能。当手机A收到新短信后，能立刻调用系统短信app将短信内容发送给B</li>
<li>如果有可能，转发这一步调用微信完成（省钱啊）</li>
<li>界面，能凑合用就行，别出bug就行</li>
</ul>
</li>
<li>给这博客添加几个功能：<ul>
<li>添加网易云音乐插件</li>
<li>添加一个新分区，类似于微信朋友圈或者qq空间发状态的功能。（因为自己有时候有些话憋不住，按照博文发出来又太短了=。=）</li>
<li>之前好像见过博客同步instagram的功能，如果上面两个都完成了，可以在博客上添加一个专门的图片分区</li>
</ul>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>有时候想到要做一些跟技术有关的东西，但很多时候都会忘记。一直觉得<strong>兴趣是最好的老师</strong>这句话很对，既然有兴趣，那么最好动手做一做。写这篇文章，提醒自己的同时也是希望认识志同道合的朋友，虽然刚开始做的东]]>
    </summary>
    
      <category term="待完成" scheme="http://www.whtis.com/tags/%E5%BE%85%E5%AE%8C%E6%88%90/"/>
    
      <category term="未完成" scheme="http://www.whtis.com/categories/%E6%9C%AA%E5%AE%8C%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将百度搜索结果的长url链接转换为真实的url地址]]></title>
    <link href="http://www.whtis.com/2016/09/19/%E5%B0%86%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E9%95%BFurl%E9%93%BE%E6%8E%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%9C%9F%E5%AE%9E%E7%9A%84url%E5%9C%B0%E5%9D%80/"/>
    <id>http://www.whtis.com/2016/09/19/将百度搜索结果的长url链接转换为真实的url地址/</id>
    <published>2016-09-18T16:37:15.000Z</published>
    <updated>2016-09-18T16:40:18.106Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>最近写爬虫的时候，想调用百度的搜索结果，于是有了这个问题。需要注意的是，本篇内容转化是仅针对百度跳转到非百度链接的，百度内部链接的跳转，如百度搜索主入口跳转到百度知道、百度文库，</p>
<h3 id="问题描述">问题描述</h3><ul>
<li>百度搜索入口：<code>https://www.baidu.com/s?wd=</code>,后面加上需要的搜索内容即可。如需要进行更加精确的搜索，可以使用百度的<a href="http://imgs.xinhuanet.com/js/baidu/gj.htm" target="_blank" rel="external">高级搜索</a>功能。</li>
<li>百度搜索结果示例：<code>https://www.baidu.com/link?url=NsJrxOylR5il9kO2p7IJZu9RdvqdWgobSo1W7n29FIu&amp;amp;wd=&amp;amp;eqid=e4c01daf0006800b0000000357debb6c</code>,实际的url为<code>www.whtis.com</code>。</li>
<li>原因：百度为什么要实行加密跳转，网上有很多有意思的文章，感兴趣可以看看。这里仅从技术角度进行说明。<br><br>百度的这种跳转采用的是302重定向。虽然有时候状态码不是302，但原理差不多一样：当你点击了百度的加密链接后，会向百度内部的服务器发送请求，这个时候服务器会根据你提交的百度链接使用重定向技术自动跳转到相应的真实url。</li>
</ul>
<h3 id="拿到真实的URL链接">拿到真实的URL链接</h3><p>网上有很多博客都提到过这事，既然知道了302跳转的原理，那么可以采用这种思路拿到真实的URL：模拟一个请求，在百度服务器进行重定向的时候获得重定向的地址即可。<br><br>原理很简单，但是我在网上找了很多，基本都是互相抄，抄的代码怎么说呢，用的工具都是httpclient，但是都是httpclient已经废弃的方法，虽然不报错，但是没法实现这功能了。所以这也告诉我们写博客的人，一定要注明自己的代码基于的是哪个版本的工具，虽然这只是一点小事，但却能让自己和他人节约很多时间。<br><br>下面上代码：</p>
<p><strong>使用版本：httpclient 4.3.3</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String realUrl = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        HttpClient client = HttpClientBuilder.create().build();</span><br><span class="line">        RequestConfig config = RequestConfig.custom()</span><br><span class="line">        <span class="comment">//禁止自动重定向</span></span><br><span class="line">                .setRedirectsEnabled(<span class="keyword">false</span>)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//302跳转</span></span><br><span class="line">        HttpGet get = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">        get.setConfig(config);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//对url进行utf-8解码</span></span><br><span class="line">            url = URLDecoder.decode(url, <span class="string">"utf-8"</span>);</span><br><span class="line">            HttpResponse rs = client.execute(get);</span><br><span class="line">            Header h = rs.getFirstHeader(<span class="string">"Location"</span>);</span><br><span class="line">            realUrl = h.getValue().trim();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printstacktrace();</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (realUrl.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> realUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>最近写爬虫的时候，想调用百度的搜索结果，于是有了这个问题。需要注意的是，本篇内容转化是仅针对百度跳转到非百度链接的，百度内部链接的跳转，如百度搜索主入口跳转到百度知道、百度文库，</p>
<h3 id="问题描述">问题描述</]]>
    </summary>
    
      <category term="java，原创" scheme="http://www.whtis.com/tags/java%EF%BC%8C%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PostgreSQL使用手记]]></title>
    <link href="http://www.whtis.com/2016/09/14/PostgreSQL%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/"/>
    <id>http://www.whtis.com/2016/09/14/PostgreSQL使用手记/</id>
    <published>2016-09-14T14:29:13.000Z</published>
    <updated>2016-09-14T16:17:29.856Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p><blockcode><br>&emsp;&emsp;因为项目需要，要将本来的<code>mybatis+mysql</code>改为<code>mybatis+postgresql</code>,使用途中难免遇到坑，以下是我遇到的，记录下来供参考。好久没写blog，感觉都快长草了，目前在想要不要开一个分类，写点日常废话😂<br></blockcode><br>&emsp;&emsp;好了，言归正传。</p>
<h3 id="为什么要用PostgreSQL">为什么要用PostgreSQL</h3><p>为什么要用呢,上面已经说了，项目需要。postgresql经常被拿来和mysql进行比较，postgresql可以用来存储较大的对象数据（文本、视频、图片等），符合项目要求。</p>
<h3 id="什么是PostgreSQL">什么是PostgreSQL</h3><p>念都不知道怎么念的一个词，确实第一感觉没有mysql好。看下官方的说法：</p>
<blockquote>
<p>PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。(摘自百度百科)</p>
</blockquote>
<h3 id="使用版本">使用版本</h3><p>本文总结基于PostgreSQL 9.4版本</p>
<h3 id="安装及使用">安装及使用</h3><p>推荐下阮一峰写的这篇博客<a href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html" target="_blank" rel="external">PostgreSQL新手入门</a></p>
<h3 id="使用中出现的错误及解决方案">使用中出现的错误及解决方案</h3><h4 id="错误一：_java-sql-SQLException:_No_suitable_driver_found_for_jdbc:postgresql://yourhost:port">错误一： <code>java.sql.SQLException: No suitable driver found for jdbc:postgresql://yourhost:port</code></h4><ul>
<li>可能的错误原因：<ul>
<li>使用的postgresql的驱动与当前使用的jdk版本不兼容。具体兼容情况参见官方文档，本文仅作摘录：</li>
<li>系统环境没有配置classpath路径，使的程序无法找到驱动的位置。（使用java IDE编写代码时一般不会出现这种情况）</li>
<li><strong>连接jdbc时url没写正确，一定要再三检查下正确的url</strong>（这一条很恶心，url错误时的提示我遇到过两种，一种是本条目列出的错误，另一种是提示字符编码有问题）</li>
</ul>
</li>
</ul>
<h4 id="错误二：_Error_querying_database-_Cause:_org-postgresql-util-PSQLException:_ERROR:_CREATE_DATABASE_cannot_run_inside_a_transaction_block">错误二： <code>Error querying database.  Cause: org.postgresql.util.PSQLException: ERROR: CREATE DATABASE cannot run inside a transaction block</code></h4><ul>
<li><p>可能的错误原因：</p>
<ul>
<li><p>根据网上查到的资料，单独使用postgresql时，出现这个错误的原因是因为没有打开自动提交。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = DriverManager.getConnection(<span class="string">"jdbc:postgresql://yourhost"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>);</span><br><span class="line">     c.setAutoCommit(<span class="keyword">true</span>); <span class="comment">// 把自动提交设置为true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我在项目中单独使用Mybatis进行事务管理，管理<code>PostgreSQL</code>时也会出现这个错误，因为Mybatis封装了<code>java.sql.*</code>相关的类,因此无法按照上面方式进行更改，在Mybatis中打开一个会话时，也应该将其设置为自动提交（mysql无需设置）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总结：出现这个问题，网上给的解决方法大多是因为没有打开自动提交，但是仅仅在portgresql控制台上执行<code>SET AUTOCOMMIT = on</code>是无用的，至于为什么需要打开自动提交才能创建数据库，这个不太清楚，可能跟<code>PostgreSQL</code>自己的事务管理逻辑有关，而且这样改动后，暂时不知道会不会对之后的数据库操作造成影响</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="使用PostgreSQL存储大文件">使用PostgreSQL存储大文件</h3><p>待编辑</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p><blockcode><br>&emsp;&emsp;因为项目需要，要将本来的<code>mybatis+mysql</code>改为<code>mybatis+postgresql</code>,使用途中难免遇到坑，以下是我遇]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="数据库，PostgreSQL" scheme="http://www.whtis.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8CPostgreSQL/"/>
    
      <category term="SQL" scheme="http://www.whtis.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习笔记--设置代理及打开外部程序]]></title>
    <link href="http://www.whtis.com/2016/05/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E5%8F%8A%E6%89%93%E5%BC%80%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.whtis.com/2016/05/29/Java学习笔记-设置代理及打开外部程序/</id>
    <published>2016-05-29T12:14:59.000Z</published>
    <updated>2016-09-14T15:50:10.235Z</updated>
    <content type="html"><![CDATA[<h3 id="设置系统代理">设置系统代理</h3><ul>
<li><p>系统设置全局代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">"proxySet"</span>, <span class="string">"true"</span>);</span><br><span class="line">System.getProperties().setProperty(<span class="string">"http.proxyHost"</span>, <span class="string">"ip"</span>);</span><br><span class="line">System.getProperties().setProperty(<span class="string">"http.proxyPort"</span>, port);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用了selenium的chrome驱动，webdriver设置代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"webdriver.chrome.driver"</span>, <span class="string">"filepath"</span>);</span><br><span class="line">String proxyIpAndPort = ip + <span class="string">":"</span> + port;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理配置</span></span><br><span class="line">DesiredCapabilities cap = <span class="keyword">new</span> DesiredCapabilities();</span><br><span class="line">org.openqa.selenium.Proxy proxy = <span class="keyword">new</span> org.openqa.selenium.Proxy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置http、ftp、ssl代理（注：当前版本只支持所有的协议公用http协议，下述代码等同于只配置http）</span></span><br><span class="line">proxy.setHttpProxy(proxyIpAndPort)</span><br><span class="line">        .setFtpProxy(proxyIpAndPort)</span><br><span class="line">        .setSslProxy(proxyIpAndPort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下三行是为了避免localhost和selenium driver的也使用代理，务必要加，否则无法与iedriver通讯</span></span><br><span class="line">cap.setCapability(CapabilityType.ForSeleniumServer.AVOIDING_PROXY, <span class="keyword">true</span>);</span><br><span class="line">cap.setCapability(CapabilityType.ForSeleniumServer.ONLY_PROXYING_SELENIUM_TRAFFIC, <span class="keyword">true</span>);</span><br><span class="line">System.setProperty(<span class="string">"http.nonProxyHosts"</span>, <span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">cap.setCapability(CapabilityType.PROXY, proxy);</span><br><span class="line"></span><br><span class="line">WebDriver webDriver = <span class="keyword">new</span> ChromeDriver(cap);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="打开外部程序">打开外部程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process p = Runtime.getRuntime().exec(<span class="string">"cmd command"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>如果外部程序放在一个单独的线程中执行，需要注意的是：该线程执行完并不代表着外部程序也执行完相应的任务。</strong></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="设置系统代理">设置系统代理</h3><ul>
<li><p>系统设置全局代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="java学习笔记" scheme="http://www.whtis.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HttpClient4.x使用中出现的几个问题及解决方法]]></title>
    <link href="http://www.whtis.com/2016/05/05/HttpClient4-x%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2016/05/05/HttpClient4-x使用中出现的几个问题及解决方法/</id>
    <published>2016-05-05T14:38:39.000Z</published>
    <updated>2016-09-14T15:46:45.590Z</updated>
    <content type="html"><![CDATA[<p>最近才开始接触这个工具包，官网上目前已经更新到<a href="http://hc.apache.org/downloads.cgi" target="_blank" rel="external">HttpClient4.5.2</a>了。google的时候看到HttpClient从4.0版本改了底层，因此使用时会出现一些方法不再适用的问题，这里记录出现的一些问题以及相应替代的方法。</p>
<p>1、 创建HttpClient时使用下面的语句，会出现<code>org.apache.http.impl.client.DefaultHttpClient&#39; is deprecated</code><br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</span><br></pre></td></tr></table></figure></p>
<p>   可以使用如下语句代替：<a href="http://stackoverflow.com/questions/15336477/deprecated-java-httpclient-how-hard-can-it-be" target="_blank" rel="external">来源</a><br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = HttpClientBuilder.create().build();</span><br></pre></td></tr></table></figure></p>
<p>   或者<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建HttpClientBuilder</span></span><br><span class="line">HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();</span><br><span class="line"><span class="comment">// HttpClient</span></span><br><span class="line">CloseableHttpClient httpClient = httpClientBuilder.build();</span><br></pre></td></tr></table></figure></p>
<p>2、 设置代理，HttpClient4.5.2版本可以使用如下语句：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建代理</span></span><br><span class="line">HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">"your proxy IP"</span>, port);</span><br><span class="line">RequestConfig config = RequestConfig.custom().setProxy(proxy).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置HttpPost/HttpGet使用代理</span></span><br><span class="line">httpost.setConfig(config);</span><br></pre></td></tr></table></figure></p>
<p>3、get或post时，如果访问的网站是https协议的，可以用如下方式访问：信任所有证书，如果可以具体到每个证书，就更好了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sslContext = <span class="keyword">new</span> SSLContextBuilder().loadTrustMaterial(<span class="keyword">null</span>, <span class="keyword">new</span> TrustStrategy() &#123;</span><br><span class="line">                <span class="comment">//信任所有</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTrusted</span><span class="params">(X509Certificate[] chain,</span><br><span class="line">                                         String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build();</span><br><span class="line">            SSLConnectionSocketFactory sslsf = <span class="keyword">new</span> SSLConnectionSocketFactory(sslContext);</span><br><span class="line">            <span class="keyword">return</span> HttpClients.custom().setSSLSocketFactory(sslsf).build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyStoreException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HttpClients.createDefault();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>最近才开始接触这个工具包，官网上目前已经更新到<a href="http://hc.apache.org/downloads.cgi" target="_blank" rel="external">HttpClient4.5.2</a>了。google的时候看到HttpCl]]>
    </summary>
    
      <category term="HttpClient" scheme="http://www.whtis.com/tags/HttpClient/"/>
    
      <category term="Web相关" scheme="http://www.whtis.com/categories/Web%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java阶段性总结]]></title>
    <link href="http://www.whtis.com/2016/04/21/Java%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://www.whtis.com/2016/04/21/Java阶段性总结/</id>
    <published>2016-04-21T10:29:08.000Z</published>
    <updated>2016-09-14T15:50:25.355Z</updated>
    <content type="html"><![CDATA[<p>花了大半年的时间，算是彻底从头看了一遍Java的基本知识，参考书籍是《Java语言程序设计》原书第五版，作者为Y.daniel Liang，基础篇和提高篇中的重要内容都摘录在了之前的文章中。本文就是对之前的Java总结做个分类，方便自己以后回顾。</p>
<h3 id="第一篇_程序设计基础（1~5章）">第一篇 程序设计基础（1~5章）</h3><h5 id="第一章_计算机、程序和Java概述"><a href="http://www.whtis.com/2015/12/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E7%A8%8B%E5%BA%8F%E5%92%8CJava%E6%A6%82%E8%BF%B0/">第一章 计算机、程序和Java概述</a></h5><h5 id="第二章_基本数据类型和基本操作"><a href="http://www.whtis.com/2015/12/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">第二章 基本数据类型和基本操作</a></h5><h5 id="第三章_控制语句"><a href="http://www.whtis.com/2016/01/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/">第三章 控制语句</a></h5><h5 id="第四章_方法"><a href="http://www.whtis.com/2016/01/11/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%B9%E6%B3%95/">第四章 方法</a></h5><h5 id="第五章_数组"><a href="http://www.whtis.com/2016/01/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E7%BB%84/">第五章 数组</a></h5><h3 id="第二篇_面向对象程序设计（6~10章）">第二篇 面向对象程序设计（6~10章）</h3><h5 id="第六章_对象和类"><a href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/">第六章 对象和类</a></h5><h5 id="第七章_字符串"><a href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/">第七章 字符串</a></h5><h5 id="第八章_继承和多态"><a href="http://www.whtis.com/2016/01/27/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">第八章 继承和多态</a></h5><h5 id="第九章_抽象类和接口"><a href="http://www.whtis.com/2016/01/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">第九章 抽象类和接口</a></h5><h5 id="第十章_面向对象建模"><a href="http://www.whtis.com/2016/01/29/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/">第十章 面向对象建模</a></h5><h3 id="第三篇_图形用户界面设计（11~13章）">第三篇 图形用户界面设计（11~13章）</h3><h5 id="第十一章_图形用户界面程序设计"><a href="http://www.whtis.com/2016/02/05/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">第十一章 图形用户界面程序设计</a></h5><h5 id="第十二章_事件驱动程序"><a href="http://www.whtis.com/2016/02/09/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/">第十二章 事件驱动程序</a></h5><h5 id="第十三章_创建图形用户界面"><a href="http://www.whtis.com/2016/02/15/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/">第十三章 创建图形用户界面</a></h5><h3 id="第四篇_异常处理、I/O（15~16章）">第四篇 异常处理、I/O（15~16章）</h3><h5 id="第十五章_异常和断言"><a href="http://www.whtis.com/2016/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80/">第十五章 异常和断言</a></h5><h5 id="第十六章_简单输入输出"><a href="http://www.whtis.com/2016/02/18/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%AE%80%E5%8D%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">第十六章 简单输入输出</a></h5><h3 id="第五篇_数据结构与集合架构">第五篇 数据结构与集合架构</h3><h5 id="第十七章_面向对象数据结构"><a href="http://www.whtis.com/2016/03/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">第十七章 面向对象数据结构</a></h5><h5 id="第十八章_Java集合架构"><a href="http://www.whtis.com/2016/04/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-Java%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84/">第十八章 Java集合架构</a></h5><h3 id="第六篇_多线程">第六篇 多线程</h3><h5 id="第十九章_多线程"><a href="http://www.whtis.com/2016/04/10/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">第十九章 多线程</a></h5><h3 id="网络">网络</h3><h5 id="第二十八章_网络"><a href="http://www.whtis.com/2016/04/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E7%BD%91%E7%BB%9C/">第二十八章 网络</a></h5><hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>花了大半年的时间，算是彻底从头看了一遍Java的基本知识，参考书籍是《Java语言程序设计》原书第五版，作者为Y.daniel Liang，基础篇和提高篇中的重要内容都摘录在了之前的文章中。本文就是对之前的Java总结做个分类，方便自己以后回顾。</p>
<h3 id="第]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第二十八章 网络]]></title>
    <link href="http://www.whtis.com/2016/04/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.whtis.com/2016/04/16/Java学习总结-第二十八章-网络/</id>
    <published>2016-04-16T13:43:48.000Z</published>
    <updated>2016-09-14T15:47:40.613Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p><code>基于套接字的通信</code>可以使程序通过指定的套接字进行通信。<code>套接字（socket）</code>是两个主机之间逻辑连接的端点，可以用于发送和接收数据。<br>Java支持流套接字和数据报套接字。<code>流套接字（stream socket）</code>使用传输控制协议（Transmission Control Protocol，TCP）进行数据传输，而<code>数据报套接字（datagram socket）</code>使用的是用户数据报协议（User Datagram Protocol，UDP）。</p>
<h3 id="客户/服务器计算模式">客户/服务器计算模式</h3><ul>
<li>服务器和客户一旦建立连接，客户和服务器就可以通过套接字进行通信。</li>
<li><p>创建<code>服务器套接字（server socket）</code>，并把它附加到一个端口上，服务器从端口监听连接。端口标识套接字上的TCP服务，端口号的范围从0到65536，但是0到1024号是为特权服务保留的端口。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">Socket socket = serverSocket.accept();</span><br></pre></td></tr></table></figure>
<p><strong>如果企图在已经使用的端口上创建服务器套接字，将会引起<code>java.net.BindException</code>异常。</strong></p>
</li>
<li><p>服务器的监听语句会一直等待，直到一个客户与服务器套接字建立连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket(serverName,port);</span><br></pre></td></tr></table></figure>
<p>serverName是服务器的域名或IP地址。</p>
</li>
<li><p>通过得到socket的输入输出流，接可以进行数据传输了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = socket.getInputStream();</span><br><span class="line">OutputStream output = socket.getOutputStream();</span><br></pre></td></tr></table></figure>
<p><strong>建议使用二进制I/O在服务器和客户间进行数据传输，以便提高效率。</strong></p>
</li>
</ul>
<h3 id="网络地址类InetAddress">网络地址类InetAddress</h3><ul>
<li><p>可以使用类InetAddress来求得客户的主机名和IP地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InetAddress inetAddress = socket.getInetAddress();</span><br><span class="line">String hostname = inetAddress.getHostName();</span><br><span class="line">String ip = inetAddress.getHostAddress();</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用静态方法getByName通过主机名或IP地址创建InetAddress的一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(<span class="string">"www.google.com"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多客户服务">多客户服务</h3><ul>
<li><p>可以使用线程处理服务器上多个客户的同步问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">	Socket socket = serverSocket.accept();</span><br><span class="line">	Thread thread = <span class="keyword">new</span> ThreadClass(socket);</span><br><span class="line">	thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器套接字可以有多个连接。while循环的每次迭代创建一个新的连接。</p>
</li>
</ul>
<h3 id="发送和接收对象">发送和接收对象</h3><ul>
<li>可以在套接字流上使用ObjectInputStream和ObjectOutputStream接收和发送对象。为了能够进行传输，这些对象必须实现<code>Serializable</code>接口。</li>
</ul>
<h3 id="从Web服务器上读取文件">从Web服务器上读取文件</h3><ul>
<li>可以创建一个<code>java.net.URL</code>对象，然后打开一个输入流：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"www.whtis.com"</span>);</span><br><span class="line">InputStream inputStream = url.openStream();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JEditorPanel类">JEditorPanel类</h3><ul>
<li>Swing提供了一个名叫javax.swing.JEditorPanel的GUI组件，它能够自动地显示普通文本文件、HTML文件和RTF文件。 </li>
<li><p>要显示文件的内容，可以使用setPage（URL）方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPage</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当单击编辑窗格中的一个超链接时，JEditorPanel产生<code>javax.swing.event.HyperLink Event</code>事件，通过该事件，我们可以得到超链接的URL，并使用setPage(url)方法显示它。</p>
</li>
</ul>
<h3 id="数据报套接字">数据报套接字</h3><ul>
<li>我们编写的有些网络通信不要求TCP提供可靠的、点对点的通道，这种情况下，数据报通信效率更高。</li>
<li>数据是用<code>分组（packet，或称为包）</code>进行传输的。数据报套接字使用<code>用户数据报协议（User Datagram Protocol，UDP）</code>，该协议不能保证分组不会丢失、或者不会重复接收、或者接收的顺序与发送的顺序不同。</li>
<li><code>数据报（datagram）</code>是独立的，包含自身网络上的传输信息，它的到达、到达的时间和内容都没有保证。</li>
</ul>
<h4 id="DatagramPacket类和DatagramSocket类">DatagramPacket类和DatagramSocket类</h4><ul>
<li>DatagramPacket表示数据报的分组。要为来自客户的传送创建DatagramPacket对象，可以使用构造方法<code>DatagramPacket(byte[] buf,int length,InetAddress host,int prot)</code>。要创建其他所有的DatagramPacket对象，使用构造方法<code>DatagramPacket(byte[] buf,int length)</code>。一旦创建了一个数据报分组，就可以使用getData()方法和setData()方法获取和设置分组中的数据。</li>
<li>数据报套接字类DatagramSocket表示发送和接收数据报分组的套接字。数据报套接字是分组传输服务的发送和接收点。每个在套接字上发送和接收的分组都是独立编址和路由的。<ul>
<li>要创建服务器上的数据报套接字，使用构造方法DatagramSocket(int port),它将套接字绑定到本地主机指定的端口上。</li>
<li>要创建客户上的数据报套接字，使用构造方法DatagramSocket()，它将套接字绑定到本地主机任意一个可用的端口上。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>流套接字的端口号和数据报套接字的端口号是互不相关的。流套接字和数据报套接字能够同时使用同一个端口号。</li>
<li>数据报套接字使用<code>send(DatagramSocket)</code>发送分组，使用<code>receive(DatagramSocket)</code>接收分组。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题28.1 28.3 28.6 28.8 28.9 28.10源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter28/src" target="_blank" rel="external">chapter28</a></li>
<li><p>习题28.6 </p>
<ul>
<li><p>服务器端的输入输出流应该和客户端的对应。</p>
<ul>
<li><p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器端的顺序应该为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如何判断ObjectInputStream类中readObject()方法是否到达末尾:</p>
<ul>
<li><p>readObject()方法读取数据流到末尾时会抛出<code>java.io.EOFException</code>异常，可以捕获到这个异常并由此判断对象数据读取完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"Address.dat"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ObjectInputStream InFromFile = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lists.add(InFromFile.readObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        jTextArea.append(<span class="string">"Data read completed!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在数据流中添加标识，当读取到标识后，则关闭输出流。例如：可以在写入数据完成后附加<code>null</code>作为标识。</p>
</li>
</ul>
</li>
<li>异常<code>java.io.StreamCorruptedException: invalid type code: AC</code>的出现原因及解决方案<ul>
<li>原因：新建一个ObjecOutputStream类后，在第一次写入时，会附加一个头文件信息，随后的数据不会附加头文件。新建一个ObjectInputStream，在第一次读取时会寻找头文件，之后读取时就不会寻找头文件直接读取数据。如果写入数据时每次都附加头文件，而读取时仅第一次读取头文件，就会抛出上述异常。</li>
<li>解决方案：写文件和读文件要统一，写文件时不能每次都附带头文件，也就是用一个输出流写数据，不要每次写入对象都新建一个输出流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p><code>基于套接字的通信</code>可以使程序通过]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java学习总结-第十九章 多线程]]></title>
    <link href="http://www.whtis.com/2016/04/10/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.whtis.com/2016/04/10/java学习总结-第十九章-多线程/</id>
    <published>2016-04-10T15:17:34.000Z</published>
    <updated>2016-09-14T15:48:53.661Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java支持<code>多线程（multithreading）</code>。多线程是指在一个程序中允许同时运行多个任务的能力。</p>
<h3 id="线程的概念">线程的概念</h3><ul>
<li><code>一个线程（thread）</code>是指程序中完成一个任务的有始有终的执行流。使用Java，可以在一个程序中并发的运行多个线程。</li>
<li>多线程可以使程序反应更快，交互性更强，执行效率更高。</li>
<li>Java对多线程程序的开发和运行提供了非常好的支持，包括锁定资源以避免冲突。</li>
<li>每个新线程都是一个对象，它的类实现<code>Runnable</code>接口或者扩展实现了<code>Runnable</code>接口，这种新对象称为<code>可运行对象（runnable object）</code>。</li>
</ul>
<h3 id="创建线程的两种方式">创建线程的两种方式</h3><h4 id="扩展Thread类创建线程">扩展Thread类创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现runnable接口创建线程">实现runnable接口创建线程</h4><ul>
<li><p>实现接口：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> run &#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建线程：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnThread());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果用户线程要实现多继承，应该选择实现Runnable接口这种方式。</p>
</li>
</ul>
<h3 id="线程的控制与通信">线程的控制与通信</h3><ul>
<li>Thread类中提供的控制线程的方法：<ul>
<li>start()</li>
<li>interrupt()  中断该线程。如果该线程处于阻塞状态，它就进入重新运行的就绪状态</li>
<li>isAlive()  该方法判断线程是否正处于运行状态</li>
<li>setPriority(int p)</li>
<li>join()  等待该线程结束</li>
<li>sleep(long millis)  </li>
<li>yield()  让该线程暂停执行，允许其他线程开始运行</li>
<li>isinterrupted()</li>
<li>currentThread()  返回当前正在运行的线程对象的引用<br><strong>Thread类还包含stop()、suspend()和resume()。但是这些线程具有内在的不安全因素，因此不建议使用。要替代stop()方法，可以给线程变量赋值为null，指明要停止它的运行。</strong></li>
</ul>
</li>
<li>方法wait()、notify()、notifyAll()定义在Object类中，也可以用于促进活动线程之间的通信。<ul>
<li>wait()  该方法强迫线程等待，直到对调用wait方法的对象调用notify或notifyAll方法。</li>
</ul>
</li>
</ul>
<h4 id="线程的状态">线程的状态</h4><ul>
<li>线程有五种状态：新建、就绪、运行、阻塞或结束。<br><img src="线程的状态.jpg" alt="线程的状态"></li>
<li>有几种原因会使线程进入<code>阻塞状态（Blocked state）</code>：<ul>
<li>可能是它自己调用了join()、sleep()或wait()方法</li>
<li>可能是其他方法调用了如上方法</li>
<li>可能是该线程在等待一个I/O操作的完成</li>
</ul>
</li>
<li>方法interrupt按下列方式中断一个线程：当线程处于就绪状态或运行状态时，给它设置一个中断标志；当线程处于阻塞状态时，它将会被唤醒并进入就绪状态，同时抛出异常java.lang.InterruptedException。即：<strong>中断不仅打断执行过程，也可以打断不执行过程。</strong></li>
</ul>
<h4 id="线程的优先级">线程的优先级</h4><ul>
<li>Java给每个线程指定一个优先级。</li>
<li>Thread类有int型常量MIN_PRIOTITY、NORM_PRIORITY和MAX_PRIORITY，分别代表1、5、10、主线程的优先级是Thread.NORM_PRIORITY。<br><strong>如果总有一个优先级较高的线程在运行，或者有一个相同优先级的线程不退出，那么一个线程可能永远也没有运行的机会。这种情况称为<code>竞争（contention）</code>或<code>资源缺乏（starvation）</code>状态。</strong></li>
</ul>
<h3 id="线程组">线程组</h3><ul>
<li>一个<code>线程组（thread group）</code>是线程的一个集合。可以同时对一个线程组进行唤醒和挂起操作。</li>
<li>可以把一个线程组添加到另一个线程组，构成一个树形结构，除了起始组以外，树中的每个线程组都有一个父线程组。</li>
<li>每个线程都属于一个线程组。</li>
<li>线程组的创建：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadGroup g = <span class="keyword">new</span> ThreadGroup(<span class="string">"thread group"</span>);  <span class="comment">//组名必须是唯一的字符串</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(g,<span class="keyword">new</span> ThreadClass(),<span class="string">"label for the thread"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>线程组里的线程必须分别启动</strong></p>
<h3 id="线程之间的同步与协作">线程之间的同步与协作</h3><p>多个线程同时访问一个共享资源会引起<code>资源冲突（race condition）</code>。如果一个类的对象在多线程程序中没有引起资源冲突，则称这样的类为<code>线程安全的（thread-safe）</code>。</p>
<h4 id="同步化实例与静态方法">同步化实例与静态方法</h4><ul>
<li>为避免资源冲突，应该防止多个线程同时进入程序的某一特定部分，程序中这样的部分称为<code>临界区（critical region）</code>。</li>
<li>可以使用关键字<code>Synchronized</code>来使方法的通信同步，以便一次只有一个线程可以访问该方法。</li>
<li>一个同步方法在执行前需要加锁：对于实例方法，要给调用该方法的对象加锁；对于静态方法，要给这个类加锁。</li>
</ul>
<h4 id="同步语句">同步语句</h4><ul>
<li><p>当执行方法中某一个代码块（也成为体）时，同步语句不仅仅可以用于获准给该对象加锁，而且可以用于要求对任何对象加锁。这个代码块称为<code>同步块（synchronized block）</code>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (expr) &#123;  <span class="comment">//表达式expr必须能求出对象的引用</span></span><br><span class="line">	语句组；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步语句允许对任何对象加锁，所以可以同步地访问一个对象而不仅仅是一个方法。</p>
</li>
<li><p>任何同步的实例方法都可以转化为同步语句。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">xMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="comment">//方法体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="线程之间的协作">线程之间的协作</h4><ul>
<li>通过在临界区上多个线程的相互排斥，线程同步完全可以避免资源冲突的发生，但是有时候我们还需要线程之间的相互协作。</li>
<li>wait、notify和notifyAll方法可以用来实现线程之间的相互通信。这些方法必须在同步方法中调用，或者在接受这些方法的对象的同步块中调用；否则会抛出异常<code>IllegalMonitorStateException</code>。</li>
</ul>
<h4 id="死锁">死锁</h4><ul>
<li>使用一种名为<code>资源排序（resource ordering）</code>的简单技术可以轻易的避免死锁的发生。该技术是给每一个需要锁定的对象定义一个顺序，确保每个线程都按这个顺序来锁定对象。</li>
</ul>
<h3 id="进程条JProcessBar">进程条JProcessBar</h3><ul>
<li>进程条JProcessBar是一个图形组件，用来以图示的方式显示有界区间内的一个值。</li>
<li>进程条的常用属性有orientation、minimum、value和maximum等。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>线程对象从来不会直接引用run方法，到了执行某个线程的时候，Java虚拟机调用该线程的run方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li><p>习题19.2 19.3 19.4 19.6 19.7 19.8 19.9 19.11源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter19/src" target="_blank" rel="external">chapter19</a></p>
</li>
<li><p>习题19.7要求使用同步集合解决习题19.6多线程出现异常java.util.ConcurrentModificationException的问题。当完成这个题并且多次执行时，会出现下面这个问题，暂时不知道是否是错误：<br>向规则集添加数字时使用如下语句：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashSet.add(((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>)) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>  控制台输出为以下结果：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>也就是说，随机数在规则集内被重新排序了，并且在使用迭代算子遍历时被打印到控制台。排序的原因猜测是同步规则集的方法导致的：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedSet(hashSet);</span><br></pre></td></tr></table></figure>
</li>
<li><p>习题19.9要求写一个死锁程序，形成死锁的条件如下：</p>
<ul>
<li><blockquote>
<p>互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。</p>
</blockquote>
</li>
<li><blockquote>
<p>不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。</p>
</blockquote>
</li>
<li><blockquote>
<p>占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。</p>
</blockquote>
</li>
<li><blockquote>
<p>循环等待条件。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。</p>
</blockquote>
</li>
</ul>
<p>根据这个原则，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $19<span class="title">_9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      DeadThread t1 = <span class="keyword">new</span> DeadThread();</span><br><span class="line">      DeadThread t2 = <span class="keyword">new</span> DeadThread();</span><br><span class="line">      t1.flag = <span class="number">0</span>;</span><br><span class="line">      t2.flag = <span class="number">1</span>;</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * 线程1锁定o1后休眠1s，使得有机会执行线程2，线程2锁定o2后，等待线程1释放o1，线程1此时锁定了o1，等待线程2</span><br><span class="line">  * 释放o2，形成死锁。</span><br><span class="line">  *</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (flag==<span class="number">0</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"flag="</span> + flag);</span><br><span class="line">          <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"o2 locked"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag==<span class="number">1</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"flag="</span> + flag);</span><br><span class="line">          <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"o2 locked"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java支持<code>多线程（multithreadi]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第十八章 Java集合架构]]></title>
    <link href="http://www.whtis.com/2016/04/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-Java%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.whtis.com/2016/04/01/Java学习总结-第十八章-Java集合架构/</id>
    <published>2016-04-01T03:41:32.000Z</published>
    <updated>2016-09-14T15:49:25.196Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数组线性表和链表是Java中的预定义结构。除此之外，Java还引入了几种可以有效组织和处理数据的接口和类，这些接口和类组成了<code>Java集合架构（Java Collection Framework）</code>。<br>一个<code>集合（collection）</code>就是一个存储一组对象的容器，一般将这些对象称为集合的<code>元素（element）</code>。Java集合构架支持三种类型的集合：<code>规则集（set）、线性表（list）和图（map）</code>，它们分别定义在接口Set、List与Map中。Set的实例存储一组互不相同的元素，List的实例存储一组顺序排列的元素，Map的实例存储一组对象，每个对象都有一个关联的键值。</p>
<p><img src="Set&amp;List类.png" alt="Set和List接口是Collection接口的子接口"><br><img src="Map类.png" alt="Map的实例存储一组对象以及与它们关联的键值"></p>
<h3 id="Collection接口和AbstractCollection类">Collection接口和AbstractCollection类</h3><ul>
<li>Collection接口是处理对象集合的根接口。它的方法详见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="external">API</a>。AbstractCollection类是提供对Collection接口部分实现的便利类。除了size方法和iterator方法之外，它实现了Collection接口中的所有方法。</li>
<li>Iterator接口提供next（）方法，可以依次访问集合中存储的元素。<br><strong>Collection接口中有些方法不能在具体子类中实现。这种情况下，这些方法会抛出异常<code>java.lang.UnsupportedOperationException</code>，该异常是RuntimeException异常的一个子类。</strong></li>
</ul>
<h3 id="规则集Set">规则集Set</h3><ul>
<li>Set接口扩展Collection接口，它没有引入新的方法和常量，只规定它的实例不能包含相同的元素。</li>
<li>AbstractSet类是一个便利类，它扩展了AbstractCollection类并实现了Set接口。</li>
<li>Set接口的三个具体类是HashSet、LinkedHashSet和TreeSet。</li>
</ul>
<h4 id="散列集HashSet">散列集HashSet</h4><ul>
<li>HashSet类可以用来存储互不相同的任何元素。考虑效率的因素，添加到散列集之中的对象必须实现hashCode方法，适当地散列分布散列码。</li>
<li>两个不等的对象可能有相同的散列码。</li>
</ul>
<h4 id="链式散列集LinkedHashSet">链式散列集LinkedHashSet</h4><ul>
<li>在HashSet中元素是没有顺序的，而在LinkedHashSet中，可以按元素插入集合的顺序进行提取。</li>
<li>LinkedHashSet中的元素存储时保持插入的顺序，要想自定义顺序，可以使用<code>TreeHashSet</code>。<br><strong>如果不需要使元素按其插入的顺序进行存储，应该使用HashSet，它的效率要比LinkedHashSet高。</strong></li>
</ul>
<h4 id="树形集TreeSet">树形集TreeSet</h4><p>SortSet是Set的一个子接口，它保证规则集中的元素是有序的。TreeSet是实现SortedSet接口的一个具体类。只有当对象之间可以互相比较是，才可以将它们添加到树形集TreeSet中。</p>
<ul>
<li>有两种方法实现对象的比较：<ul>
<li>使用Comparable接口。如果添加到规则集中的对象是Comparable的实例，就可以使用compareTo方法来比较。这种方法定义的序通常称为<code>自然顺序（natural order）</code>。<strong>参见习题18.7</strong></li>
<li>如果该类不支持Comparable接口，或者在实现Comparable接口的类中不想使用compareTo方法进行比较，可以给规则集的元素创建一个比较器。这种方法定义的序称为<code>比较器顺序（order by comparator）</code>。</li>
</ul>
</li>
<li>创建树形集的好的方法是使用构造方法<code>TreeSet(Collection c)</code>，这样只需要对规则集进行一次排序，效率较高。<br>**如果向树形集添加一个与集合中已有元素不可比的对象，将会发生运行错误<code>ClassCastException</code>。</li>
</ul>
<h3 id="比较器接口Comparator">比较器接口Comparator</h3><ul>
<li>有时想把不同类型的元素添加到同一个树形集内，可以定义一个比较器来比较这些元素。可以创建一个<code>java.util.Comparator</code>接口的类。其方法如下：<ul>
<li>public int compare(Object element1,Object element2)  </li>
<li>public boolean equals(Object element)<br>**Object类也定义了equals方法，因此实现接口时不实现equals方法也不会报错，但是实现该方法可以快速的判断，提高效率。</li>
</ul>
</li>
<li>树形集要想使用一个比较器，必须使用构造方法TreeSet（Comparator comparator）来创建一个有序集。</li>
</ul>
<h3 id="线性表List">线性表List</h3><p>线性表允许在一个集合中存储重复的元素。</p>
<ul>
<li>List接口扩展Collection接口，添加了<code>面向位置（position-oriented）</code>的操作，并且添加了能够双向遍历线性表的新迭代探子。（ListIterator）</li>
</ul>
<h4 id="数组线性表ArrayList和链表LinkedList">数组线性表ArrayList和链表LinkedList</h4><ul>
<li>如果需要使用下标随机访问元素，并且处理在末尾之外，不在其他位置插入或删除元素，使用ArrayList。</li>
<li>如果需要在线性表的任意位置上插入或删除元素，应该选择LinkedList。</li>
<li>如不要求在线性表中插入或删除元素，数组是效率最高的数据结构。</li>
</ul>
<h4 id="向量类Vector">向量类Vector</h4><ul>
<li>Vector类除了包含用于访问和修改向量的同步方法外，它与ArrayList是相同的。同步方法用于防止两个或多个线程同时访问向量时引起数据冲突。</li>
<li>当不需要同步时，最好使用ArrayList，它比Vector快得多。</li>
</ul>
<h4 id="栈类stack">栈类stack</h4><p>栈类stack是最为Vector类的扩展实现的。</p>
<h3 id="一般类型的使用">一般类型的使用</h3><ul>
<li>所有的集合都支持一般类型，可以用记号<code>&lt;&gt;</code>给任一集合中的元素指定一个特定的类型。</li>
<li>从一个只有一种指定元素类型的集合中取值时，不需要进行类型转换。</li>
</ul>
<h3 id="图Map">图Map</h3><ul>
<li>Map接口建立元素和键值的一个映射关系。键值就是下标。</li>
<li>一个图中不能有重复的键值，每个键值对应一个值。</li>
<li>AbstractMap类是一个实现Map接口的便利类，除了entrySet()方法外，它实现了Map接口中的其他方法。SortedMap接口扩展Map接口，其中的映像是以键值升序的方式排列的。</li>
<li>散列图HashMap、链式散列图LinkedHashMap和树形图TreeMap三种类是实现Map接口的具体类。</li>
</ul>
<h4 id="HashMap">HashMap</h4><p>对于定位查找一个值、插入一个映像或删除一个映像，HashMap的效率是很高的。</p>
<h4 id="LinkedHashMap">LinkedHashMap</h4><ul>
<li>它支持图中元素排序。在LinkedHashMap中，元素既可以按照它们插入的顺序排序（称为<code>插入排序（insertion order）</code>），也可以按它们最后一次访问时间的顺序，从最早到最晚（称为<code>访问顺序（access order）</code>）。<ul>
<li>无参构造方法是以插入顺序创建LinkedHashMap对象的。</li>
<li>使用构造方法LinkedHashMap（initialCapacity，loadFactor，true）可以以访问顺序创建LinkedHashMap对象。</li>
</ul>
</li>
</ul>
<h4 id="TreeMap">TreeMap</h4><ul>
<li>它实现了SortedMap接口，它可以按照键值排好的顺序遍历图。键值可以使用Comparable接口或Comparator接口来排序。</li>
<li>构造方法：<ul>
<li>TreeMap（）如果实现了Comparable接口，就可以使用compareTo方法来对集合内中的元素进行排序。</li>
<li>TreeMap（Comparator comparator）可以使用指定比较器来对图中元素进行排序。</li>
</ul>
</li>
</ul>
<p><strong>Map接口不含有迭代探子，为遍历一个图，可以用Map接口的方法<code>enrtySet()</code>来创建一个映像的规则集。该规则集内的每个元素都是一个字符串，它是由代表键值对象的字符串与其对应的映像用等号连接而成的。</strong></p>
<h3 id="Collections类">Collections类</h3><p>Collections类包含管理集合与图、创建同步集合类、创建只读集合类等<code>静态方法</code>。</p>
<h3 id="Arrays类">Arrays类</h3><p>Arrays类中包含对数组进行排序、查找、比较和填充元素的各种<code>静态方法</code>。它还包含了将数组转为线性表的方法。</p>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>Java集合架构中的所有具体类都实现了Cloneable和Serializable接口，所以它们的实例都是可复制和可复制的。</li>
<li>Collections类和Arrays类提供的方法都是静态方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题18.1 18.2 18.3 18.5 18.6 18.7 18.9源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter18/src" target="_blank" rel="external">chapter18</a></li>
<li><p>18.5按字典升序显示单词的实现思路：使用线性表存储每个单词，使用构造方法sort（Comparator comparator）对表中的对象排序，比较器的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DicComparable</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        String s1 = ((String) (o1)).toLowerCase();</span><br><span class="line">        String s2 = ((String) (o2)).toLowerCase();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s1.compareTo(s2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1.compareTo(s2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.7将单词按出现频率升序显示，实现思路：创建一个实现Comparable接口的类Wordoccurrence,该类包含两个域word和count，使用compareTo方法来比较单词的出现次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordOccurrence</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String word;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordOccurrence</span><span class="params">(String word, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; ((WordOccurrence) o).count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; ((WordOccurrence) o).count) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数组线性表和链表是Java中的预定义结构。除此之外，Ja]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第十七章 面向对象数据结构]]></title>
    <link href="http://www.whtis.com/2016/03/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.whtis.com/2016/03/22/Java学习总结-第十七章-面向对象数据结构/</id>
    <published>2016-03-22T15:44:38.000Z</published>
    <updated>2016-09-14T15:48:34.332Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数据结构是按某种方式组织的数据集合。用面向对象的观点来看，一个数据结构就是一个存储着其他对象的对象，存储在数据结构内的对象称为数据或元素。因此数据结构又被称为<code>容器对象（container object）</code>或<code>集合对象（collection object）</code>。<br>本章介绍线性表、堆栈、队列和二叉树等四种动态数据结构。</p>
<h3 id="线性表">线性表</h3><ul>
<li>线性表是存储顺序排列的数据时最常用的数据结构。</li>
<li>线性表可以由数组或者链表实现。这两种类具有相同的操作，但是具有不同的数据域，这些相同的操作可以由接口或抽象类生成。在设计时同时提供接口与抽象类是把它们的优点结合到一起的好策略，这样的抽象类称为<code>便利类</code>。</li>
<li>数组线性表<ul>
<li>数组是一种固定大小的数据结构。但仍然可以采用如下方法实现动态改变：当数组不能再存储线性表中的新元素时，创建一个更大的数组来代替当前数组。这样的数组线性表是一个动态的数据结构。</li>
</ul>
</li>
<li>链表<ul>
<li>由数据创建的线性表，在特定位置进行插入和删除操作效率是很低的，因此可以采用链表结构来提高效率。</li>
<li>链表的遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node temp = first;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">     temp = temp.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="栈和队列">栈和队列</h3><ul>
<li>栈（stack）可以看做是一种特殊的线性表，访问、插入和删除它的元素只能在栈的一端（栈顶）进行。队列可以表示一个排队等待的队伍。它可以看做是一种特殊的线性表，它的元素只能从队列的末端（队列尾）插入，从开始端（队列头）访问和删除。</li>
<li>栈：使用数组线性表来实现栈效率较高。</li>
<li>队列：用链表实现。</li>
</ul>
<h3 id="二叉树">二叉树</h3><ul>
<li>线性表、栈和队列都是由一列元素构成的线型结构。二叉树是一个层次结构，它要么是空集，要么由一个被称为<code>根（root）</code>的元素和两棵不同的子树组成，这两个子树分别称为<code>左子树（left subtree）</code>和<code>右子树（right subtree）</code>。</li>
<li>一个结点的左（右）子树的根节点称为该结点的<code>左（右）孩子（left（right）child）</code>。没有孩子的结点称为<code>叶结点（leaf）</code>。<code>二叉搜索树（binary search tree）</code>是一种常用的特殊二叉树。二叉搜索树的特征是：对它的每一个结点来说，左子树中结点的值都小于该结点的值，右子树中的结点的值都大于该节点的值。</li>
</ul>
<h4 id="二叉树的遍历">二叉树的遍历</h4><ul>
<li><p><code>中序遍历（inorder）:</code>首先访问当前结点的左子树，然后访问当前结点，最后访问该结点的右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       inorder(root.left);</span><br><span class="line">       System.out.print(root.element + <span class="string">" "</span>);</span><br><span class="line">       inorder(root.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>后序遍历（postorder）：</code>首先访问当前结点的左子树，然后访问该结点的右子树，最后访问该结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       postorder(root.left);</span><br><span class="line">       postorder(root.right);</span><br><span class="line">       System.out.print(root.element + <span class="string">" "</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>前序遍历（preorder）：</code>首先访问当前结点，然后访问该结点的左子树，最后访问该结点的右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       System.out.print(root.element + <span class="string">" "</span>);</span><br><span class="line">       preorder(root.left);</span><br><span class="line">       preorder(root.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>深度优先遍历（depth-first）：</code>与前序遍历相同。</p>
</li>
<li><code>广度遍历法（breadth-first）：</code>一层一层的访问树的结点。<br><strong>如果元素的插入顺序不同，树看起来可能不一样，但是只要元素的集合相同，中序序列是一样的。</strong></li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>基本类型的数据不能作为对象存储，但是可以给基本数据类型值创建对应包装类的对象。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题17.1、17.2、17.3、17.6源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter17/src" target="_blank" rel="external">chapter17</a></li>
<li>写双向链表时，在执行下列方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    TreeNode current = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode target = current.next;</span><br><span class="line">    target.pravious.next = target.next;</span><br><span class="line">    target.next.pravious = target.pravious;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行到第7行语句时：list的状态是<code>Method threw &#39;java.lang.NullPointerException&#39; exception. Cannot evaluate _17_3.DoubleLinkedList.toString()</code>,但是整个方法执行完后，不会报错，原因暂时不知道。</p>
<ul>
<li>习题17.6中需要写一个方法，返回二叉树的深度，深度是指二叉树最长路径的结点个数。代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = treeDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = treeDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数据结构是按某种方式组织的数据集合。用面向对象的观点来看]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[base64编码和解码示例代码]]></title>
    <link href="http://www.whtis.com/2016/03/05/base64%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.whtis.com/2016/03/05/base64编码和解码示例代码/</id>
    <published>2016-03-05T15:55:01.000Z</published>
    <updated>2016-09-14T15:46:10.654Z</updated>
    <content type="html"><![CDATA[<p>写密码管理器时，一直在找一种加密方式，除了自己实现外，我还在网上发现了一个不错的方法，<a href="http://www.q3060.com/list6/list144/2717.html" target="_blank" rel="external">源地址在这里</a>。这里仅作抄录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by ht on 2016/2/24.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testorigin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransformBS1 transformBS = <span class="keyword">new</span> TransformBS1();</span><br><span class="line">        transformBS.testS2B();</span><br><span class="line">        transformBS.testB2S();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 今天在网上看到一个程序游戏，只要目的是为了能够将文件中的01二进制数据读取到程序然后通过base64解码，再转换成程序</span><br><span class="line"> * 所以，自己写了个程序：（1）将一段字符串进行base64处理，然后转换成二进制输出。（2）将一段二进制数据转换成字符串，然后base64解码到对应的字符串</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformBS1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @ see 字符串进行base64编码后转换为二进制形式,如：（h(原字符)-&gt;a(编码后)-&gt;01100001010000010011110100111101(二进制形式)）</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testS2B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========字符串到二进制！============="</span>);</span><br><span class="line">        BASE64Encoder e = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line"><span class="comment">//编码器</span></span><br><span class="line">        String s = <span class="string">"我爱你"</span>;</span><br><span class="line">        System.out.println(<span class="string">"尚未编码的数据："</span> + s);</span><br><span class="line">        s = e.encode(s.getBytes());</span><br><span class="line"><span class="comment">//获得base64编码后的字符串</span></span><br><span class="line">        System.out.println(<span class="string">"编码后的数据："</span> + s);</span><br><span class="line">        System.out.print(<span class="string">"二进制数据："</span>);</span><br><span class="line">        String s1 = <span class="string">"whtis\n"</span> + <span class="string">"我爱你\n"</span> + s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1.toCharArray()) &#123;</span><br><span class="line"><span class="comment">//对字符串中的字符逐个转换成二进制数据</span></span><br><span class="line">            String binaryStr = Integer.toBinaryString(c);</span><br><span class="line"><span class="comment">//单个字符转换成的二进制字符串</span></span><br><span class="line">            String format = String.format(<span class="string">"%8s"</span>, binaryStr);</span><br><span class="line"><span class="comment">//因为上面转换成二进制后的位数不够8位所以不足的前面补空格，这里是考虑到能够从数据文件批量读取。</span></span><br><span class="line">            format = format.replace(<span class="string">" "</span>, <span class="string">"0"</span>);</span><br><span class="line"><span class="comment">//高位空格替换成0，其实编码后的数据最大范围为2的6次方，首位一定是空格，不然就要用format.startWith(" ");来判断</span></span><br><span class="line">            System.out.print(format);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n=========字符串到二进制结束！============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @ see 二进制形式转换为字符串后进行base64解码的字符串如：(01100001010000010011110100111101-&gt;a-&gt;h)</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB2S</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========二进制到字符串开始！============="</span>);</span><br><span class="line">        StringBuffer results = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//保存尚未解码的数据结果</span></span><br><span class="line">        String binaryStr = <span class="string">"01110111011010000111010001101001011100110000101011000100001000111100100011000110011110110000000001010001101010110111101101001010100100011010100110100011010010111100000110101010011000011001001100111"</span>;</span><br><span class="line"><span class="comment">//二进制数据，这里是取用上面程序的最后结果</span></span><br><span class="line">        System.out.println(<span class="string">"二进制数据："</span> + binaryStr);</span><br><span class="line"><span class="comment">//这里采用正则表达式来匹配8位长度的数据，然后一个个find()</span></span><br><span class="line">        Matcher matcher = Pattern.compile(<span class="string">"\\d&#123;8&#125;"</span>).matcher(binaryStr);</span><br><span class="line"><span class="comment">//定义匹配模式并，获取模式</span></span><br><span class="line">        BASE64Decoder d = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line"><span class="comment">//解码器</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line"><span class="comment">//在binaryStr中找到了8位长度的数据，依次往后面找</span></span><br><span class="line">            <span class="keyword">int</span> intVal = Integer.valueOf(matcher.group(), <span class="number">2</span>);</span><br><span class="line"><span class="comment">//matcher.group()中存储了找到匹配模式的数据，这里以2进制的形式转换为整数</span></span><br><span class="line">            results.append((<span class="keyword">char</span>) intVal);</span><br><span class="line"><span class="comment">//将整数转换为对应的字符，并添加到结果中</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"尚未解码的数据："</span> + results);</span><br><span class="line"><span class="comment">//输出尚未解码的数据</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(d.decodeBuffer(results.toString()));</span><br><span class="line"><span class="comment">//得到解码后的数据</span></span><br><span class="line">        System.out.println(<span class="string">"解码后的数据："</span> + s);</span><br><span class="line"><span class="comment">//输出解码后的数据</span></span><br><span class="line">        System.out.println(<span class="string">"=========二进制到字符串结束！============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>写密码管理器时，一直在找一种加密方式，除了自己实现外，我还在网上发现了一个不错的方法，<a href="http://www.q3060.com/list6/list144/2717.html" target="_blank" rel="external">源地址在这里</]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="收集整理" scheme="http://www.whtis.com/tags/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GUI练习之二-密码管理器]]></title>
    <link href="http://www.whtis.com/2016/02/20/GUI%E7%BB%83%E4%B9%A0%E4%B9%8B%E4%BA%8C-%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://www.whtis.com/2016/02/20/GUI练习之二-密码管理器/</id>
    <published>2016-02-20T13:31:46.000Z</published>
    <updated>2016-09-14T15:46:30.398Z</updated>
    <content type="html"><![CDATA[<h3 id="功能说明及演示">功能说明及演示</h3><p><del><strong>Swing不是线程安全的，因此使用过程中应避免多开程序，防止出现莫名奇妙的错误。</strong></del><br>北邮人论坛大神给了解决方案，<a href="http://bbs.byr.cn/#!article/Java/47997" target="_blank" rel="external">链接在这</a>，以下内容为复制粘贴：</p>
<blockquote>
<p>Swing不是线程安全的，但也不是大问题。只要把所有的对Swing窗体的的操作都放在专门的线程（event dispatch thread）里做就行了。有一个模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SwingUtilities.invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        createAndShowGUI();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样就线程安全了。这里有详细说明： <a href="http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html" target="_blank" rel="external">http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html</a></p>
</blockquote>
<h4 id="说明">说明</h4><p>综合学习的GUI图形设计和输入输出的知识，实现了一个简易的密码管理器，主要功能如下：</p>
<ul>
<li>可以自己选择密码文件的存放位置</li>
<li>可以选择生成的密码是否可以用文本查看器查看</li>
<li>可以连续的写入新数据</li>
<li>可以根据关键字和密码条件生成相应的密码字符，并提供MD5的显示与查看功能</li>
<li>可以根据网站/网址名进行简单的查看功能</li>
<li>可以同步显示所有存在的密码文件列表</li>
<li>可以选择是否在执行生成按钮后刷新页面，方便直接书写下一个密码文件</li>
<li>其他小功能</li>
</ul>
<h4 id="实现思路">实现思路</h4><p>1、存储密码的同时，将生成密码的条件设置为常量，存储在一个整数数组中（waysOfWirte），并将这值附在生成的密码最后，取值时同时取出来，但是不显示在用户界面上。<br>2、利用文件后缀名的不同区别密码文件的存储格式（二进制存储方式后缀为.w，文本可读后缀名为.wf）。</p>
<h4 id="演示">演示</h4><ul>
<li>初始化设置，程序会在同目录下创建一个名为<code>.pmconfig.w</code>的文件，该文件将密码文件的存放路径写入供以后使用：<br><img src="http://7xnttb.com1.z0.glb.clouddn.com/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C.gif" alt="初始化操作.gif"></li>
<li>主界面的操作：包括密码文件的生成、查看、更新以及删除等操作：<br><img src="http://7xnttb.com1.z0.glb.clouddn.com/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%BB%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C.gif" alt="主界面操作.gif"></li>
</ul>
<h3 id="问题记录">问题记录</h3><ul>
<li>如何回车后使光标出现在下一个输入框中：<br>使用<code>requestFocus（）</code>方法</li>
<li><p>如何创建一个文件夹:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File fileDir = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\ht\\IdeaProjects\\PasswordGenerated\\PasswdGenetated\\"</span>);</span><br><span class="line"><span class="keyword">if</span> (!fileDir.isDirectory()) &#123;</span><br><span class="line"> fileDir.mkdir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何获取系统剪切板并设置内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line"><span class="comment">//复制到剪切板上</span></span><br><span class="line">StringSelection ss = <span class="keyword">new</span> StringSelection(password);</span><br><span class="line">clipboard.setContents(ss, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何获取当前系统的目录树并选取目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JFileChooser fileChooser = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">   fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);</span><br><span class="line">   <span class="keyword">int</span> i = fileChooser.showOpenDialog(<span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (i == fileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">       String path = fileChooser.getSelectedFile().getAbsolutePath();</span><br><span class="line">       String name = fileChooser.getSelectedFile().getName();</span><br><span class="line">       System.out.println(path + name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了保证跨平台使用，将windows路径中的”\“替换为”/“</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"/"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何实现初始化界面设置密码文件位置后隐藏该界面，继而出现主界面<br>PasswordManger类中initFrame和mainFrame的先后设置。</p>
</li>
<li><p>如何使JList能够实时显示密码文件的个数</p>
<ul>
<li><p>使用<code>setModel（javax.swing.ListModel&lt;E&gt; model）</code>方法。该方法要求传入一个Model对象，ListModel的使用用例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileModel</span> <span class="keyword">extends</span> <span class="title">AbstractListModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String[] files;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FileModel</span><span class="params">(String[] files)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.files = files;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (index + <span class="number">1</span>) + <span class="string">"."</span> + files[index++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> files.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ListModel是一个接口，如果实现该接口，需要实现一些不必要的方法：<code>void addListDataListener(ListDataListener l)</code>和<code>void removeListDataListener(ListDataListener l)</code>,但是Java提供了一个便捷类AbstractListModel，继承该类，就可以避免实现以上方法。</p>
</li>
<li>除了AbstractListModel类，还有其他抽象类如DefaultListModel，但是DefaultListModel实现了ListModel的所有方法，因此可以做的更改比较小。</li>
<li>为了监听FileModel的变化，可以采用这种方法：在每次JList内容发生变化时重新创建一个FIleModel，传入的是更新后的数组，再使用JList的<code>updateUI()</code>方法，就可以动态显示JList的内容了。<br><em>可以给FileModel添加一个监听器类<code>ListDataListener</code>,并实现该接口的抽象方法。（网上介绍，未做）</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateJList</span><span class="params">(String fileDirPath)</span> </span>&#123;</span><br><span class="line">        String[] files = <span class="keyword">new</span> File(fileDirPath).list();</span><br><span class="line">        FileModel fileModel = <span class="keyword">new</span> FileModel(files);</span><br><span class="line">        mainFrame.getJlFileName().setModel(fileModel);</span><br><span class="line">        mainFrame.getJlFileName().updateUI();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">- 根据指定条件生成密码</span><br><span class="line">  + 我使用如下方法，返回的字符都是字符<span class="string">'A'</span></span><br><span class="line">  ```<span class="function">java</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">generateChar</span><span class="params">(<span class="keyword">char</span> aChar, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">int</span> a = aChar + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= low &amp;&amp; a &lt;= high) &#123;</span><br><span class="line">            c = (<span class="keyword">char</span>) a;</span><br><span class="line">  <span class="comment">//          return c;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; low) &#123;</span><br><span class="line">  <span class="comment">//          return generateChar((char) (a + 6), low, high);</span></span><br><span class="line">  			  generateChar((<span class="keyword">char</span>) (a + <span class="number">6</span>), low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; high) &#123;</span><br><span class="line">  <span class="comment">//          return generateChar((char) (a - 30), low, high);</span></span><br><span class="line">  		      generateChar((<span class="keyword">char</span>) (a - <span class="number">30</span>), low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>问题原因：递归不设出口，每次递归返回的值都在递归自己这一层，无法返回到最初的一层<br>解决方法：使用注释掉的三条语句，删除相应的错误语句。<br><strong>递归不设出口毫无意义</strong></p>
<ul>
<li>异常<br><code>java.lang.stackOverflow</code> 堆栈溢出，原因是递归太深</li>
</ul>
</li>
<li><p>生成密码的MD5值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generateMD5</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = md5.digest(password.getBytes());</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> x : bs) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x &amp; <span class="number">0xff</span>) &gt;&gt; <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">"0"</span>).append(Integer.toHexString(x &amp; <span class="number">0xff</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(Integer.toHexString(x &amp; <span class="number">0xff</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始选取配置文件路径时若该路径存在其他文件，应该避免出现在JList中</p>
</li>
</ul>
<h3 id="源码">源码</h3><p>见我的GitHub：<a href="https://github.com/whtis/PasswordManager/tree/master/src" target="_blank" rel="external">PasswordManager</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="功能说明及演示">功能说明及演示</h3><p><del><strong>Swing不是线程安全的，因此使用过程中应避免多开程序，防止出现莫名奇妙的错误。</strong></del><br>北邮人论坛大神给了解决方案，<a href="http://bbs.by]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="小练习" scheme="http://www.whtis.com/tags/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十六章 简单输入输出]]></title>
    <link href="http://www.whtis.com/2016/02/18/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%AE%80%E5%8D%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://www.whtis.com/2016/02/18/Java学习总结-第十六章-简单输入输出/</id>
    <published>2016-02-18T11:37:58.000Z</published>
    <updated>2016-09-14T15:49:34.036Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章主要讨论数据持久化的问题。一般Java程序在结束后所有存储在内存中的数据都会消失，为了保留这些数据，就要学会如何将它们存储到磁盘文件或光盘文件中。<br>本章介绍的主要是两个方面的内容：文本I/O和二进制I/O。为了知识的连贯性，需要先介绍相关的知识，以方便理解。<br><strong>计算机中所有文件都是以二进制格式来存储的。文本I/O是在二进制I/O基础上提供了一层抽象，它封装了字符的编码和解码过程，在文本I/O中自动进行编码和解码。</strong></p>
<h3 id="提前需要知道的一些知识">提前需要知道的一些知识</h3><ul>
<li>windows和Unix文件存储目录的不同。</li>
<li>位、字节、字符、ASCII码和统一码Unicode相关知识。<br>位，英文是bit，是用来表示计算机数据的一种计量单位，8bit为一个字节，ASCII码采用一个字节存储二进制数据，Java中统一码采用两个字节进行存储，统一码的低字节就是ASCII码，因此在Java中，字符是由两个字节构成的。</li>
<li>Java中基本数据类型都占几个字节。如，int类型是4个字节，char类型是2个字节。</li>
</ul>
<h3 id="文件类File">文件类File</h3><p>无论是文本I/O还是二进制I/O的构造方法，都需要传入文件类参数或者文件名参数。</p>
<h4 id="文件系统相关">文件系统相关</h4><ul>
<li>目录路径与文件名全称是平台依赖的。</li>
<li>为了解决不同平台路径与分隔符的问题，File类提供了四个常量：<ul>
<li>File.PathSeparator </li>
<li>File.PathSeparatorChar <code>&quot;/&quot;</code>or<code>&quot;\&quot;</code> </li>
<li>File.Separator </li>
<li>File.SeparatorChar <code>&quot;;&quot;</code>or<code>&quot;:&quot;</code></li>
</ul>
</li>
<li><code>绝对路径（absolute path）</code>名是依赖于系统的，如果想开发平台无关的程序，一定不要用绝对路径。可以使用和平台无关的常量创建一个相对路径。（简单的方法是无论Win还是Linux，相对路径分隔符都使用”/“即可。）</li>
</ul>
<h4 id="File类的常用方法简录">File类的常用方法简录</h4><ul>
<li>构造方法：<ul>
<li>File（pathname：String）<br>······</li>
</ul>
</li>
<li>常用方法<ul>
<li>exists（） 检测文件是否存在</li>
<li>isDirectory（）/isFile（） 是目录/文件</li>
<li>isAbsolute（） 该文件是否由绝对路径创建</li>
<li>getAbsolutePath（） 返回File对象的绝对路径</li>
<li>getCanonicalPath（） 返回值与getAbsolutePath（）相同，但是删除了一些冗余符号</li>
<li>getPath（）</li>
<li>getParent（）<br>······</li>
</ul>
</li>
</ul>
<h3 id="文本I/O类">文本I/O类</h3><ul>
<li>File类不提供从文件中读写数据的方法，因此需要选择适当的输入输出类来进行I/O操作。<strong>输入输出都是对于程序本身而言</strong>。<br><img src="文本IO类.jpg" alt="文本I/O类"></li>
<li>Reader类是文本输入的根类，Writer类是文本输出的根类。</li>
<li>Reader类常用方法：<ul>
<li>read（） 从输入流读取下一个字符，返回值在0到65525之间，表示该字符的统一码。到达流的结尾时返回-1<br>···</li>
</ul>
</li>
<li>Writer类常用方法：<ul>
<li>flush（） 刷新该输出流，并将已经输出到缓冲区的所有字符写入文件<br>···</li>
</ul>
</li>
<li>read（）方法读取字符，如果没有有效字符，那么它将阻塞线程。</li>
<li>处理PrintWriter类，其他文本I/O类中的所有方法都声明抛出异常java.io.IOException。</li>
</ul>
<h4 id="FileReader类和FileWriter类">FileReader类和FileWriter类</h4><ul>
<li>使用主机上默认的字符编码方式进行读写操作。</li>
<li>所有方法均继承自父类，没有新的方法。</li>
<li>FileReader类read（）方法是读取一个<strong>字节</strong></li>
<li>FileWriter构造方法支持参数append：<ul>
<li>FileWriter(File file,booean append) 如果原文件存在，可以通过设置append参数决定是覆盖还是追加</li>
</ul>
</li>
</ul>
<h4 id="InputStreamReader类和OutputStreamWriter类">InputStreamReader类和OutputStreamWriter类</h4><ul>
<li>可以在构造方法中指定使用哪种编码方案进行读写操作。</li>
<li>用于实现字符与字节之间的转化。写入OutputStreamWriter的字符用指定的编码方案翻译为字节。 </li>
<li>除<code>getEncoding()</code>方法外，均继承自父类方法。getEncoding()方法返回这个数据流使用的编码方案名称。<br><strong>Java程序使用的是统一码（Unicode）。从FileReader流中读取一个字符时，返回该字符的统一码。字符在文件中的编码可能不是统一码，Java自动将它转化为统一码，想FileWriter流中写入字符时，Java自动的将统一码转化为文件指定编码。</strong></li>
</ul>
<h4 id="BufferedReader类和BufferedWriter类">BufferedReader类和BufferedWriter类</h4><ul>
<li>用于输出字符与字符串。</li>
<li>BufferedReader类和BufferedWriter类通过减少读写次数来加快输入输出的速度。缓冲区数据流使用一个类似高速缓冲器作用的字符数组。缓冲区默认是<code>8192</code>个字节。</li>
<li>缓冲区输出流只有当它的缓冲区已满或调用<code>flush()</code>方法才调用写入文件的方法。</li>
<li>BufferedReader常用方法：<ul>
<li>readLine（） 整行读取（不带换行符的一行），到达流的末尾时，返回<code>null</code><br>···</li>
</ul>
</li>
<li>BufferedWriter常用方法：<ul>
<li>newLine（） 向文件写入一个依赖平台的换行符。以下方法可以获得系统的换行符：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String lineSeparator = (String) java.security.AccessController.doPrivileged(<span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>物理输入输出的I/O设备比CPU的速度慢得多，因此读取一个大文件时，使用缓冲区能够较大地提高效率。</strong></p>
<h4 id="PrintWriter类和PrintStream类">PrintWriter类和PrintStream类</h4><ul>
<li>可以将对象、字符串和数值以<code>文本</code>方式输出。</li>
<li>PrintWriter的效率比PrintStream高，功能一样，前者用于替代后者。</li>
<li>打印数值、字符或布尔值，就是将其转化为字符串打印。打印一个对象就是打印该对象用<code>toString()</code>方法返回的描述字符串。</li>
<li>printf（）方法用于格式化输出。</li>
<li><em>System.out解析</em><br>out是定义在System类中类型为PrintStream的一个静态变量。默认情况下，out是标准输出设备，即屏幕。可以使用<code>setOut()</code>方法设置新的out。</li>
<li>常用构造方法：<ul>
<li>public PrintWriter（Writer out，boolean autoFlush） autoFlush为true，println方法会引起缓冲区刷新</li>
</ul>
</li>
</ul>
<h3 id="二进制I/O">二进制I/O</h3><ul>
<li>二进制输入输出不需要进行文本的编码与解码操作，所以要比文本I/O效率高。向文件写入字节，就是将源字节复制到文件中，从文件读取字节，就是将文件中的字节原样返回。<br><img src="二进制IO类.jpg" alt="二进制I/O类"></li>
<li>InputStream和OutputStream的所有方法与Reader和Writer中的方法类似，不同的是前者操作的是字节，后者操作的是字符。</li>
<li>InputStream类和OutputStream类是抽象类。</li>
<li>InputStream类常用方法：<ul>
<li>read（） 从输入流中读取数据的下一个字节，返回值为0~255之间的整数，如果到达流尾，返回-1</li>
<li>available（） 返回可以从该输入流读取的字节数</li>
<li>mark（int readlimit） 在该输入流中标记当前位置<br>···</li>
</ul>
</li>
<li>OutputStream类常用方法：<ul>
<li>write（int b） 将指定字节写到输出流，参数b是int型，写入的值是（byte）b</li>
<li>flush（）<br>···</li>
</ul>
</li>
</ul>
<h4 id="FileInputStream类和FileOutputStream类">FileInputStream类和FileOutputStream类</h4><ul>
<li>继承自父类的方法，没有引进新方法</li>
<li>输入输出均是操作的字节。</li>
</ul>
<h4 id="FilterInputStream类和FilterOutputStream类">FilterInputStream类和FilterOutputStream类</h4><p><code>过滤器数据流（filter stream）</code>是为某种目的过滤字节的数据流。基本字节输入流提供的读取方法只能用来读取字节，如果想要读取整数值、双精度值或字符串，需要一个过滤器类来包装输入流。</p>
<ul>
<li>该类是父类，如果需要处理基本数值类型数据时，可以使用DataInputSteam类和DataOutputStream类来过滤字节。</li>
</ul>
<h4 id="DataInputStream类和DataOutputStream类">DataInputStream类和DataOutputStream类</h4><ul>
<li>DataInputSteam从数据流中读取字节并将它们转化为适当的基本类型值或字符串。DataOutputStream将基本类型的值或字符串转化为字节并将这些字节输出到输出数据流。</li>
<li>DataOutputStream类和DataInputSteam类以平台无关的方式读写Java的基本类型值和字符串。</li>
<li>可以使用<code>input.available()==0</code>方法检测读取是否已经到了结尾。</li>
<li>DataInputSteam扩展<code>FilterInputStream</code>类并实现<code>DataInput</code>接口；DataoutputStream扩展<code>FilterOutputStream</code>类并实现<code>DataOutput</code>接口。</li>
<li>DataInput类常用方法： <ul>
<li>readInt（） 从输入流中读取一个int值（输入流是一个字节一个字节读入，DataInputSteam的作用就是将读入的字节4个4个组合，其他方法类似）</li>
<li>readUTF（） 从UTF格式中读取一个字符串<br>···</li>
</ul>
</li>
<li>Dataoutput类常用方法：<ul>
<li>writeByte（int v） 将参数v的低8位（一个字节）写到输出流（如果参数v是在Java中被赋值，那么v的统一码是16位（两个字节），调用该方法只能将低字节（低8位）写到输出流）</li>
<li>writeBytes（String s） 将字符串中字符的低8位写到输出流，适合由ASCII字符构成的字符串</li>
<li>writeChar（char c） 向输出流中写一个字符（两个字节构成）</li>
<li>writeChars（String s） 将字符串s中的每一个字符依次写到输出流，每个字符占两个字节</li>
<li>writeInt（int v） 向输出流写一个int值</li>
<li>writeUTF（String s） 用UTF格式写出一个字符串<br>···<br><strong>由此可知，如果要使用二进制I/O，必须使用相对应的输入输出方法以及正确的顺序才能得到正确的数据。</strong></li>
</ul>
</li>
<li><em>UTF编码</em><ul>
<li>UTF是一种编码方案，它可以使系统高效的同时处理统一码（Unicode）和ASCII码。ASCII码字符集是统一码字符集的一个子集。</li>
<li>为了解决8位ASCII码转为16位统一码造成的浪费问题，提出来UTF编码。UTF编码方案分别使用1字节、2字节或3字节来存储字符。<ul>
<li>ASCII码的值不会超过0x7F,使用一个字节编码</li>
<li>不超过0x7FF的统一码值编码为两个字节</li>
<li>其余编码为三个字节</li>
</ul>
</li>
<li>UTF字符的开始几位表明该字符的编码是几个字节的：<ul>
<li>首位是0,一个字节的字符</li>
<li>前三位是110，两个字节字符的第一个字节</li>
<li>前四位是1110，它是三字节字符的第一个字节</li>
</ul>
</li>
<li>UTF字符串的前两个字节用来存储字符串中的字符个数。如：writeUTF(“ABCDEF”)写入的是8个字节</li>
<li><strong>如果字符串的大多数字符都是普通的ASCII字符，采用UTF格式存储的效率是很高的。</strong></li>
</ul>
</li>
</ul>
<h4 id="BufferedInputStream类和BufferedOutputStream类">BufferedInputStream类和BufferedOutputStream类</h4><ul>
<li>提供缓冲区，加快读写<code>字节</code>的效率。缓冲区默认大小为<code>512</code>个字节。</li>
</ul>
<h3 id="对象输入输出">对象输入输出</h3><ul>
<li>DataInputSteam类和DataOutputStream类可以实现基本数据类型与字符串的输入输出，在此基础上，ObjectInputStream类和ObjectOutputStream类还允许对象的输入输出。</li>
<li>可以完全用ObjectInputStream类和ObjectOutputStream类替代DataInputSteam类和DataOutputStream类。</li>
<li>ObjectInputStream扩展<code>InputStream</code>类并实现<code>ObjectInput</code>和<code>ObjectStreamConstants</code>接口,<code>ObjectInput</code>是<code>DataInput</code>的子接口；ObjectOutputStream扩展<code>OutputStream</code>类并实现<code>ObjectOutput</code>和<code>ObjectStreamConstants</code>接口,<code>ObjectOutput</code>是<code>DataOutput</code>的子接口。<code>ObjectStreamConstants</code>包含ObjectInputStream类和ObjectOutputStream类中所用的常量。<br><img src="Object输入输出类.jpg" alt="Object输入输出"></li>
<li>常用构造方法：<ul>
<li>public ObjectInputStream（InputStream in）</li>
<li>public ObjectOutputStream（OutputStream out）</li>
</ul>
</li>
<li>可以向数据流中写入多个对象或基本类型数据。从对应的ObjectInputStream中读回这些对象时，必须与其存入时的类型和顺序相同。对于必要的类型，必须使用Java安全性所要求的类型转换。（显式转换）</li>
</ul>
<h4 id="可序列化接口Serializable">可序列化接口Serializable</h4><ul>
<li>并不是每一个对象都可以写到输出流。可以写入到输出流中的对象称为<code>可序列化的（serializable）</code>。</li>
<li>可序列化的对象时java.io.Serializable接口的实例，所以可序列化对象的类必须实现Serializable接口。</li>
<li>Serializable接口是一种标记性接口。它没有方法，要实现这个接口可以启动Java机制，自动执行存储对象或数组的过程。</li>
<li>Java提供了自动进行写对象这个过程的内在机制，这个过程称为<code>对象序列化（object serialization）</code>。与此相反，读取对象的过程称为<code>对象解读序列化（object deserialization）</code>。它是在ObjectInputStream类中实现的。</li>
<li>存储一个可序列化对象时，会对该对象的类进行编码，编码包括类名、类的说明标志、对象实例变量的值以及任何从初始对象引用的其他对象包，但是不存储对象静态变量的值。</li>
<li><p>如果一个对象时Serializable的实例，但它包含一个非序列化的数据域，该对象不是可序列化的。为了是该对象可序列化，可以给这些数据域加上关键字<code>transient</code>，告诉Java虚拟机将对象写入对象流时忽略这些数据域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> v1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> v2;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> A v3 = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125; <span class="comment">//A is not serializable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个对象多次写入对象流，第一次存储一个可序列化对象时，会创建一个序列号，Java虚拟机将对象的所有内容包括序列号一起写入对象输出流，以后的存储，都是存储序列号的一个拷贝，换句话说，只存储引用。</p>
</li>
</ul>
<h4 id="序列化数组">序列化数组</h4><p>当数组中的元素是可序列化的时候，数组也是可序列化的。一个完整的数组可以用writeObject方法存入文件，此后使用readObject方法将它读出。</p>
<h3 id="随机读写文件">随机读写文件</h3><ul>
<li>Java提供了RandomAccessFile类，它允许对文件内的随机位置进行读写。</li>
<li>RandomAccessFile类实现了DataInput和DataOutput接口。</li>
<li>常用方法：<ul>
<li>RandomAccessFile（File file，String mode） 以指定File和模式创建，模式可以是”r”、”rw”等</li>
<li>getFilePointer（） 返回从文件头到发生读写位置的偏移量</li>
<li>length（） 返回文件的字节数</li>
<li>seek（long pos） 设置从文件头到下一次读写位置的偏移量</li>
<li>setLength（long newLength） 给这个文件设置一个新长度<br>···</li>
</ul>
</li>
<li>随机读写文件是由字节序列组成的，在其中某个字节的位置处有一个称为<code>文件指针（file pointer）</code>的特殊标记。文件的读写操作就是在文件指针所指的位置上进行的。</li>
<li><strong>文件指针置于文件的开头。</strong></li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>本章可能出现的异常总结如下：<ul>
<li>企图用一个不存在的文件创建FileReader/FileWriter对象，出现异常<code>FileNotFoundException</code>。</li>
<li>到达文件尾后还想读取数据，报<code>java.io.EOFException</code>异常。</li>
<li>readObject（）方法可能抛出<code>ClassNOtFoundException</code>异常。</li>
</ul>
</li>
<li>FilterInputStream类和FilterOutputStream类的作用在于：基本的字节输入输出流只能操作字节，但是基本类型的数据如int类型是4个字节，如果想要读取正确的int值，仅靠基本的FileInputStream和FileOutputStream类是无法完成的，因此需要在这基础上包装一层Filter Stream，使用该包装类的方法可以正确存取基本类型的数据。</li>
<li>随机读写文件常被用来处理记录型文件，因为记录型文件每条记录的大小可以设置为固定的。这样，每次操作时，就可以确定文件指针的偏移量了。</li>
<li>随机读写虽然说是文件指针位于文件头，但显示的实际情况是：<br><em>在空文件中插入一条记录，此时文件指针位于这条记录末尾，但是显示的却是这条记录，这点要牢记。</em></li>
<li>I/O类可分为文本I/O和二进制I/O。文本I/O将数据解释成字符的序列，二进制I/O将数据解释成原始的二进制数。文本在文件中如何存储依赖于文件的编码方式。Java对文本I/O提供自动编码与解码。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>16.1 单词统计可以使用StringTokenizer类的countTokens（）方法或者使用正则匹配。</li>
<li>16.4 重写Java源代码格式。代码提供了行尾风格和次行风格相互转化的方法。</li>
<li>16.5 使用字符串的<code>replaceAll()</code>方法删除字符。</li>
<li>16.14 代码参考<a href="http://www.whtis.com/2016/02/16/GUI%E5%B0%8F%E7%BB%83%E4%B9%A0-%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/">GUI小练习-简易计算器</a></li>
<li>16.15 代码见文件夹AddressBook。</li>
<li>其余习题16.7 16.8 16.10 16.11源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter16/src" target="_blank" rel="external">chapter16</a></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章主要讨论数据持久化的问题。一般Java程序在结束后所]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GUI小练习-简易计算器]]></title>
    <link href="http://www.whtis.com/2016/02/16/GUI%E5%B0%8F%E7%BB%83%E4%B9%A0-%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://www.whtis.com/2016/02/16/GUI小练习-简易计算器/</id>
    <published>2016-02-16T10:51:30.000Z</published>
    <updated>2016-09-14T15:46:19.078Z</updated>
    <content type="html"><![CDATA[<h2 id="简易说明">简易说明</h2><ul>
<li>学习了Java图形界面设计，写了一个简易的计算器，实现的功能如下：<ul>
<li>基本的加减乘除四则运算</li>
<li>连续计算</li>
<li>运算结果记忆</li>
<li>程序启动次数统计</li>
</ul>
</li>
<li>本来打算添加其它功能，不过基本框架出来也就不打算在这部分停留太久，暂时写下设计的功能，等以后有更简单的方法处理连续计算的时候再回来重写一下吧：<ul>
<li>显示结果的处理，包括两个整数作运算，结果应该显示为整数、浮点数显示的位数设定等。目前为了方便，统一转为了浮点数进行计算，显示的结果也是浮点数。</li>
<li>初始设计了四个功能键，依次为<code>Ac</code>（清零）、<code>Cv</code>（小数和分数的转化）、<code>Re</code>（最近一次结果记忆），<code>←</code>（删除），目前除<code>Cv</code>外都已实现。</li>
<li>目前显示结果为单行显示，最初考虑的是双行，但因为文本对齐和设置的问题无法处理，最终采用的JTextField进行单行显示。</li>
<li>组件的等比例放大和缩小问题。目前只能做到自动，因此将其设置成为了不可更改大小,避免破坏布局。</li>
</ul>
</li>
</ul>
<h2 id="遇到的问题及解决方案记录">遇到的问题及解决方案记录</h2><h3 id="布局问题">布局问题</h3><ul>
<li>如何拼凑无缝的界面<ul>
<li>解决方法:略</li>
</ul>
</li>
</ul>
<h3 id="加减乘除运算问题">加减乘除运算问题</h3><ul>
<li>第一次就按运算符的处理<ul>
<li>如果是初始操作，无视之</li>
<li>判断StringBuffer对象里是否有东西，如果没有，直接设置运算符compute</li>
</ul>
</li>
<li>多次按运算符的处理<ul>
<li>创建一个string类型的值来存储运算符，但同时只能设置一个</li>
</ul>
</li>
<li>连续运算的问题（貌似链表处理比较简单？没学过，布吉岛…）<ul>
<li>计算器能够正常运行的一系列设计，包括stringbuffer、compute、result等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">computeAction</span><span class="params">(ActionEvent e, JTextField textField)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="小数点的问题">小数点的问题</h3><ul>
<li><p>直接按小数点应该将其设置成正确的小数形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stringBuffer.toString().startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            stringBuffer.insert(<span class="number">0</span>, <span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>小数点在一次运算中只能出现一次，多按无效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"."</span>:</span><br><span class="line">      <span class="keyword">boolean</span> hasDot = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuffer.length(); i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (stringBuffer.charAt(i) == <span class="string">'.'</span>) &#123;</span><br><span class="line">              hasDot = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!hasDot) &#123;</span><br><span class="line">          capicaty++;</span><br><span class="line">          stringBuffer.append(<span class="string">"."</span>);</span><br><span class="line">          textField.setText(stringBuffer.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="等于问题">等于问题</h3><ul>
<li>仅仅在初始时输入数字，不进行任何运算，按下等于号应该显示初始输入的数字，并将result设置为相关的值，从而进行下次运算<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(capicaty&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">	textField.setText(String.valueOf(result));</span><br><span class="line">    reResult = result;</span><br><span class="line">    compute = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="除法问题">除法问题</h3><ul>
<li>出现不合法的运算会得到Infinity，为了界面友好，显示为’0’<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"÷"</span>:</span><br><span class="line">    result /= Double.parseDouble(stringBuffer.toString());</span><br><span class="line">    <span class="keyword">if</span> (String.valueOf(result).equals(<span class="string">"Infinity"</span>)) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码">代码</h2><ul>
<li>完整的代码见我的Github：<a href="https://github.com/whtis/Calculator" target="_blank" rel="external">Calculator</a></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简易说明">简易说明</h2><ul>
<li>学习了Java图形界面设计，写了一个简易的计算器，实现的功能如下：<ul>
<li>基本的加减乘除四则运算</li>
<li>连续计算</li>
<li>运算结果记忆</li>
<li>程序启动次数统计</li>
<]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="小练习" scheme="http://www.whtis.com/tags/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十三章 创建图形用户界面]]></title>
    <link href="http://www.whtis.com/2016/02/15/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
    <id>http://www.whtis.com/2016/02/15/Java学习总结-第十三章-创建图形用户界面/</id>
    <published>2016-02-15T14:32:39.000Z</published>
    <updated>2016-09-14T15:48:42.637Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章综合第十一、十二章的内容，介绍GUI编程中常用的组件。</p>
<h3 id="Swing_GUI组件的公共特性">Swing GUI组件的公共特性</h3><ul>
<li>Component类是所有用户界面组件和容器的根类，Jcomponent类是大多数Swing组件的根类。</li>
<li>GUI组件都有处理字体、颜色、大小、工具提示文本和边框等属性的方法。</li>
<li>可以在Jcomponent类的任何对象上设置边框。<ul>
<li>TitleBorder(String title) 创建标题边框</li>
<li>LineBorder(Color color,int width) 创建线型边框</li>
</ul>
</li>
<li><strong>容器类Container类是Swing GUI组件类的父类。</strong></li>
</ul>
<h3 id="按钮（JButton）">按钮（JButton）</h3><p><code>按钮（button）</code>是一种点击时触发行为事件的组件。Swing提供常规按钮、开关按钮、复选框和单选按钮。</p>
<ul>
<li>Jbutton可以响应多种类型的事件，通常我们只需要响应ActionEvent事件。</li>
<li>按钮可以设置工具提示文本（<code>setToolTipText(xxx)</code>）和热键（<code>setMnemonic(xxx)</code>）。</li>
</ul>
<h4 id="图标">图标</h4><ul>
<li>图标是一个固定大小的图片，典型的图标体型较小，用于装饰组件。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Icon icon = <span class="keyword">new</span> ImageIcon(<span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>java目前支持GIF、PNG、JPEG三种图像格式。</strong></p>
<ul>
<li>每个常规按钮有一个默认图标，一个按下图标和一个在上图标，使用如下方法进行设置：<ul>
<li>setPressedIcon(“XXX”) 设置按钮按下的图标</li>
<li>setRolloverIcon(“xxx”) 设置鼠标停留在按钮上时的图标</li>
</ul>
</li>
</ul>
<h4 id="对齐方式">对齐方式</h4><ul>
<li><p><code>水平对齐（horizontal alignment）</code>指定以什么样的方式在<strong>按钮</strong>上放置文本和图标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setHorizontalAlignment(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>int的取值为：SwingConstants.LEADING(LEFT、CENTER、RIGHT、TRAILING)。默认的是最后一种（右对齐）。</li>
</ul>
</li>
<li><p><code>垂直对齐（vertical alignment）</code>指定以什么样的垂直方式在按钮上放置文本和图标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setVerticalAlignment(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>int的取值为：SwingConstants.TOP(CENTER、BOTTOM)，默认的是CENTER。</li>
</ul>
</li>
</ul>
<h4 id="文本位置">文本位置</h4><ul>
<li><code>水平文本位置（horizontal text position）</code>指定文本相对于图标的水平位置。</li>
<li><code>垂直文本位置（Vertical text position）</code>指定文本相对于图标的垂直位置。</li>
<li>设置方式和默认值与对齐方式相同。</li>
</ul>
<h3 id="复选框（JCheckBox）">复选框（JCheckBox）</h3><ul>
<li>一个<code>开关按钮（toggle button）</code>有两种状态，JToggleButton类继承AbstractButton并实现了一个开关按钮。开关按钮分为两种：<br>1、JCheckBox 复选按钮（方形）<br>2、 JRadionButton 单选按钮（圆形）</li>
<li>JCheckBox先触发的是ItemEvent事件，然后触发ActionEvent事件。要确定复选框是否被选中，使用<code>isSelected()</code>方法。</li>
</ul>
<h3 id="单选按钮（JRadioButton）">单选按钮（JRadioButton）</h3><ul>
<li><code>单选按钮（radio button）</code>，或者叫<code>选择按钮(option button)</code>,让用户从一组选项中选择唯一的一个选项。</li>
<li>单选按钮使用Java.swing.ButtonGroup类的实例进行组织，并使用add方法添加按钮<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ButtonGroup group = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line">group.add(xx1);</span><br><span class="line">group.add(xx2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果没有创建按钮组，就无法达到单选的目的。</p>
<ul>
<li>JRadioButton先触发的是ItemEvent事件，然后触发ActionEvent事件。要确定复选框是否被选中，使用<code>isSelected()</code>方法。</li>
</ul>
<h3 id="标签（JLable）">标签（JLable）</h3><ul>
<li><code>标签（lable）</code>是显示一小段文字、一幅图片或二者皆有的区域。</li>
<li>JLable继承自JComponent类，具有与JButton类似的属性。</li>
</ul>
<h3 id="文本域（JTextField）">文本域（JTextField）</h3><ul>
<li><code>文本域（text field）</code>可以用于输入或显示字符串。（单行）</li>
<li>JTextField继承自JTextComponent类。</li>
<li>JTextField触发的是ActionEvent事件（回车键触发）。</li>
</ul>
<h3 id="文本区（JTextArea）">文本区（JTextArea）</h3><ul>
<li>文本区用户输入多行文本。</li>
<li>可以创建指定行列的文本区，JTextArea继承自JTextComponent类。</li>
<li><p>JTextArea无法滚动，但可以创建一个<code>JScrollPane</code>对象处理滚动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JScrollPane scrollPane = <span class="keyword">new</span> JScrollPane(<span class="keyword">new</span> JTextArea());</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用属性</p>
<ul>
<li>setLineWrap（boolean b） 是否换行</li>
<li>setWrapStyleWord（boolean b） 是否按单词换行，默认按照字符换行</li>
<li>setEditable（boolean b） 是否可编辑</li>
</ul>
</li>
</ul>
<h3 id="组合框（JComboBox）">组合框（JComboBox）</h3><ul>
<li><code>组合框（combo box）</code>，也叫<code>选择列表（choice list）</code>或<code>下拉式列表（drop-down list）</code>，它包含项目的一个列表，用户能够从中选择。<strong>使用它可以限制用户的选择范围并能避免对输入数据有效性的繁复检查。</strong></li>
<li>JComboBox可以引发ActionEvent和ItemEvent事件。选中一个新的项目是，JComboBox会产生两次ItemEvent事件，一次是取消前一个项目，另一次是选中当前项目。</li>
<li>常用方法<ul>
<li>getSelectedItem（）方法返回已经选定的项目</li>
<li>getSelectedIndex（） 返回选中的项目次序号</li>
</ul>
</li>
</ul>
<h3 id="列表框（JList）">列表框（JList）</h3><ul>
<li><code>列表框（list）</code>是一个组件，与JComboBox类似，但是它允许用户选择一个或多个项目。</li>
<li><p>选择模式属性selectionMode取值如下，默认为多区间选择</p>
<ul>
<li>SINGLE_SELECTION 单项选择</li>
<li>SINGLE_INTERVAL_SETECTION 单区间选择（允许选择多项，但是必须连续）</li>
<li>MULTIPLE_INTERVAL_SETECTION 多区间选择<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JList不能自动滚动，可以参考文本区的方法设置滚动。</p>
</li>
<li>JList触发ListSelectionEvent事件。</li>
<li>常用方法：<ul>
<li>getSelectedIndices（） 以数组形式返回选中的次序号</li>
<li>getSelectedValues（） 以数组形式返回选中的值</li>
<li>getVisibleRowCount（） 返回可见行数</li>
</ul>
</li>
</ul>
<h3 id="滚动条（JScrollbar）">滚动条（JScrollbar）</h3><ul>
<li><code>滚动条（scrollbar）</code>是一个控制器，它使用户能从值得一个范围中进行选择。</li>
<li>JScrolBar的属性如下：<ul>
<li>orientation（方向）：指定滚动条的水平或垂直模式。</li>
<li>maximum（最大值）: 指滚动条的最大值。</li>
<li>minimum（最小值）</li>
<li>visibleAmount（宽度，也叫广度）：是指滚动块的相对宽度。滚动块在屏幕上的显示的实际宽度取决于最大值及visibleAmount的值。</li>
<li>value：表示滚动条当前的值。</li>
<li>blockIncrement（块增量）：是用户点击滚动条的块增加（减少）区时所增加（减少）的值。</li>
<li>unitIncrement（单位增量）：用户点击单位增加（减少）区所增加（减少）的值。</li>
<li>**滚动条上的宽度对应于<code>maximum+visibleAmount</code>。当滚动条设为最大值时，滚动块的左端在maximum处，右端在maximum+visibleAmount处。</li>
</ul>
</li>
<li>用户改变滚动条的值时，滚动条产生AdjustmentEvent的一个实例。</li>
<li>可以使用构造方法或者使用<code>setOrientation</code>方法来指定滚动条的方向。默认情况下，属性maximum的值为100，minimum为0，blockIncrement为10，visibleAmount为10。</li>
</ul>
<h3 id="滑动块（JSlider）">滑动块（JSlider）</h3><ul>
<li>JSlider与JScrollBar类似，但是JSlider具有更多的属性和更多的显示形式。</li>
<li>JSlider允许用户以图形方式在指定的区间中选择一个数值。滑动块可以在主标记以及次标记之间滑动。标记间的像素值是由<code>setMajorTickSpacing</code>和<code>setMinorTickSpacing</code>方法控制的。</li>
<li>Slider可以带或不带标记，可以有或没有标签，可以水平显示或垂直显示。</li>
<li>垂直滚动条的值从上向下增加，但是垂直滑动块的值从上向下减少。</li>
<li>改变滑动块的值时，滑动块产生javax.swing.event.ChangeEvent的一个实例。</li>
</ul>
<h3 id="创建多个窗口">创建多个窗口</h3><p>新开的窗口叫做<code>子窗口（subwindow）</code>，主框架叫<code>主窗口（main window）</code>。</p>
<ul>
<li>从应用程序创建一个子窗口，需要创建JFrame的一个子类，用于定义任务和通知新窗口做什么。然后，在程序中创建该子类的一个实例，通过把它设为可见的即可弹出新窗口。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>可以在任何Swing组件使用边框，边框和图标都可以共享。</li>
<li>AbstractButton类中的常量LEFT、RIGHT……也可以被许多其他Swing组件使用。由于所有的Swing组件都实现了SwingConstants，因此各种组件都可以通过SwingConstants引用这些常量。因此<code>JButton.CENTER和SwingConstants.CENTER</code>作用是一样的。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题13.1 13.4 13.5 13.8 13.10 13.14 13.15源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter13/src" target="_blank" rel="external">chapter13</a></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章综合第十一、十二章的内容，介绍GUI编程中常用的组件]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十二章 事件驱动程序]]></title>
    <link href="http://www.whtis.com/2016/02/09/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.whtis.com/2016/02/09/Java学习总结-第十二章-事件驱动程序/</id>
    <published>2016-02-09T15:19:47.000Z</published>
    <updated>2016-09-14T15:49:10.780Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>所有非GUI程序都是按过程的顺序执行的，Java GUI程序设计是事件驱动的。本章介绍有关Java<code>事件驱动程序（event-driven programming）</code>的概念和技术。</p>
<h3 id="事件和事件源">事件和事件源</h3><ul>
<li><code>事件（event）</code>：程序发生的某些事情的信号。如：移动鼠标、点击鼠标、按照键盘键等。</li>
<li>事件<code>源对象（source object）</code>：某组件上发生了事件，该组件就被称为源对象。</li>
<li>一个事件是事件类的实例，事件类的根类是java.util.EventObject。可以使用该类中的<code>getSource()</code>方法获得事件源对象。</li>
<li>如果一个组件能够发生某个事件，那么这个组件的任何子类都能够发生同样的事件。如Component类是所有GUI类的父类，因此所有GUI组件都可以发生<code>MouseEvent</code>、<code>keyEvent</code>、<code>FocusEvent</code>和<code>ComponentEvent</code>事件。<br><img src="Event事件类.jpg" alt="Event事件类.jpg"></li>
</ul>
<h3 id="事件的监听、注册和处理">事件的监听、注册和处理</h3><ul>
<li>Java使用事件委托处理模型来处理事件：在源对象的外部用户行为触发事件，关心该事件的对象接收事件，后一个对象称为<code>监听器（listener）</code>。</li>
<li>一个对象要成为源对象上事件的监听器，需要具备两个条件：<ul>
<li>监听器对象的类必须实现相应的事件监听接口（xListener）。监听器接口包含处理事件的方法，这种方法称为<code>处理器（handler）</code>。</li>
<li>监听对象必须由源对象注册。注册方法依据事件的类型而定。一个源对象拥有一个监听器列表，通过调用监听器对象上的处理器，通知所有的已注册监听器对事件做出响应。</li>
</ul>
</li>
</ul>
<h3 id="鼠标事件">鼠标事件</h3><p>在一个组件上按下、释放、点击、移动、拖动鼠标时就会产生鼠标事件。鼠标的事件对象捕获事件。</p>
<ul>
<li>Java提供了两个处理鼠标事件的监听器接口<code>MouseListener</code>和<code>MouseMotionListener</code>。前者监听鼠标的按下、释放、移入、移出或点击等行为，后者监听鼠标的拖动和移动等行为。</li>
<li>java.awt.Point类封装平面上一个点的信息。可以用该类辅助处理鼠标事件。</li>
<li>MouseEvent类继承自InputEvent类。</li>
</ul>
<h3 id="键盘事件">键盘事件</h3><ul>
<li>键盘事件中捕获的键都是表示字符统一码的整数，包括字母与数字键、功能键、Tab键和回车键等。它们可以分别由<code>getKeyChar()</code>和<code>getKeyCode()</code>方法获得。</li>
<li>当击打一个统一码字符键时，就会调用<code>KeyTyped</code>处理器。<br><strong>仅有一个焦点组件能够接收KeyEvent、要使一个组件成为焦点组件，需要将属性isFocusable设置为true。</strong></li>
</ul>
<h3 id="定时器类Timer">定时器类Timer</h3><p>定时器类java.swing.Timer就是一个按照预定频率触发ActionEvent事件的源组件，它不是GUI组件。<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Timer</span>(delay, actionEvent).start();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>在事件处理中，忘记注册监听器是一个常见的错误。如果源对象没法通知监听器，监听器就不能响应事件。</li>
<li>如果一个监听器被源对象注册两次，当事件发生时，监听器的处理方法将会被调用两次。</li>
<li>源对象和监听器对象可能是相同的对象。（同一个类）</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li><p>习题12.7：<br>本题的难点在于所画的线需要从框架的中心开始。由于setvisible()方法才会调用paint()方法画图，在此之前，无论是JFrame还是JPanel，使用getWidth()和getHeight()方法得到的值都为0，因此需要想办法在框架画出来之后设置起始点的坐标。方法有两种：</p>
<ul>
<li><p>方法一：监听键盘事件的方法中，使用除功能键以外的键进行初始化设置，此方法不提倡；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keyPressed</span><span class="params">(KeyEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (e.getKeyCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.VK_UP:</span><br><span class="line">                y -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.VK_DOWN:</span><br><span class="line">                y += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.VK_LEFT:</span><br><span class="line">                x -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.VK_RIGHT:</span><br><span class="line">                x += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//            default:</span></span><br><span class="line"><span class="comment">//                x = this.getWidth() / 2;</span></span><br><span class="line"><span class="comment">//                y = this.getHeight() / 2;</span></span><br><span class="line"><span class="comment">//                lineStart.move(x,y);</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：添加窗口监听事件，这样就能确保在最开始将坐标设置好。由于JPanel是不可见的，无法实现WindowListener接口，因此在JFrame实现该接口，并在相应的方法中传入正确的框架中心坐标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $12<span class="title">_7</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">WindowListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> $<span class="number">12_7</span>() <span class="keyword">throws</span> HeadlessException &#123;</span><br><span class="line">      <span class="keyword">this</span>.addWindowListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">      PaintPanel p = <span class="keyword">new</span> PaintPanel(<span class="keyword">this</span>.getWidth() / <span class="number">2</span>, <span class="keyword">this</span>.getHeight() / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">this</span>.getContentPane().add(p);</span><br><span class="line">      p.setFocusable(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>习题12.3 12.4 12.5 12.6 12.7 12.8源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter12/src" target="_blank" rel="external">chapter12</a></p>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>所有非GUI程序都是按过程的顺序执行的，Java GUI]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第十一章 图形用户界面程序设计]]></title>
    <link href="http://www.whtis.com/2016/02/05/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.whtis.com/2016/02/05/Java学习总结-第十一章-图形用户界面程序设计/</id>
    <published>2016-02-05T14:17:17.000Z</published>
    <updated>2016-09-14T15:48:26.709Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍Java GUI程序设计基础。讨论GUI组件以及它们的关系，介绍容器和布局管理器、颜色、字体、以及几何图形的绘制。</p>
<h3 id="GUI组件">GUI组件</h3><ul>
<li><code>重型组件(heavyweight component)</code>：<code>抽象窗口组件(Abstract Window Tookit,AWT)</code>称为重型组件，因为它基于同位体的解决方案非常依赖底层平台。AWT的组件通过它们各自的代理映射成平台特性（platform-specific）的组件，这些代理称为<code>同位体(peer)</code>。</li>
<li><code>轻型组件(lightweight component)</code>：不依赖本地GUI的<code>Swing组件库(Swing components)</code>中的组件称为轻型组件，Swing组件更少地依赖目标机器上的平台，更少使用本地的GUI资源。</li>
<li>大多数Swing组件都是直接用Java代码绘制的，而java.awt.Window或java.awt.panel子类的组件例外，它们必须使用具体平台上的本地GUI来绘制。</li>
<li>为了区别Swing组件和AWT组件，Swing GUI组件类的开头都有前缀字母J。</li>
</ul>
<h3 id="Java_GUI_API">Java GUI API</h3><p><img src="GUI程序设计类层次图.jpg" alt="Java GUI程序设计类层次图"><br>为开发GUI程序所做的Java API设计是应用类、继承性和接口的一个优秀范例。GUI类的分类如下：</p>
<ul>
<li><code>容器类(container class)</code>：如JFrame、Jpanel和Japplet等，用来包含其他组件。<ul>
<li>Container用来组织组件。根据要求的位置和格式，布局管理器把组件定位放置到容器上。框架、面板和applet都是容器的例子。</li>
<li>JFrame是不能包含在其他窗口内的窗口。在Java GUI应用程序中，它是包含其他Swing用户界面组件的容器。</li>
<li>JDialog是一个弹出式信息窗口。一般用作接收用户附加信息或公告事件发生通知的临时窗口。</li>
<li>JApplet是Applet的一个子类。要创建基于Swing的Java Applet必须扩展JApplet。</li>
<li>Jpanel是一个存放用户界面组件的不可见容器。面板可以嵌套，可以把面板放在包含面板的容器中。Jpanel也可以作为画布来画图。</li>
</ul>
</li>
<li><code>辅助类(helper class)</code>：如Graphics、Color、Font、FontMetrics和Dimension等，是组件和容器用来绘制和放置对象的。它们都不是Component的子类。<ul>
<li>Graphics是一个抽象类，它提供一个图形环境，用于绘制字符串、直线和简单几何图形。</li>
<li>Color类用来处理图形组件的颜色。</li>
<li>Font指定GUI组件上文本和图形的字体。</li>
<li>FontMetrics是一个用于获取字体属性的抽象类。</li>
<li>Dimension将组件的宽度和高度（精度为整数）封装在单个对象中。</li>
<li>LayoutManager是一个接口，它的实例指定组件在容器中的摆放方式。<br><strong>辅助类包含在java.awt包中。Swing组件不能取代AWT的全部类，只能替代AWT的GUI组件类，辅助类仍保持不变。</strong></li>
</ul>
</li>
<li><code>组件类(component)</code>：图形用户界面（GUI）组件类，如JButton、JTextField、JTextArea、JComboBox、JList、JRadioButton和JMenu等，都是JComponent类的子类。<br><strong>JFrame、Japplet、JDialog和JComponent类及其子类都组织在javax.swing中。</strong></li>
</ul>
<h3 id="框架JFrame">框架JFrame</h3><ul>
<li><p>创建框架</p>
<ul>
<li><p>方法一：使用JFrame的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JFrame frame = <span class="keyword">new</span> JFrame();</span><br><span class="line"><span class="comment">// JFrame frame = new JFrame(String title);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：扩展JFrame框架，创建自己的框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中，方法二较好，理由如下：<br>1、创建一个GUI应用程序就是要创建一个框架，所以扩展JFrame类来定义一个框架是很自然的。<br>2、如果需要的话，这个新类可以重复使用。</p>
</li>
<li>在框架中添加组件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.awt.Container container = frame.getContentPane();  <span class="comment">//返回框架的内容窗格</span></span><br><span class="line">container.add(xxx);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>组件是由内容窗格的布局管理器放置在框架上的，而内容窗格默认的布局管理器是将按钮放到中央。</strong></p>
<ul>
<li>框架居中<br>默认情况下，框架在屏幕的左上角显示。可以使用JFrame类中的setLocation（x，y）方法调整框架位置。要使框架居中，就要知道屏幕的宽和高，这可以由java.awt.Toolkit类得到：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();</span><br><span class="line"><span class="keyword">int</span> screenWidth = screenSize.width;</span><br><span class="line"><span class="keyword">int</span> screenHeight = screenSize.height;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>java.awt.Dimension类将组件的宽和高（精度为整数）封装在单个对象中。使用<code>getWidth()</code>和<code>getHeight()</code>方法获取组件的宽和高。</p>
<h3 id="布局管理器">布局管理器</h3><p>Java的布局管理器提供了一层抽象，自动把用户界面映射到所有的窗口系统。其它窗口系统一般使用<code>硬编码（hard-code）</code>的像素尺寸来安排用户界面组件。</p>
<ul>
<li>布局管理器是使用布局管理器类创建的，每一个布局管理器类都实现了LayoutManager接口。</li>
<li>使用<code>setLayout（layoutManager）</code>方法在容器中设置布局管理器。</li>
<li>布局管理器的种类：<ul>
<li>FlowLayout（流式布局管理器）：按照添加的顺序，由左到右将组件排列在容器中，放满一行时，就开始新的一行。<ul>
<li>可以使用常量来指定对齐方式：FlowLayout.RIGHT、FlowLayout.CENTER和FlowLayout.LEFT。</li>
<li>public FlowLayout（int align，int hGap，int vGap）根据指定的对齐方式、水平间距和垂直间距构造一个新的FlowLayout对象。间距是指组件之间用像素度量的距离。</li>
<li>public FlowLayout（int align）</li>
<li>public FlowLayout（）使用默认的构造方法创建，默认的对齐方式是居中，默认的水平间距和垂直间距都是5个像素。</li>
</ul>
</li>
<li>GridLayout（网格布局管理器）：根据构造方法定义的行数和列数，布局管理器GridLayout以网格（矩阵）的形式排列组件。<ul>
<li>public GridLayout（int rows,int columns,int hGap,int vGap）  </li>
<li>public GridLayout（int rows,int columns）组件在容器上的水平和垂直间距为0。  </li>
<li>public GridLayout（）创建的新的GridLayout对象只有一行。<br><strong>行数或列数可以为零，但不能两个同时为零。如果一个为零另一个不为零，则不为零的维数已经固定，为零的维数由布局管理器动态地决定。</strong></li>
</ul>
</li>
<li>BordLayout（板式布局管理器）：将窗口分为五部分：东区、南区、西区、北区和中央。由常量EAST、WEST、NORTH、SOUTH决定组件的位置。<ul>
<li>public BorderLayout（int hGap，int vGap）</li>
<li>public BorderLayout（） </li>
<li>组件根据它们最合适的尺寸和在容器中的位置来放置。可以随意扩展拉伸。<br><strong>在FlowLayout和GridLayout两个布局管理器中，组件添加到容器中的顺序是很重要的，它决定了组件在容器中的位置。</strong></li>
</ul>
</li>
</ul>
</li>
<li>布局管理器的属性<br>布局管理器的属性可以动态的改变。可以在创建后使用set方法改变其属性。</li>
<li>validate和doLayout方法<ul>
<li>每一时刻，一个容器只能有一个布局管理器。可以使用setLayout（aNewLayout）方法改变容器的布局管理器，然后使用validate()方法强迫容器根据新的布局管理器重新摆放其中的组件。</li>
<li>如果使用相同布局管理器但是改变了它的属性，需要使用doLayout（）方法强迫容器根据布局管理器的新属性对组件重新放置。</li>
</ul>
</li>
</ul>
<h3 id="颜色类Color">颜色类Color</h3><ul>
<li>颜色由红、绿、蓝三原色构成，每种原色的强度都用一个byte值表示，从0（最暗）到255（最亮）。这就是通常所说的<code>RGB模式(RGB model)</code>。</li>
<li>java将13种标准色定义为常量，可以使用常量设定颜色。自JDK 1.4开始，新常量均为大写。</li>
</ul>
<h3 id="字体类Font">字体类Font</h3><ul>
<li>使用java.awt.Font类来创建字体对象，并使用Component类中的setFont方法设置组件的字体。</li>
<li>public Font（String name，int style，int size）</li>
<li>可以使用系统上的其它字体创建字体对象。为了找到系统上的字体，需要使用`java.awt.GraphicsEnvironment类的静态方法getLocalGraphicsEnvironment（）类来创建它的一个实例。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GraphicsEnvironment e = GraphicsEnvironment.getLocalGraphicsEnvironment();</span><br><span class="line">String[] fontnames = e.getAvailableFontFamilyNames();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fontnames.length; i++) &#123;</span><br><span class="line">	System.out.println(fontnames[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用面板作子容器">使用面板作子容器</h3><ul>
<li>使用Java用户图形界面程序设计，可以将窗口分成几个面板，面板是分组放置用户界面组件的子容器。</li>
<li>面板不可见的，可以用作组织组件的小容器，以达到要求的布局效果。 </li>
</ul>
<h3 id="在面板上绘制图形">在面板上绘制图形</h3><p>要在面板上画图，需要创建一个由JPanel扩展的新类，并且覆盖paintComponent方法告知面板如何画图。虽然可以在框架或applet中使用paint方法直接画图，但是最好使用JPanel绘制字符串和图形并显示图像，用这种方法画图不会影响其他组件。</p>
<h3 id="利用FontMetrics类居中显示">利用FontMetrics类居中显示</h3><ul>
<li>FontMetrics类可以对特定字体的字符串测量出精确的宽度和高度。FontMetics可以度量如下属性：<ul>
<li>Leading 文本行之间的距离</li>
<li>Ascent 表示字符从基线到其顶端的高度</li>
<li>Descent 表示下降字符如j、y、g等从基线到底端的距离<br><img src="FontMetics类确定字体属性.jpg" alt="FontMetics类确定字体属性"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">paintComponent</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">	FontMetrics fm = g.getFontMetrics();</span><br><span class="line">	<span class="keyword">int</span> stringWidth = fm.stringWidth(<span class="string">"Welcome to Java"</span>);</span><br><span class="line">	<span class="keyword">int</span> stringAscent = fm.getAscent();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xCoordinate = getWidth/<span class="number">2</span> - stringWidth/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> yCoordinate = getHeight/<span class="number">2</span> + StringAscent/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>Java图形界面设计应该遵循的顺序：面板（JPanel）→容器（Container）→框架（JFrame）</li>
<li><del>面板中设置背景色似乎不起作用。（本章创建的JPanel子类MessagePanel不起作用，其它的起作用，原因未知）</del><ul>
<li>原因：MessagePanel类重写了paintComponent（）方法，该方法是JComponent类中的方法，但是写的时候错写成了paintComponents（）方法，该方法是Container类中的方法，因此设置字体时不起作用。</li>
</ul>
</li>
<li>java.awt.Component 是所有GUI组件的根类。</li>
<li>java.awt.Container 是所有容器类的根类。</li>
<li>java.awt.Dimension 是度量GUI组件尺寸的一个类。</li>
<li>默认情况下，JFrame的布局管理器是BorderLayout，JPanel的布局管理器是FlowLayout。</li>
<li>paintComponent()方法是Component类中的方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题11.4源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter11/src" target="_blank" rel="external">chapter11</a><br><em>本章画图题较多，用到的时候再回来复习具体的东东吧~</em></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍Java GUI程序设计基础。讨论GUI组件以及]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十五章 异常和断言]]></title>
    <link href="http://www.whtis.com/2016/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80/"/>
    <id>http://www.whtis.com/2016/01/30/Java学习总结-第十五章-异常和断言/</id>
    <published>2016-01-30T08:41:58.000Z</published>
    <updated>2016-09-14T15:49:17.604Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍应用异常处理来处理运行错误，以及应用断言来确保程序的正确性。</p>
<h3 id="异常和异常类型">异常和异常类型</h3><ul>
<li>运行会引起<code>异常（exception）</code>。异常是指程序运行中出现的时间，它中断正常的程序控制流。</li>
<li><code>异常处理（exception handing）</code>：Java给程序员提供的稳妥处理运行错误的功能。</li>
<li>异常类<ul>
<li>Java的异常是Throwable派生类的一个实例。        </li>
<li>通过扩展Throwable或它的子类，可以创建自己的异常类。</li>
<li>异常类可以分为三种主要类型：系统错误、异常和运行异常。<ul>
<li><code>系统错误（system error）</code>是由Java虚拟机抛出并在Error类中描述的。Error类描述内部的系统错误。此类错误程序员一般无法处理。（LinkageError、VirtualMachineError、AWTError）</li>
<li><code>异常（exception）</code>是由Exception类描述的。Exception类描述由程序和外部环境引起的错误，这些错误能通过程序捕获和处理。（classNotFoundException、RuntimeException、···）</li>
<li><code>运行异常（runtime exception）</code>是由RuntimeException类描述的。RuntimeException类描述编程错误，比如不合适的转换、访问一个越界数组或数值错误等。（ArithmeticException、NullPointerException、IndexOutOfBoundsException、···）</li>
</ul>
</li>
</ul>
</li>
<li>必检异常和免检异常<ul>
<li>RuntimeException、Error以及它们的子类都称为<code>免检异常（unchecked exception）</code>。所有其他异常都成为<code>必检异常（checked exception）</code>。</li>
<li>必检异常编译器会强制程序员检查并处理它们。免检异常反映程序设计中不可重获的逻辑错误。</li>
<li>Java语言不允许编写捕获或声明免检异常的代码。</li>
</ul>
</li>
</ul>
<h3 id="异常处理">异常处理</h3><p>Java的异常模型基于三种操作：<code>声明异常（declaring an exception）</code>、<code>抛出异常（throwing an exception）</code>和<code>捕获异常（catching an exception）</code>。</p>
<ul>
<li>声明异常：每个方法都必须说明它可能抛出的必检异常的类型。<ul>
<li>在Java中使用关键字<code>throws</code>声明异常，使用关键字<code>throw</code>抛出异常。</li>
</ul>
</li>
<li>抛出异常：程序检查到一个错误后，创建一个适当类型异常的实例并抛出它。<ul>
<li>一个方法总能抛出免检异常。</li>
</ul>
</li>
<li><p>捕获异常：使用<code>try-catch</code>语句块捕获并处理异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//some statments</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	<span class="comment">//do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理异常的代码称为<code>异常处理器（exception handler）</code>。寻找处理器的整个过程称为捕获异常。</li>
<li>如果try语句块中某条语句抛出了异常，Java就会跳过try语句块中剩下的语句，开始为该异常搜索异常处理器。从第一个到最后一个逐个检查catch语句，看是否有某个catch字句中的异常类实例与该异常的类型匹配。如果有，就将该异常对象赋值给所声明的变量，执行catch子句中的代码。如果没有发现异常处理器，Java退出这个方法，把异常传递给调用该方法的方法，继续同样的过程来查找处理器。如果在调用的方法链中找不到相应的处理器，程序终止并在监视器上输出错误信息。</li>
<li>一个异常对象包含有关异常的有价值信息，可以利用java.lang.Throwable类中的下列实例方法获取异常的信息：<ul>
<li>public String getMessage() 返回Throwable对象的详细信息</li>
<li>public String toString() 返回3个字符串合起来的串，它们分别是 1）异常类名的全称。2）“：”（一个冒号和空格）。3）getMessage()方法</li>
<li>public void printStackTrace() 在控制台输出Throwable对象及其踪迹信息</li>
</ul>
</li>
</ul>
</li>
<li>方法是按照线程执行的。如果一个线程发生异常没有得到处理，该线程中止，但是程序中的其他线程不受影响。</li>
</ul>
<h3 id="重新抛出异常">重新抛出异常</h3><ul>
<li>当一个方法出现异常是，如果没有捕获异常，该方法就会立即退出。如果方法在退出之前需要执行某些任务，应该在该方法中捕获异常，然后按如下结构将异常重新抛出，交给调用它的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	statements;</span><br><span class="line">&#125; <span class="keyword">catch</span>(TheException ex) &#123;</span><br><span class="line">	perform operations before exits;</span><br><span class="line">	<span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="finally子句">finally子句</h3><ul>
<li>有时，不论异常是否出现或者是否被捕获，都希望执行某些代码。可以使用如下结构实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	statements;</span><br><span class="line">&#125; <span class="keyword">catch</span> (TheException ex) &#123;</span><br><span class="line">	handling ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	finalStatements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>使用finally子句时可能会忽略catch子句。</strong></p>
<h3 id="何时使用异常">何时使用异常</h3><p>当必须处理不可预料的错误时应该使用try-catch语句块，不要用try-catch块处理简单的、可预料的情况。</p>
<h3 id="创建自己的异常类">创建自己的异常类</h3><p>可以通过扩展Exception类或其子类来创建自己的异常类。</p>
<h3 id="断言">断言</h3><p><code>断言（assertion）</code>是Java的一个语句，它允许对程序提出一个判断（假设）。断言包含一个布尔表达式，在程序运行中它应该是真。</p>
<ul>
<li>断言用于确保程序的正确性，避免逻辑错误。</li>
<li>声明断言：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> assertion;</span><br><span class="line">or</span><br><span class="line"><span class="keyword">assert</span> assertion:detailMessage;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中assertion是一个布尔表达式，detailMessage是一个基本类型值或一个对象值。</p>
<ul>
<li><p>运行带断言的程序</p>
<ul>
<li><p>默认情况下，断言在运行时不起作用。为使它们有效，使用开关<code>-enableassertions</code>或其缩写<code>-ea</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言可以有选择地激活，在类层次或包层次起作用或不起作用。使它不起作用的开关是<code>-disableassertions</code>,或其缩写<code>-da</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea:package1 -da:Class1 xxx</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="使用异常处理或断言">使用异常处理或断言</h3><ul>
<li>不应该使用断言代替异常处理。异常处理用于在程序运行期间处理非常环境，断言是要确保程序的正确性。</li>
<li>异常处理针对程序的健壮性，而断言涉及程序的正确性。</li>
<li>不要使用断言检测public方法的参数。传给public方法的有效参数被认为是方法合约的一部分。</li>
<li>使用断言进一步确认假设。这将加强对程序正确的的确认。</li>
<li>将断言放到没有缺省情况的switch语句中。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>从一个通用父类可以派生出多种异常类。如果一个catch子句可以捕获一个父类的异常对象，它就能捕获那个父类所有子类的异常对象。</li>
<li>在catch字句中指定异常的顺序是非常重要的。一般遵循从子类异常到父类异常的顺序。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题15.5源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter15/src" target="_blank" rel="external">chapter15</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍应用异常处理来处理运行错误，以及应用断言来确保程]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十章 面向对象建模]]></title>
    <link href="http://www.whtis.com/2016/01/29/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/"/>
    <id>http://www.whtis.com/2016/01/29/Java学习总结-第十章-面向对象建模/</id>
    <published>2016-01-29T10:48:33.000Z</published>
    <updated>2016-09-14T15:49:41.564Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章初步介绍使用面向对象的方法开发软件系统，学习类的设计原则。</p>
<h3 id="软件开发过程">软件开发过程</h3><ul>
<li>软件开发步骤：需求分析、系统分析、设计、实现、测试、发行应用和维护。</li>
</ul>
<h3 id="分析类之间的关系">分析类之间的关系</h3><ul>
<li><code>关联(association)</code>：是一种描述两个类之间行为的一般二元关系。</li>
<li>聚集和包容<ul>
<li><code>聚集(aggregation)</code>：是一种特殊的关联形式，表示两个类之间的所属关系。聚集模拟<code>具有（has-a）</code>关系。</li>
<li>如果一个对象被一个聚集对象所专有，它和聚集对象之间的关系就称为<code>包容（composition）</code>。</li>
</ul>
</li>
<li>继承<br><code>继承(inheritance)</code>模拟两个类之间“是”（is-a）的关系。<code>强是(strong is-a)</code>关系描述两个类之间的直接继承关系，可以用类的继承表示。<code>弱是(weak is-a)</code>关系描述一个类具有某种属性，可以用接口表示。</li>
</ul>
<h3 id="类的设计原则">类的设计原则</h3><ul>
<li>设计一个类<ul>
<li>一个类应该描述一个单一的实体，类的所有操作应该在逻辑上相互配合，支持一个共同的目标。</li>
<li>类经常是为了多种不同用户的使用而设计的。</li>
<li>类是为了可重用而设计的，用户可以在不同的组合、不同的顺序和不同的环境中联合使用类。</li>
<li>在可能的情况下，应该提供公用的无参构造方法，并且覆盖定义在Object类中的equals方法和toString方法。如果覆盖了equals方法，也应该覆盖hashcode方法。（原因是两个相等的对象必须拥有相等的散列码）</li>
<li>给类、数据域以及方法选择有意义的名字。建议将数据的声明置于构造方法之前，将构造方法置于方法之前。</li>
</ul>
</li>
<li>使用可见性修饰符public、protected和private<ul>
<li>一个类可以提供两种合约：对类的使用者和对类的扩展者。<ul>
<li>为了使用者，应该将数据域设为私有的（private），将访问器方法和修改器方法设为公有的（public）。</li>
<li>为了扩展者，应该将数据域和方法都设为保护的（protected）。扩展者的合约包含使用者的合约。</li>
</ul>
</li>
<li>类应该使用private修饰符隐藏其数据，以免用户直接访问它。</li>
</ul>
</li>
<li>使用静态修饰符static<br>一个属性如果被类中的所有实例所共享，它应该声明为静态的。</li>
<li>使用继承或包容<ul>
<li>继承与包容之间的区别就是“是”（is-a）关系与“具有”（has-a）关系之间的区别。</li>
<li>如果要求多态性，使用继承来设计。如果不需要关系多态性，包容设计会更好。因为对包容设计得类，类之间的依赖性要比使用继承设计的类弱一些。</li>
</ul>
</li>
<li><p>使用接口或抽象类</p>
<ul>
<li>接口和抽象类都能用于描述一般性的公有特征。强是关系使用类来模拟，弱是关系使用接口来模拟。</li>
<li>一个子类只能扩展一个父类，但是可以实现多个接口，所以接口比抽象类更灵活。</li>
<li>要将接口和抽象类的好处结合起来，可以创建一个接口和一个实现该接口的抽象类，这样的抽象类称为<code>便利类(convenience class)</code>。</li>
</ul>
<h3 id="用顺序图和状态图模拟动态行为">用顺序图和状态图模拟动态行为</h3><ul>
<li>UML图符仅仅用来描述类的属性和方法以及类之间的静态关系。</li>
<li>顺序图：通过刻画方法调用的时间顺序来描述对象之间的交互作用。<ul>
<li><strong>类角色（clss role）</strong>表示对象所起的作用，顺序图顶部的对象表示类角色。</li>
<li><strong>生命线（lifeline）</strong>表示在某段时间内对象是存在的，用对象引出的垂直虚线（点线）表示。</li>
<li><strong>激活（activation）</strong>表示对象执行一项操作所用的时间段，使用位于生命线上的窄矩形表示。</li>
<li><strong>方法调用（method invocation）</strong>表示对象之间的通信，用标有调用方法指令的水平箭头表示。<br><a href="">!顺序图示例</a></li>
</ul>
</li>
<li><code>状态图（statechart diagram）</code>用来描述对象的控制流。状态图包含下列元素：<ul>
<li>状态（state）表示对象在生存期内的状况，包括对象满足某些条件、执行某些操作或等待某些事件发生等。每个状态都有一个名字，用圆角矩形表示它们，初始状态例外，用实心小圆表示。</li>
<li>转移（transition）表示两个状态之间的关系，表示一个对象执行某些操作后从一种状态转变为另一种状态。用标有合适方法调用的实线箭头来表示转移。<br><a href="">!状态图示例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用Java_API在构架基础上编程">使用Java API在构架基础上编程</h3><ul>
<li><p>Java应用程序接口（Application Program Interface，API）由许多类和接口组成。<br>java.lang包含Java核心类，每个Java程序隐含地导入该包。<br>javax.swing包含用于开发Swing GUI程序的轻型图形用户界面组件。<br>java.util包含许多工具。如StringTokenizer、Data、Calendar和GregorianCalendar等。</p>
<hr>
</li>
</ul>
<h2 id="复习小结">复习小结</h2><ul>
<li><p>接口是一种特殊的类，因此接口也可以用来声明类型。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Comparable</span> tt = <span class="keyword">new</span> <span class="built_in">Comparable</span>() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            public <span class="built_in">int</span> compareTo(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>上述写法类似于内部类。</p>
</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li><p>习题10.1<br>  写成如下形式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> n = <span class="number">1</span>;</span><br><span class="line">        Rational sum = <span class="keyword">new</span> Rational();</span><br><span class="line">        <span class="keyword">while</span> (n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            Rational r = <span class="keyword">new</span> Rational(n, n + <span class="number">1</span>);</span><br><span class="line">            sum = sum.add(r);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>当n增加到23时，sum=2292289173/118982864,再进行运算时，会出现除零错误，原因是分子的值超出了Integer类的最大值2147483647。因此最终得不到类似<code>分子/分母</code>形式的结果。如果在每次循环结束后，将sum转换成double类型，就可以得到最后double类型的结果了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> m = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">double</span> sum1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (m &lt; <span class="number">100</span>) &#123;</span><br><span class="line">          Rational r = <span class="keyword">new</span> Rational(m, m + <span class="number">1</span>);</span><br><span class="line">          sum1 += r.doubleValue();</span><br><span class="line">          m++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其余习题10.3 10.4源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter10/src" target="_blank" rel="external">chapter10</a></p>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章初步介绍使用面向对象的方法开发软件系统，学习类的设计]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第九章 抽象类和接口]]></title>
    <link href="http://www.whtis.com/2016/01/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.whtis.com/2016/01/28/Java学习总结-第九章-抽象类和接口/</id>
    <published>2016-01-28T09:03:02.000Z</published>
    <updated>2016-09-14T15:47:15.437Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>在继承的层次结构中，子类的出现使类变得越来越具体，而子类的父类就变得更一般、更通用。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类称为<code>抽象类（abstract class）</code>。<br>一个子类只能从一个父类继承，如果想要使其继承多个父类，可以使用<code>接口（interface）</code>来达到<code>多重继承（multiple inheritance）</code>的效果。<br>本章介绍抽象类和接口，并讨论如何使用基本数据类型值的包装类。</p>
<h3 id="抽象类">抽象类</h3><ul>
<li>抽象类使用关键字<code>abstract</code>修饰。</li>
<li>抽象类中可以存在抽象方法，抽象方法也使用关键字<code>abstract</code>修饰。</li>
<li>非抽象类不能包含抽象方法，在一个由抽象类扩展出来的非抽象类中，所有抽象方法都必须实现。</li>
<li>抽象类不能用new运算符实例化，但仍然可以定义它的构造方法。</li>
<li>包含抽象方法的类必须是抽象的，但抽象类中可以存在非抽象方法。</li>
<li>子类可以声明为抽象的，即使他的父类是具体的。</li>
<li>不能用new运算符创建抽象类的实例，但是，抽象类可以用作数据类型。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GeometricObject[] geo = <span class="keyword">new</span> GeometricObject[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="日历类Calendar和公历类GregorianCalendar">日历类Calendar和公历类GregorianCalendar</h3><p>略。</p>
<h3 id="接口">接口</h3><ul>
<li><code>接口(interface)</code>是一种与类相似的结构，只包含常量和抽象方法。抽象类和接口相似，但是抽象类处理包含常量和抽象方法外，还可以包含变量和具体方法。</li>
<li>使用关键字<code>implements</code>可以实现接口。</li>
<li>接口与抽象类<ul>
<li>在接口中，数据必须是常量，而抽象类可以有非常量的数据域。</li>
<li>接口中的每个方法只有一个头标志，没有实现部分，抽象类可以有具体的方法。<br><strong>在接口中，所有的数据域都是public final static的，所有的方法都是public abstract的，在书写接口时可以省略这部分内容。</strong></li>
<li>一个接口只能扩展其他接口，不能扩展类。一个类可以扩展它的父类并实现多个接口。</li>
</ul>
</li>
<li>抽象类和接口都可以用来模拟共同特征。<ul>
<li><code>强是关系(Strong is-a relationship)</code>：明显地描述了父子关系应该使用类模拟。</li>
<li><code>弱是关系(Weak is-a relationship)</code>：也叫<code>类属关系（is-kind of relationship）</code>，是指对象拥有某种属性。用接口来模拟。</li>
</ul>
</li>
<li><p>可克隆接口Cloneable</p>
<ul>
<li><p>Cloneable接口在java.lang包中如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>体为空的接口称为<code>标记接口（marker interface）</code>。标记接口不包含常量或方法，它用于标明一个类具有某种必备的属性。</p>
</li>
</ul>
</li>
<li>浅复制和深复制<ul>
<li><code>浅复制(shallow copy)</code>：如果域是一个对象，复制的是域的引用而不是域的内容。</li>
<li><code>深复制(deep copy)</code>: 复制域的内容。需要重写clone()方法。</li>
</ul>
</li>
</ul>
<h3 id="将基本数据类型值处理为对象">将基本数据类型值处理为对象</h3><ul>
<li>在Java中，基本类型不作为对象使用，这样做是效率原因。同时，Java也将基本数据类型并入对象或包装成对象，方便使用。对应的类称为<code>包装类（wrapper class）</code>。使用包装对象代替基本类型变量，可以进行一般程序设计。</li>
<li>包装类的名称与对应的基本类型一样，但是第一个字母大写。Integer和Character例外。</li>
<li>包装类没有无参构造方法；所有包装类的实例都是永久的。</li>
<li>数值包装类的常量<ul>
<li>MAX_VALUE</li>
<li>MIN_VALUE</li>
</ul>
</li>
<li>静态方法<code>valueOf()</code>创建一个新的对象，并将它初始化为指定字符串表示的值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double doubleObject = Double.valueOf(<span class="string">"12.4"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基本类型和包装类之间的自动转换">基本类型和包装类之间的自动转换</h3><ul>
<li>二者自JDK 1.5就可以自动转换。</li>
<li>将基本类型的值转换为包装类对象，称为<code>装箱（boxing）</code>，相反的过程称为<code>开箱（unboxing）</code>。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>接口仅定义了规范，实现接口的好处有：<br>1、表示多个实现类之间的弱是关系<br>2、接口可以同一标准<br>3、接口可以快速分离工作内容<br>4、接口有利于程序扩展</li>
<li>实现接口，必须实现接口中所有的方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题9.1 9.2 9.3 9.4 9.6 9.8 9.9 9.10程序源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter9/src" target="_blank" rel="external">chapter9</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>在继承的层次结构中，子类的出现使类变得越来越具体，而子类]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
</feed>
