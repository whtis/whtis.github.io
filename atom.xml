<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[whtis's blog]]></title>
  <subtitle><![CDATA[点滴的记录，是变强的必经之路]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.whtis.com/"/>
  <updated>2016-01-31T12:17:44.810Z</updated>
  <id>http://www.whtis.com/</id>
  
  <author>
    <name><![CDATA[whtis]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java学习总结--第十五章 异常和断言]]></title>
    <link href="http://www.whtis.com/2016/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80/"/>
    <id>http://www.whtis.com/2016/01/30/Java学习总结-第十五章-异常和断言/</id>
    <published>2016-01-30T08:41:58.000Z</published>
    <updated>2016-01-31T12:17:44.810Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍应用异常处理来处理运行错误，以及应用断言来确保程序的正确性。</p>
<h3 id="异常和异常类型">异常和异常类型</h3><ul>
<li>运行会引起<code>异常（exception）</code>。异常是指程序运行中出现的时间，它中断正常的程序控制流。</li>
<li><code>异常处理（exception handing）</code>：Java给程序员提供的稳妥处理运行错误的功能。</li>
<li>异常类<ul>
<li>Java的异常是Throwable派生类的一个实例。        </li>
<li>通过扩展Throwable或它的子类，可以创建自己的异常类。</li>
<li>异常类可以分为三种主要类型：系统错误、异常和运行异常。<ul>
<li><code>系统错误（system error）</code>是由Java虚拟机抛出并在Error类中描述的。Error类描述内部的系统错误。此类错误程序员一般无法处理。（LinkageError、VirtualMachineError、AWTError）</li>
<li><code>异常（exception）</code>是由Exception类描述的。Exception类描述由程序和外部环境引起的错误，这些错误能通过程序捕获和处理。（classNotFoundException、RuntimeException、···）</li>
<li><code>运行异常（runtime exception）</code>是由RuntimeException类描述的。RuntimeException类描述编程错误，比如不合适的转换、访问一个越界数组或数值错误等。（ArithmeticException、NullPointerException、IndexOutOfBoundsException、···）</li>
</ul>
</li>
</ul>
</li>
<li>必检异常和免检异常<ul>
<li>RuntimeException、Error以及它们的子类都称为<code>免检异常（unchecked exception）</code>。所有其他异常都成为<code>必检异常（checked exception）</code>。</li>
<li>必检异常编译器会强制程序员检查并处理它们。免检异常反映程序设计中不可重获的逻辑错误。</li>
<li>Java语言不允许编写捕获或声明免检异常的代码。</li>
</ul>
</li>
</ul>
<h3 id="异常处理">异常处理</h3><p>Java的异常模型基于三种操作：<code>声明异常（declaring an exception）</code>、<code>抛出异常（throwing an exception）</code>和<code>捕获异常（catching an exception）</code>。</p>
<ul>
<li>声明异常：每个方法都必须说明它可能抛出的必检异常的类型。<ul>
<li>在Java中使用关键字<code>throws</code>声明异常，使用关键字<code>throw</code>抛出异常。</li>
</ul>
</li>
<li>抛出异常：程序检查到一个错误后，创建一个适当类型异常的实例并抛出它。<ul>
<li>一个方法总能抛出免检异常。</li>
</ul>
</li>
<li><p>捕获异常：使用<code>try-catch</code>语句块捕获并处理异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//some statments</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	<span class="comment">//do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理异常的代码称为<code>异常处理器（exception handler）</code>。寻找处理器的整个过程称为捕获异常。</li>
<li>如果try语句块中某条语句抛出了异常，Java就会跳过try语句块中剩下的语句，开始为该异常搜索异常处理器。从第一个到最后一个逐个检查catch语句，看是否有某个catch字句中的异常类实例与该异常的类型匹配。如果有，就将该异常对象赋值给所声明的变量，执行catch子句中的代码。如果没有发现异常处理器，Java退出这个方法，把异常传递给调用该方法的方法，继续同样的过程来查找处理器。如果在调用的方法链中找不到相应的处理器，程序终止并在监视器上输出错误信息。</li>
<li>一个异常对象包含有关异常的有价值信息，可以利用java.lang.Throwable类中的下列实例方法获取异常的信息：<ul>
<li>public String getMessage() 返回Throwable对象的详细信息</li>
<li>public String toString() 返回3个字符串合起来的串，它们分别是 1）异常类名的全称。2）“：”（一个冒号和空格）。3）getMessage()方法</li>
<li>public void printStackTrace() 在控制台输出Throwable对象及其踪迹信息</li>
</ul>
</li>
</ul>
</li>
<li>方法是按照线程执行的。如果一个线程发生异常没有得到处理，该线程中止，但是程序中的其他线程不受影响。</li>
</ul>
<h3 id="重新抛出异常">重新抛出异常</h3><ul>
<li>当一个方法出现异常是，如果没有捕获异常，该方法就会立即退出。如果方法在退出之前需要执行某些任务，应该在该方法中捕获异常，然后按如下结构将异常重新抛出，交给调用它的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	statements;</span><br><span class="line">&#125; <span class="keyword">catch</span>(TheException ex) &#123;</span><br><span class="line">	perform operations before exits;</span><br><span class="line">	<span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="finally子句">finally子句</h3><ul>
<li>有时，不论异常是否出现或者是否被捕获，都希望执行某些代码。可以使用如下结构实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	statements;</span><br><span class="line">&#125; <span class="keyword">catch</span> (TheException ex) &#123;</span><br><span class="line">	handling ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	finalStatements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>使用finally子句时可能会忽略catch子句。</strong></p>
<h3 id="何时使用异常">何时使用异常</h3><p>当必须处理不可预料的错误时应该使用try-catch语句块，不要用try-catch块处理简单的、可预料的情况。</p>
<h3 id="创建自己的异常类">创建自己的异常类</h3><p>可以通过扩展Exception类或其子类来创建自己的异常类。</p>
<h3 id="断言">断言</h3><p><code>断言（assertion）</code>是Java的一个语句，它允许对程序提出一个判断（假设）。断言包含一个布尔表达式，在程序运行中它应该是真。</p>
<ul>
<li>断言用于确保程序的正确性，避免逻辑错误。</li>
<li>声明断言：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> assertion;</span><br><span class="line">or</span><br><span class="line"><span class="keyword">assert</span> assertion:detailMessage;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中assertion是一个布尔表达式，detailMessage是一个基本类型值或一个对象值。</p>
<ul>
<li><p>运行带断言的程序</p>
<ul>
<li><p>默认情况下，断言在运行时不起作用。为使它们有效，使用开关<code>-enableassertions</code>或其缩写<code>-ea</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言可以有选择地激活，在类层次或包层次起作用或不起作用。使它不起作用的开关是<code>-disableassertions</code>,或其缩写<code>-da</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea:package1 -da:Class1 xxx</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="使用异常处理或断言">使用异常处理或断言</h3><ul>
<li>不应该使用断言代替异常处理。异常处理用于在程序运行期间处理非常环境，断言是要确保程序的正确性。</li>
<li>异常处理针对程序的健壮性，而断言涉及程序的正确性。</li>
<li>不要使用断言检测public方法的参数。传给public方法的有效参数被认为是方法合约的一部分。</li>
<li>使用断言进一步确认假设。这将加强对程序正确的的确认。</li>
<li>将断言放到没有缺省情况的switch语句中。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>从一个通用父类可以派生出多种异常类。如果一个catch子句可以捕获一个父类的异常对象，它就能捕获那个父类所有子类的异常对象。</li>
<li>在catch字句中指定异常的顺序是非常重要的。一般遵循从子类异常到父类异常的顺序。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题15.5源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter15/src" target="_blank" rel="external">chapter15</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍应用异常处理来处理运行错误，以及应用断言来确保程]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第十章 面向对象建模]]></title>
    <link href="http://www.whtis.com/2016/01/29/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/"/>
    <id>http://www.whtis.com/2016/01/29/Java学习总结-第十章-面向对象建模/</id>
    <published>2016-01-29T10:48:33.000Z</published>
    <updated>2016-01-30T08:29:41.676Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章初步介绍使用面向对象的方法开发软件系统，学习类的设计原则。</p>
<h3 id="软件开发过程">软件开发过程</h3><ul>
<li>软件开发步骤：需求分析、系统分析、设计、实现、测试、发行应用和维护。</li>
</ul>
<h3 id="分析类之间的关系">分析类之间的关系</h3><ul>
<li><code>关联(association)</code>：是一种描述两个类之间行为的一般二元关系。</li>
<li>聚集和包容<ul>
<li><code>聚集(aggregation)</code>：是一种特殊的关联形式，表示两个类之间的所属关系。聚集模拟<code>具有（has-a）</code>关系。</li>
<li>如果一个对象被一个聚集对象所专有，它和聚集对象之间的关系就称为<code>包容（composition）</code>。</li>
</ul>
</li>
<li>继承<br><code>继承(inheritance)</code>模拟两个类之间“是”（is-a）的关系。<code>强是(strong is-a)</code>关系描述两个类之间的直接继承关系，可以用类的继承表示。<code>弱是(weak is-a)</code>关系描述一个类具有某种属性，可以用接口表示。</li>
</ul>
<h3 id="类的设计原则">类的设计原则</h3><ul>
<li>设计一个类<ul>
<li>一个类应该描述一个单一的实体，类的所有操作应该在逻辑上相互配合，支持一个共同的目标。</li>
<li>类经常是为了多种不同用户的使用而设计的。</li>
<li>类是为了可重用而设计的，用户可以在不同的组合、不同的顺序和不同的环境中联合使用类。</li>
<li>在可能的情况下，应该提供公用的无参构造方法，并且覆盖定义在Object类中的equals方法和toString方法。如果覆盖了equals方法，也应该覆盖hashcode方法。（原因是两个相等的对象必须拥有相等的散列码）</li>
<li>给类、数据域以及方法选择有意义的名字。建议将数据的声明置于构造方法之前，将构造方法置于方法之前。</li>
</ul>
</li>
<li>使用可见性修饰符public、protected和private<ul>
<li>一个类可以提供两种合约：对类的使用者和对类的扩展者。<ul>
<li>为了使用者，应该将数据域设为私有的（private），将访问器方法和修改器方法设为公有的（public）。</li>
<li>为了扩展者，应该将数据域和方法都设为保护的（protected）。扩展者的合约包含使用者的合约。</li>
</ul>
</li>
<li>类应该使用private修饰符隐藏其数据，以免用户直接访问它。</li>
</ul>
</li>
<li>使用静态修饰符static<br>一个属性如果被类中的所有实例所共享，它应该声明为静态的。</li>
<li>使用继承或包容<ul>
<li>继承与包容之间的区别就是“是”（is-a）关系与“具有”（has-a）关系之间的区别。</li>
<li>如果要求多态性，使用继承来设计。如果不需要关系多态性，包容设计会更好。因为对包容设计得类，类之间的依赖性要比使用继承设计的类弱一些。</li>
</ul>
</li>
<li><p>使用接口或抽象类</p>
<ul>
<li>接口和抽象类都能用于描述一般性的公有特征。强是关系使用类来模拟，弱是关系使用接口来模拟。</li>
<li>一个子类只能扩展一个父类，但是可以实现多个接口，所以接口比抽象类更灵活。</li>
<li>要将接口和抽象类的好处结合起来，可以创建一个接口和一个实现该接口的抽象类，这样的抽象类称为<code>便利类(convenience class)</code>。</li>
</ul>
<h3 id="用顺序图和状态图模拟动态行为">用顺序图和状态图模拟动态行为</h3><ul>
<li>UML图符仅仅用来描述类的属性和方法以及类之间的静态关系。</li>
<li>顺序图：通过刻画方法调用的时间顺序来描述对象之间的交互作用。<ul>
<li><strong>类角色（clss role）</strong>表示对象所起的作用，顺序图顶部的对象表示类角色。</li>
<li><strong>生命线（lifeline）</strong>表示在某段时间内对象是存在的，用对象引出的垂直虚线（点线）表示。</li>
<li><strong>激活（activation）</strong>表示对象执行一项操作所用的时间段，使用位于生命线上的窄矩形表示。</li>
<li><strong>方法调用（method invocation）</strong>表示对象之间的通信，用标有调用方法指令的水平箭头表示。<br><a href="">!顺序图示例</a></li>
</ul>
</li>
<li><code>状态图（statechart diagram）</code>用来描述对象的控制流。状态图包含下列元素：<ul>
<li>状态（state）表示对象在生存期内的状况，包括对象满足某些条件、执行某些操作或等待某些事件发生等。每个状态都有一个名字，用圆角矩形表示它们，初始状态例外，用实心小圆表示。</li>
<li>转移（transition）表示两个状态之间的关系，表示一个对象执行某些操作后从一种状态转变为另一种状态。用标有合适方法调用的实线箭头来表示转移。<br><a href="">!状态图示例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用Java_API在构架基础上编程">使用Java API在构架基础上编程</h3><ul>
<li><p>Java应用程序接口（Application Program Interface，API）由许多类和接口组成。<br>java.lang包含Java核心类，每个Java程序隐含地导入该包。<br>javax.swing包含用于开发Swing GUI程序的轻型图形用户界面组件。<br>java.util包含许多工具。如StringTokenizer、Data、Calendar和GregorianCalendar等。</p>
<hr>
</li>
</ul>
<h2 id="复习小结">复习小结</h2><ul>
<li><p>接口是一种特殊的类，因此接口也可以用来声明类型。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Comparable</span> tt = <span class="keyword">new</span> <span class="built_in">Comparable</span>() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            public <span class="built_in">int</span> compareTo(<span class="built_in">Object</span> o) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>上述写法类似于内部类。</p>
</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li><p>习题10.1<br>  写成如下形式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> n = <span class="number">1</span>;</span><br><span class="line">        Rational sum = <span class="keyword">new</span> Rational();</span><br><span class="line">        <span class="keyword">while</span> (n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            Rational r = <span class="keyword">new</span> Rational(n, n + <span class="number">1</span>);</span><br><span class="line">            sum = sum.add(r);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>当n增加到23时，sum=2292289173/118982864,再进行运算时，会出现除零错误，原因是分子的值超出了Integer类的最大值2147483647。因此最终得不到类似<code>分子/分母</code>形式的结果。如果在每次循环结束后，将sum转换成double类型，就可以得到最后double类型的结果了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> m = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">double</span> sum1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (m &lt; <span class="number">100</span>) &#123;</span><br><span class="line">          Rational r = <span class="keyword">new</span> Rational(m, m + <span class="number">1</span>);</span><br><span class="line">          sum1 += r.doubleValue();</span><br><span class="line">          m++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其余习题10.3 10.4源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter10/src" target="_blank" rel="external">chapter10</a></p>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章初步介绍使用面向对象的方法开发软件系统，学习类的设计]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第九章 抽象类和接口]]></title>
    <link href="http://www.whtis.com/2016/01/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.whtis.com/2016/01/28/Java学习总结-第九章-抽象类和接口/</id>
    <published>2016-01-28T09:03:02.000Z</published>
    <updated>2016-01-28T10:46:18.987Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>在继承的层次结构中，子类的出现使类变得越来越具体，而子类的父类就变得更一般、更通用。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类称为<code>抽象类（abstract class）</code>。<br>一个子类只能从一个父类继承，如果想要使其继承多个父类，可以使用<code>接口（interface）</code>来达到<code>多重继承（multiple inheritance）</code>的效果。<br>本章介绍抽象类和接口，并讨论如何使用基本数据类型值的包装类。</p>
<h3 id="抽象类">抽象类</h3><ul>
<li>抽象类使用关键字<code>abstract</code>修饰。</li>
<li>抽象类中可以存在抽象方法，抽象方法也使用关键字<code>abstract</code>修饰。</li>
<li>非抽象类不能包含抽象方法，在一个由抽象类扩展出来的非抽象类中，所有抽象方法都必须实现。</li>
<li>抽象类不能用new运算符实例化，但仍然可以定义它的构造方法。</li>
<li>包含抽象方法的类必须是抽象的，但抽象类中可以存在非抽象方法。</li>
<li>子类可以声明为抽象的，即使他的父类是具体的。</li>
<li>不能用new运算符创建抽象类的实例，但是，抽象类可以用作数据类型。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GeometricObject[] geo = <span class="keyword">new</span> GeometricObject[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="日历类Calendar和公历类GregorianCalendar">日历类Calendar和公历类GregorianCalendar</h3><p>略。</p>
<h3 id="接口">接口</h3><ul>
<li><code>接口(interface)</code>是一种与类相似的结构，只包含常量和抽象方法。抽象类和接口相似，但是抽象类处理包含常量和抽象方法外，还可以包含变量和具体方法。</li>
<li>使用关键字<code>implements</code>可以实现接口。</li>
<li>接口与抽象类<ul>
<li>在接口中，数据必须是常量，而抽象类可以有非常量的数据域。</li>
<li>接口中的每个方法只有一个头标志，没有实现部分，抽象类可以有具体的方法。<br><strong>在接口中，所有的数据域都是public final static的，所有的方法都是public abstract的，在书写接口时可以省略这部分内容。</strong></li>
<li>一个接口只能扩展其他接口，不能扩展类。一个类可以扩展它的父类并实现多个接口。</li>
</ul>
</li>
<li>抽象类和接口都可以用来模拟共同特征。<ul>
<li><code>强是关系(Strong is-a relationship)</code>：明显地描述了父子关系应该使用类模拟。</li>
<li><code>弱是关系(Weak is-a relationship)</code>：也叫<code>类属关系（is-kind of relationship）</code>，是指对象拥有某种属性。用接口来模拟。</li>
</ul>
</li>
<li><p>可克隆接口Cloneable</p>
<ul>
<li><p>Cloneable接口在java.lang包中如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>体为空的接口称为<code>标记接口（marker interface）</code>。标记接口不包含常量或方法，它用于标明一个类具有某种必备的属性。</p>
</li>
</ul>
</li>
<li>浅复制和深复制<ul>
<li><code>浅复制(shallow copy)</code>：如果域是一个对象，复制的是域的引用而不是域的内容。</li>
<li><code>深复制(deep copy)</code>: 复制域的内容。需要重写clone()方法。</li>
</ul>
</li>
</ul>
<h3 id="将基本数据类型值处理为对象">将基本数据类型值处理为对象</h3><ul>
<li>在Java中，基本类型不作为对象使用，这样做是效率原因。同时，Java也将基本数据类型并入对象或包装成对象，方便使用。对应的类称为<code>包装类（wrapper class）</code>。使用包装对象代替基本类型变量，可以进行一般程序设计。</li>
<li>包装类的名称与对应的基本类型一样，但是第一个字母大写。Integer和Character例外。</li>
<li>包装类没有无参构造方法；所有包装类的实例都是永久的。</li>
<li>数值包装类的常量<ul>
<li>MAX_VALUE</li>
<li>MIN_VALUE</li>
</ul>
</li>
<li>静态方法<code>valueOf()</code>创建一个新的对象，并将它初始化为指定字符串表示的值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double doubleObject = Double.valueOf(<span class="string">"12.4"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基本类型和包装类之间的自动转换">基本类型和包装类之间的自动转换</h3><ul>
<li>二者自JDK 1.5就可以自动转换。</li>
<li>将基本类型的值转换为包装类对象，称为<code>装箱（boxing）</code>，相反的过程称为<code>开箱（unboxing）</code>。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>接口仅定义了规范，实现接口的好处有：<br>1、表示多个实现类之间的弱是关系<br>2、接口可以同一标准<br>3、接口可以快速分离工作内容<br>4、接口有利于程序扩展</li>
<li>实现接口，必须实现接口中所有的方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题9.1 9.2 9.3 9.4 9.6 9.8 9.9 9.10程序源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter9/src" target="_blank" rel="external">chapter9</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>在继承的层次结构中，子类的出现使类变得越来越具体，而子类]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第八章 继承和多态]]></title>
    <link href="http://www.whtis.com/2016/01/27/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://www.whtis.com/2016/01/27/Java学习总结-第八章-继承和多态/</id>
    <published>2016-01-27T13:17:29.000Z</published>
    <updated>2016-01-28T10:44:49.901Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>在面向对象程序设计中，可以由已有的类派生出子类，这叫做<code>继承（inheritance）</code>。<br>本章介绍继承的概念。着重理解父类和子类、关键字super的用法以及object类，了解多态和动态绑定、一般程序设计以及对象转换，介绍修饰符protect和final。</p>
<h3 id="父类和子类">父类和子类</h3><ul>
<li>在面向对象程序设计中，从另一个类C2中派生的类C1称为<code>次类(subclass)</code>,C2则称为<code>超类(superclass)</code>。超类又称为<code>父类(parent class)</code>或<code>基类(base class)</code>,次类又称为<code>子类(child class)</code>、<code>扩展类(extend class)</code>或<code>派生类(derived class)</code>。子类从它的父类中继承可访问的数据域和方法，也可以添加新数据域和方法。</li>
</ul>
<h3 id="关键字super">关键字super</h3><ul>
<li>调用父类的构造方法<ul>
<li>super(); 或super(参数);</li>
<li>以上语句必须出现在子类构造方法的第一行，这也是调用父类构造方法的唯一方式。</li>
<li>构造方法链(constructor chaining)：在任何情况下，构造一个类的实例时，将会沿着继承链调用所有父类的构造方法，这叫做<code>构造方法链</code>。</li>
</ul>
</li>
<li>调用父类的方法<ul>
<li>super.方法名(参数);</li>
</ul>
</li>
</ul>
<h3 id="方法覆盖">方法覆盖</h3><ul>
<li>有时候子类需要修改父类中定义的方法，这叫做<code>方法覆盖(method overriding)</code>。<ul>
<li>为了覆盖方法，子类定义的方法必须与父类方法具有相同的头标志和相同的返回值类型。（使用ctrl+c、ctrl+v）</li>
<li>实例方法仅当可访问时才能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系。</li>
<li>静态方法也能继承，但不能被覆盖。如果父类中定义的静态方法在子类中重新定义，父类的方法将被隐藏。</li>
</ul>
</li>
</ul>
<h3 id="对象类Object">对象类Object</h3><ul>
<li>Java中的每个类都源于java.lang.Object类。如果一个类在定义时没有指定继承谁，它的父类就是Object。</li>
<li><p>Object类的常用实例方法</p>
<ul>
<li>equals()方法：检验两个对象是否相等。其默认实现为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由此可知，Object类中的equals()方法相当于使用==运算符。因此，Object类的子类很有必要修改equals方法，以便检验两个不同的对象是否具有相同的内容。</p>
<ul>
<li>hashCode()方法：调用对象的hashCode()方法返回该对象的哈希代码。<ul>
<li><code>哈希码（hash code）</code>是一个整数，用于在混杂集合中存储并能快速查找对象。</li>
<li>编写代码时，如果两个对象相等，它们的哈希码一定相同。两个不同的对象也可能具有相同的哈希码。</li>
<li>在程序一次运行期间，多次调用hashCode方法应该返回相同的整数，对不同的运行可以返回不同的整数。</li>
</ul>
</li>
<li>toString()方法：返回一个代表该对象的字符串。默认情况下，返回一个由该对象所属的类名、at符号（@）和该对象十六进制的哈希码组成的字符串。</li>
</ul>
</li>
</ul>
<h3 id="多态性、动态绑定和一般程序设计">多态性、动态绑定和一般程序设计</h3><ul>
<li>继承关系使一个子类继承父类的特征，并可以附加一些自己的新特征。子类是父类的某种专门化，每一个子类的实例都是父类的实例。因此对于需要父类类型的参数，总可以传入子类的实例。</li>
<li>为父类对象设计的任何形式的代码都可以应用于子类，这个特征称为<code>多态性（polymorphism）</code>。</li>
<li><code>动态绑定（dynamic binding）</code>：代码提供多种实现，采用哪一种实现由Java虚拟机在运行时动态决定。<ul>
<li>动态绑定工作机制如下： //todo</li>
</ul>
</li>
<li>多态性一般允许方法使用范围更广的对象参数，这称为<code>一般程序设计（generic programming）</code>。</li>
</ul>
<h3 id="对象类型转换和instanceof运算符">对象类型转换和instanceof运算符</h3><ul>
<li>转换可以把一个类的对象转换为继承链中的另一个对象。</li>
<li><p><code>隐式类型转换（implicit casting）</code>：子类的实例永远是父类的实例，因此可以将一个子类的实例转换为父类的一个变量。这称为<code>向上转换（upcasting）</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fruit f = <span class="keyword">new</span> apple();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>显式类型转换（explicit casting）</code>：父类对象不一定是子类的实例，因此转换需要显式的告诉编译器转换的类型。把父类的实例转换成它的子类变量，这称为<code>向下转换（downcasting）</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apple a = (Apple)f;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了确保显式转换能成功，可以用运算符instanceof来判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f <span class="keyword">instanceof</span> Apple) &#123;</span><br><span class="line">	Apple a = (Apple)f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了能够进行一般程序设计，一个好的做法是把变量声明为父类类型，这样它可以接收任何子类类型的值。</p>
</li>
</ul>
<h3 id="隐藏数据域和静态方法">隐藏数据域和静态方法</h3><ul>
<li>可以覆盖一个实例方法，但不能覆盖一个数据域（实例或静态的）或静态方法。如果在子类中声明的数据域或静态方法与父类中的名字相同，父类中的将被隐藏，但是它依然存在。在子类中可以使用关键字super调用隐藏的数据域或静态方法，隐藏的域或方法也可以通过父类类型的引用变量来访问。</li>
<li>使用引用变量调用实例方法时，变量所引用对象的实际类在运行时决定使用该方法的哪个实现。访问数据域或静态方法是，引用变量所声明的类型在编译时决定使用哪个数据域或静态方法。</li>
</ul>
<h3 id="protected数据和方法">protected数据和方法</h3><ul>
<li>保护的（protected）修饰符可以应用于类中的数据和方法。公用类中保护的数据或方法可以被<code>它的子类或同一包中的任何类</code>访问，即使子类在不同的包中也可以。</li>
<li>使用可见性修饰符<br>修饰符private、protected、public称为<code>可见性修饰符（visibility modifier）</code>或<code>访问性修饰符（accessible modifier）</code>，因为他们指定类和类的成员如何被访问。这些修饰符的可见性按下面的顺序递增：<pre><code>               可见性逐渐增加
         -------------------------→
<span class="keyword">private</span>，空（如果没有修饰符），<span class="keyword">protected</span>，<span class="keyword">public</span>
</code></pre></li>
</ul>
<h3 id="final类、方法和变量">final类、方法和变量</h3><ul>
<li>用final修饰符说明一个类是终极的（final），不能做父类。例如：Math类。</li>
<li>也可以把方法定义为终极的，终极方法不能被它的子类覆盖。<br><strong>方法内的终极局部变量就是常量。</strong></li>
</ul>
<h3 id="finalize、clone和getclass方法">finalize、clone和getclass方法</h3><ul>
<li><p>finalize()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当一个对象变成垃圾时，finalize方法会被该对象的垃圾回收程序调用。</li>
<li>默认情况下，finalize方法不做任何事。如果必要，子类应该覆盖finalize方法，释放系统资源或进行其他清洁工作。<br><strong>finalize方法是有Java虚拟机调用的，在自己的程序中不要书写任何调用该方法的代码。</strong></li>
</ul>
</li>
<li>clone方法<ul>
<li>要创建一个有单独内存空间的新对象，使用clone()方法。</li>
<li>不是所有对象都可以被克隆。要成为一个可克隆的对象，它的类必须实现java.lang.Cloneable接口。</li>
</ul>
</li>
<li>getClass方法<ul>
<li>一个类在使用时必须先装入。Java虚拟机装入类是，创建一个包含类信息的对象，这些信息有类名、构造方法和方法等。这个对象是java.lang.Class的一个实例，因为它描述有关类的信息，称它为<code>元对象（meta-object）</code>。每个对象都可以使用getClass()方法返回它的元对象。</li>
<li>一个类只有一个元对象。每个对象都有一个元对象，如果两个对象是从同一个类创建的，那么它们的元对象相同。</li>
</ul>
</li>
</ul>
<h3 id="初始化模块">初始化模块</h3><ul>
<li><code>初始化模块（initialization block）</code>：是一个用大括号括住的语句块，它位于类的声明中，但是不在方法或构造方法内。它的作用就像把它放在了类中每个构造方法最开始的位置。</li>
<li>一个类可以有多个初始化模块。在这种情况下，模块按照它们在类中出现的顺序执行。</li>
<li>初始化模块分为<code>实例初始化模块（instance initialization block）</code>和<code>静态初始化模块（static initialization block）</code>。</li>
<li>包含初始化模块的程序的执行顺序如下：<br>1、类装载：静态数据域，静态初始化模块<br>2、类创建：构造方法，实例数据域，实例初始化模块<br>3、类运行：实例方法体</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>子类不是父类的自给，子类可以在父类的基础上进行扩展。</li>
<li>如果一个类设计成子类，最好提供一个无参构造方法以避免程序错误。</li>
<li>多态存在的条件：<br>1、要有继承<br>2、要有重写<br>3、父类引用指向子类对象</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题8.2 8.4源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter8/src" target="_blank" rel="external">chapter8</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>在面向对象程序设计中，可以由已有的类派生出子类，这叫做<]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第七章 字符串]]></title>
    <link href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.whtis.com/2016/01/26/Java学习总结-第七章-字符串/</id>
    <published>2016-01-26T13:33:26.000Z</published>
    <updated>2016-01-27T13:14:59.111Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java中，将字符串看作是对象，提供了String类、StringBuffer类和StringTokenizer类来存储和处理字符串。本章总结<code>字符串(string)</code>的处理。</p>
<h3 id="字符串类String">字符串类String</h3><ul>
<li><p>字符串的<code>快捷初始化(shorthand initializer)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="keyword">new</span> String(<span class="string">"xxx"</span>);</span><br><span class="line">String message = <span class="string">"xxx"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>永久字符串与规范字符串</p>
<ul>
<li>字符串是永久的。</li>
<li>如果两个String对象是通过快捷初始化用相同的字符串直接量构造的，则Java虚拟机为了提高效率，将它们存储在同一对象中。这样的字符串称为<code>规范字符串（canonical string）</code>。</li>
</ul>
</li>
<li>可以使用String对象的intern方法返回一个规范字符串，这种字符串与使用快捷初始化创建的字符串相同。</li>
<li>String类的几个常用方法<ul>
<li>charAt(int index) 提取指定字符</li>
<li>length() 返回数组的长度</li>
<li>concat（String s） 连接字符串s</li>
<li>subString(int beginIndex) 返回从beginIndex开始到结束的字符串</li>
<li>subString(int beginIndex，int endIndex) 返回从beginIndex开始到endIndex-1的字符串</li>
<li>regionMathches() 比较两个字符串的某一部分是否相等</li>
</ul>
</li>
<li>字符串的比较<ul>
<li>使用”==”运算符检测两个字符串是否具有相同的引用。</li>
<li>使用equals()方法对对象的内容进行比较。</li>
<li>使用compareTo()方法比较两个字符串。返回值由字典序决定。</li>
</ul>
</li>
<li>字符串的转换<ul>
<li>toLowerCase() 将字符串转换成小写</li>
<li>toUpperCase() 将字符串转换成大写</li>
<li>trim() 删除字符串两端的空格</li>
<li>replace(oldChar,newChar) 用新的字符替换旧的字符</li>
<li>replaceAll(oldChar,newChar) 用新的字符替换全部旧的字符</li>
</ul>
</li>
<li>获取字符串中的一个字符或子串<ul>
<li>indexOf() 得到某个字符</li>
<li>lastIndexOf() 得到某个字符串</li>
</ul>
</li>
<li>字符串与数组之间的转换<ul>
<li>字符串转换为数组： toCharArray() 方法</li>
<li>数组转换为字符串： 使用构造方法String(char[])或者valueOf(char[])方法</li>
</ul>
</li>
</ul>
<h3 id="字符类Character">字符类Character</h3><ul>
<li>常用的方法如下：<ul>
<li>charValue() 返回该对象的char值</li>
<li>is<em>() 判断该字符是否是</em></li>
</ul>
</li>
</ul>
<h3 id="字符串缓冲类StringBuffer">字符串缓冲类StringBuffer</h3><ul>
<li>StringBuffer类比String类更加灵活，可以在字符缓冲区中添加、插入或追加新的内容。字符串一旦创建后，它的值就不再改变。</li>
<li>常用方法如下：<ul>
<li>append() 在字符缓冲区中追加</li>
<li>deleteCharAt() 删除特定的字符</li>
<li>setCharAt() 在特定位置设置一个新字符</li>
<li>insert() 插入一个新内容</li>
<li>reverse() 倒置字符串缓冲区中字符的顺序</li>
<li>capacity() 返回字符串缓冲区的现有容量<br><strong>String类的方法StringBuffer类同样拥有</strong></li>
</ul>
</li>
<li>字符串的长度一定小于或等于缓冲区的容量。如果字符串的长度超过了缓冲区的容量，则缓冲区的容量将会变成2*（原缓冲区容量+1），因为在计算机内部，字符串缓冲区是一个字符数组。</li>
</ul>
<h3 id="字符串令牌类StringTokenizer">字符串令牌类StringTokenizer</h3><ul>
<li>该类用来将字符串分解为片段，以便提取和处理字符串中的信息。</li>
<li>常用方法：<ul>
<li>StringTokenizer(String s,String delim,boolean returnDelims)<br>使用指定的定界符构造字符串s的一个StringTokenizer对象。字符串delim中的每一个字符都是定界符。如果returndelims为true，那么定界符也看成令牌。</li>
<li>StringTokenizer(String s)<br>使用默认的定界符“\t \n \sr”（空格、制表符、换行符和回车符）构造字符串s的一个StringTokenizer对象，并且定界符不能算作令牌。</li>
<li>countTokens() 返回所包含的令牌数</li>
<li>hasMoreTokens() 如果该对象中还有令牌，返回true</li>
<li>nextToken() 返回下一个令牌</li>
</ul>
</li>
</ul>
<h3 id="字符串扫描类Scanner">字符串扫描类Scanner</h3><ul>
<li>StringTokenizer中，定界符是单个字符，使用Scanner类useDelimiter()方法，来指定一个单词作为定界符。</li>
<li>Scanner类可以实现从键盘中读取输入。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="命令行参数">命令行参数</h3><ul>
<li>使用如下命令行可以从命令行向main方法传递参数，参数保存在String[]类型的args数组中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java className arg0 arg1 arg2 ……</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>String类重写了equals()方法，因此可以用string.equals(string1)比较两个字符串；StringBuffer没有重写equals()方法，因此不能直接使用。</li>
<li>equals()方法最初是用来比较地址是否相等的。</li>
<li>StringTokenizer类没有无参构造方法。一个方法是否需要有无参构造方法取决于无参构造方法是否有意义，对StringTokenizer类来说，StringTokenizer对象必须是为某个字符串而创建的，因此不需要无参构造方法。</li>
<li>使用eclipse或者Intellij时，如果需要向main方法传递参数，乘号必须写成<code>&quot; *&quot;</code>或<code>&quot;* &quot;</code>才能正常显示结果。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题7.3 7.4 7.5 7.7 7.9 7.11 7.12 7.14 7.18源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter7/src" target="_blank" rel="external">chapter7</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java中，将字符串看作是对象，提供了String类、S]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第六章 对象和类]]></title>
    <link href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/"/>
    <id>http://www.whtis.com/2016/01/26/Java学习总结-第六章-对象和类/</id>
    <published>2016-01-26T09:30:41.000Z</published>
    <updated>2016-01-26T13:28:44.731Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>面向对象程序设计把数据和属于它们的操作放入一个叫做<code>对象（object）</code>的整体中，所有对象都与属性和活动联系在一起，这样做使程序更容易开发和维护。<br>本章将介绍面向对象程序设计的基本知识：声明类、创建对象、处理对象以及组织对象协调工作。</p>
<h3 id="对象和类">对象和类</h3><ul>
<li>对象代表现实世界中可以明确表示的一个整体。对戏那个有自己独特的特性、状态和行为。对象的<code>状态（state）</code>是由具有当前值的<code>数据域（data field，又称为属性）</code>的集合构成的。对象的<code>行为（behavior）</code>是<code>方法（methed）</code>的集合定义的。</li>
<li><code>类（class）</code>是定义同一类型对象的结构。在Java的类中，数据用来描述属性，方法用来定义行为。<br>类提供<code>构造方法(constructor)</code>，调用它可以创建类的对象。构造方法是用来进行初始化操作的。</li>
<li>包含main方法的类称为<code>主类（main class）</code>。</li>
</ul>
<h3 id="构造方法">构造方法</h3><ul>
<li>构造方法必须与定义它的类有完全相同的名字。构造方法可以重载，方便使用不同的初始数据值来构造对象。</li>
<li>构造方法没有返回类型，甚至连<code>void</code>也没有。</li>
<li>构造方法分为<code>有参构造方法</code>和<code>无参构造方法</code>。后者在类中没有明确声明构造方法时会自动生成，以避免程序出错。无参构造方法称为<code>默认构造方法</code>。</li>
<li>构造方法的调用是在创建一个对象时使用<code>new</code>操作符进行的。<br><strong>类是一个蓝本，定义对象的数据和方法。一个对象是类的一个实例。可以从一个类中创建多个实例。创建的一个实例被称为<code>实例化（instantiation）</code>。<code>对象（object）</code>和<code>实例（instance）</code>两个词语经常互换使用。</strong></li>
</ul>
<h3 id="对象的访问">对象的访问</h3><ul>
<li><p>新创建的对象在内存中占用空间，通过访问对象的<code>引用变量</code>来访问，该变量仅包含对象的引用地址。<br>一个类所定义的类型被称为<code>引用类型（reference type）</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问新创建的对象的数据和方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectRefVar.data------引用对象的数据。</span><br><span class="line">objectRefVar.method------引用对象的方法。</span><br></pre></td></tr></table></figure>
</li>
<li><p>当创建一个对象，但不赋给这个对象任何引用变量，那么这样创建的对象称为<code>匿名（anonymous）</code>对象。</p>
</li>
<li>基本数据类型变量和引用类型变量的区别<ul>
<li>基本数据类型在内存中存储时就是基本类型的数据，但是引用类型在内存中存储的是一个引用，指向对象的存储地址。</li>
<li>将一个基本数据类型变量赋值给另一个变量时，这个变量也有了相同的值。但将一个引用类型变量赋值给另一个变量时，这个变量仅拥有原来对象的引用。</li>
</ul>
</li>
</ul>
<h3 id="可见性修饰符、访问器和修改器">可见性修饰符、访问器和修改器</h3><p>  Java提供了几个修饰符，用来控制对数据、方法和类的访问。</p>
<ul>
<li>public 使类、方法和数据域可以在任何类中访问。</li>
<li>private 使方法和数据域只能从它自己所在类中访问。</li>
<li>默认情况下，类、方法和数据域可以从同一个包里的任何类中访问，这时也被称为<code>包私有的（package-private）</code>或者<code>包内访问的（package-access）</code>。</li>
<li>一个对象不能访问自己类中的私有成员。但是，如果对象是在自己类内声明的则可以。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象在自己类中声明，正确</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> x;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">		System.out.println(foo.x);</span><br><span class="line">		System.out.println(foo.convert(foo.x));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">convert</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象不在自己类中声明，无法访问私有成员</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">		System.out.println(foo.x);</span><br><span class="line">		System.out.println(foo.convert(foo.x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>修饰符private只修饰数据和方法，不修饰整个类（内部类除外）。</li>
<li>大多数情况下，构造方法应该是公用的（public）。但是，如果不想让用户创建某个类的实例，可以使用私有的构造方法。例如：Math类。</li>
</ul>
<h3 id="数据域的封装（data_field_encapsulation）">数据域的封装（data field encapsulation）</h3><ul>
<li>为了避免通过对象引用直接修改属性，应该使用private修饰符声明私有域。</li>
<li>get()方法称为读取器（getter）或访问器（accessor），set()方法称为设置器（setter）或修改器（mutator）。</li>
<li>使用数据域封装使类更加容易维护。</li>
</ul>
<h3 id="永久对象和类">永久对象和类</h3><ul>
<li>如果一个对象一旦被创建，它的内容就不能再改变，那么该对象就称为<code>永久对象（immutable object）</code>，它的类称为<code>永久类（immutable class）</code>。</li>
<li>一个类的所有数据都是私有的并且没有修改器，但它不一定是永久类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>要使一个类成为永久类，必须将所有数据域说明为私有的，并且不含返回引用非永久对象数据域的修改器和访问器。</p>
<h3 id="给方法传递对象参数">给方法传递对象参数</h3><ul>
<li>传递对象实际上是传递对象的引用（copy referance）；传递基本数据类型的参数时，传递的是实参的值。（copy value）</li>
</ul>
<h3 id="静态变量、常量和静态方法">静态变量、常量和静态方法</h3><ul>
<li>实例变量不能被同一个类中的多个对象共享，<code>静态变量（static variavle，又称为类变量）</code>可以让一个类中的所有实例共享数据。</li>
<li>静态变量存储在类的公用内存中，如果某个对象修改了静态变量的值，同一类中的所有对象都会受到影响。</li>
<li>使用修饰符<code>static</code>声明静态变量或静态方法。</li>
</ul>
<h3 id="变量的作用域">变量的作用域</h3><ul>
<li>类的实例变量和静态变量称为<code>类属变量（class&#39;s variavble，常称为类变量）</code>或<code>数据域（data field）</code>。<br>定义在方法内部的变量称为局部变量。</li>
<li>类属变量的作用域是整个类，局部变量的作用域是方法体内。</li>
<li>如果局部变量和一个类属变量具有相同的名字，那么局部变量优先，同名的类属变量将会被隐藏。<strong>（就近原则）</strong></li>
</ul>
<h3 id="this关键字">this关键字</h3><p>有时需要在方法中引用类属的<code>隐藏变量（hidden variable）</code>。</p>
<ul>
<li>隐藏的静态变量可以通过“类名.静态变量”的方式引用。隐藏的实例变量需要使用关键字<code>this</code>来引用。</li>
</ul>
<h3 id="对象数组">对象数组</h3><p>数组中的元素可以为对象，要初始化对象数组，可以使用for循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	Objects[i] = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类的抽象和封装">类的抽象和封装</h3><ul>
<li><code>类抽象（class abstraction）</code>是将类的实现和使用分离。类的创建者提供了类的描述，让使用者明白如何使用类。从类外可以访问的方法和数据域的全体，以及对这些成员如何使用的描述，合称为<code>类的合约（class&#39;s contract）</code>。</li>
<li><code>类的封装（class encapsulation）</code>是将类的实现细节包装好，对用户隐藏起来，用户不需要知道如何实现的，仅需要知道如何使用即可。</li>
</ul>
<h3 id="内部类">内部类</h3><ul>
<li><code>内部类(inner class)</code>或者叫<code>嵌入类（nested class）</code>，是一种在其他类的内部定义的类。</li>
<li>内部类可以引用包含在它的外部类中的数据和方法。</li>
<li>内部类只是用来支持其外部类的工作。</li>
<li>内部类可以声明为public、protected或private，其意义与用在类的其他成员上相同。</li>
<li>内部类可以声明为静态的static。可以使用外部类的类名来访问静态的内部类，静态内部类不能访问外部类的非静态成员。</li>
<li><p>从另外的类中创建内部类的对象：</p>
<ul>
<li><p>如果内部类是非静态的，必须先创建外部类的实例，然后使用如下语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 内部类对象名 = 外部类对象.new 内部类();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果内部类是静态的，使用如下语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 内部类对象名 = <span class="keyword">new</span> 外部类对象.内部类();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>在面向过程程序设计语言中，数据和方法是分离的，但是在面向对象语言中，数据和方法定义在同一个类当中。</li>
<li>引用型数据的默认值是<code>null</code>,数值型的默认值是<code>0</code>，boolean型的默认值是<code>false</code>，char型的默认值是<code>‘\u0000’</code>。</li>
<li>通过引用变量引用一个对象之前，必须先创建该对象。如果引用一个没有创建的对象，会引起运行错误<code>NullPointerException</code>。</li>
<li>通过数据域的封装，原类中的数据不会被改变，仅在外部类调用时临时修改。</li>
<li>如何判断一个变量或方法定义为实例的还是静态的？<br>如果一个变量或方法依赖于类的具体实例，应该定义为实例变量或实例方法。如果一个变量或方法不依赖羽类的具体实例，就该定义为静态变量或静态方法。</li>
<li>如何在内存中区分对象和类？<ul>
<li>类是静态的概念，位于代码区</li>
<li>对象是new出来的，位于堆内存。类的每个成员变量在不同的对象中都有不同的值（除了静态变量），而方法只有一份，执行的时候才占用内存。<br>堆内存是程序运行时动态分配的内存。</li>
</ul>
</li>
<li>非静态方法是依据不同的对象进行调用。</li>
<li>静态成员变量存在于<code>data seg</code>区。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题6.1 6.3 6.5 6.7 6.8 6.11 6.12 6.13源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter6/src" target="_blank" rel="external">chapter6</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>面向对象程序设计把数据和属于它们的操作放入一个叫做<co]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第五章 数组]]></title>
    <link href="http://www.whtis.com/2016/01/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E7%BB%84/"/>
    <id>http://www.whtis.com/2016/01/20/Java学习总结-第五章-数组/</id>
    <published>2016-01-20T11:59:25.000Z</published>
    <updated>2016-01-28T06:04:05.676Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍了数组的基本知识。数组用于存储一个元素个数和类型固定的有序集，并提供对这些数据进行处理的各种方法。</p>
<h3 id="数组">数组</h3><ul>
<li>声明数组： 数据类型[] 数组名</li>
<li>数组创建后，数组元素通过下标来访问。数组下标是<code>基于0的（0-based）</code>，因此数组的下表最大值是arrayObject.length-1。</li>
<li><p>增强的for循环可以在不用下标变量的情况下访问整个数组，用法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(elementType value:arrayRefVar) &#123;</span><br><span class="line">   <span class="comment">//process the value  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组初始化：数据类型[] 数组变量 = {直接量1，直接量2，···，直接量n}；<br>数组初始化语句中不使用运算符new。使用时，必须将声明、创建、初始化数组都放在一个语句中。</p>
</li>
</ul>
<h3 id="数组的复制">数组的复制</h3><ul>
<li>可以直接使用赋值语句（=）进行数组的复制，这样操作仅能够将数组的引用进行复制。</li>
<li>复制数组中的内容有以下三种方法:<ul>
<li>用循环语句分别复制数组的每一个元素。</li>
<li>使用System类中的静态方法arraycopy（）方法。</li>
<li>使用clone（）方法复制数组。</li>
</ul>
</li>
</ul>
<h3 id="数组的排序">数组的排序</h3><ul>
<li>选择排序法</li>
<li>冒泡排序法</li>
<li>插入排序法<br>具体算法见<a href="http://www.whtis.com/2015/12/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/">排序的几种写法</a><br><strong>在java.util.Array类中，Java提供了几个排序的重载方法，可以用来对int型、double型、char型、short型、long型和float型数组进行排序。</strong></li>
</ul>
<h3 id="数组的查找">数组的查找</h3><ul>
<li><p>线性查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">listSearch</span><span class="params">(<span class="keyword">int</span>[] lists, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分法查找：前提是数组元素必须已经排序。</p>
<ul>
<li><p>二分法的迭代实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] lists, <span class="keyword">int</span> key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key == lists[(high + low) / <span class="number">2</span>]) &#123;</span><br><span class="line">              <span class="keyword">return</span> (high + low) / <span class="number">2</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; lists[(high + low) / <span class="number">2</span>]) &#123;</span><br><span class="line">              low = ((high + low) / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; lists[(high + low) / <span class="number">2</span>]) &#123;</span><br><span class="line">              high = ((high + low) / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -low - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分法的递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursiveBinarySearch</span><span class="params">(<span class="keyword">int</span>[] lists, <span class="keyword">int</span> key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">          <span class="keyword">return</span> -low - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (key &lt; lists[mid]) &#123;</span><br><span class="line">          <span class="keyword">return</span> recursiveBinarySearch(lists, key, low, mid - <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == lists[mid]) &#123;</span><br><span class="line">          <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> recursiveBinarySearch(lists, key, mid + <span class="number">1</span>, high);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="多维数组">多维数组</h3><ul>
<li>声明：数据类型[][] 数组引用变量<br>-数组的长度：数组的长度是指数组中元素的个数。<code>n</code>维数组是由<code>k</code>个<code>n-1</code>维数组构成，那么n维数组的个数就是<code>k</code>。例如：<br>x = new int[2][3][5],则x[0]和x[1]是二维数组，x的长度就是2。</li>
<li>锯齿数组<br>二维数组中，每一行本身是一个数组。因而各行就可以有不同的长度，这样的数组称为锯齿数组。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] x = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">	&#123;<span class="number">5</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>数组变量只存储着数组的引用。</li>
<li>越界访问数组是常见的编程错误。它出现错误时的Exception是ArrayIndexOutOfBoundsException，通常称为<code>过一错误（off-by-one error）</code></li>
<li>使用语法new int[5][]创建数组时，第一个下标必须给定。new int[][]是错误的。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题5.5 5.7 5.12 5.14 5.15 5.16 5.25源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter5/src" target="_blank" rel="external">chapter5</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍了数组的基本知识。数组用于存储一个元素个数和类型]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第四章 方法]]></title>
    <link href="http://www.whtis.com/2016/01/11/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2016/01/11/Java学习总结-第四章-方法/</id>
    <published>2016-01-11T14:16:41.000Z</published>
    <updated>2016-01-26T13:27:50.595Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍了如何编写带返回值和不带返回值的方法以及如何调用含参/不含参的方法。采用这些规范可以编写递归方法，最后介绍如何使用方法抽象进行程序设计。</p>
<h3 id="基本方法的语法结构：">基本方法的语法结构：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用方法">调用方法</h3><p>创建方法时，定义了方法干什么。要使用方法，必须<code>调用</code>（call）或<code>引用</code>（invoke）它。</p>
<ul>
<li>调用堆栈：每当调用一个方法时，系统将参数、局部变量和系统寄存器存储在一个内存区域中。这个内存区域称为<code>堆栈</code>（stack）。它使用后进先出的方式存储数据。</li>
</ul>
<h3 id="参数传递">参数传递</h3><ul>
<li>参数传递需要注意<code>参数顺序匹配</code>。</li>
<li>Java中的参数传递，如果是基本数据类型，传递是值本身，如果是引用数据类型，传递的是这个引用。<br><strong>需要注意的是，实参将参数传给形参，这种传递方式称为<code>值传递</code>（pass by value）。无论形参在方法中如何改变，该实参的值不受影响。（可以通俗的理解为：实参传递给形参的这个过程，是copy了一份给形参）。</strong></li>
</ul>
<h3 id="重载方法">重载方法</h3><ul>
<li>主要用于不同的构造方法。</li>
<li>重载方法可使程序清晰易读。执行相似任务的方法应该给予相同的名称。</li>
<li>有时一个方法调用会有两个或更多可能的匹配，编译器无法判断哪个更为合适。这成为<code>歧义匹配。</code>歧义匹配是编译错误。</li>
</ul>
<h3 id="方法抽象">方法抽象</h3><ul>
<li>方法抽象是把方法的应用同实现分离开来。</li>
<li>在不知道方法如何实现的情况下也可以使用方法，这就是方法的<code>信息隐藏</code>或<code>封装</code>。</li>
</ul>
<h3 id="Math类的常用方法">Math类的常用方法</h3><ul>
<li>三角函数方法：sin、cos、tan、asin、acos、atan、toRadians、toDegrees······</li>
<li>指数函数方法：exp、log </li>
<li>服务型方法：pow、sqrt</li>
<li>常量：Math.PI、Math.E</li>
<li>取整方法：ceil、floor、rint、round</li>
<li>min、max、abs</li>
<li>random方法<ul>
<li>random方法生成大于等于0.0小于1.0的double型随机数（0&lt;Math.random()&lt;1.0）。该方法十分有用，可以用它来生成任意范围的随机数。</li>
<li>可以生成任意两个字符ch1和ch2(ch1&lt;ch2）之间之间的随机字符：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">char</span>)(ch1+Math.random()*(ch2-ch1+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="递归">递归</h3><ul>
<li>递归是函数直接或间接调用自己的过程。</li>
<li>所有的递归方法都用下列特征：<ul>
<li>有一个或多个初始状态（最简单情形）用于中断递归。</li>
<li>每次递归调用都简化原始问题，使它越来越接近初始状态，直到达到初始状态。</li>
</ul>
</li>
<li><p>递归的两个实例：</p>
<ul>
<li><p>计算斐波那契数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> fib(index - <span class="number">1</span>) + fib(index - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>汉诺塔问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveDisks</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> fromTower, <span class="keyword">char</span> ToTower, <span class="keyword">char</span> auxTower)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"move disk "</span> + n + <span class="string">" from "</span> + fromTower + <span class="string">" to "</span> + ToTower);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          moveDisks(n - <span class="number">1</span>, fromTower, auxTower, ToTower);</span><br><span class="line">          System.out.println(<span class="string">"move disk "</span> + n + <span class="string">" from "</span> + fromTower + <span class="string">" to "</span> + ToTower);</span><br><span class="line">          moveDisks(n - <span class="number">1</span>, auxTower, ToTower, fromTower);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>递归与迭代</p>
<ul>
<li>递归是程序控制的另一种形式，本质上是不用循环控制的重复。</li>
<li>递归和迭代相比，会耗费太多的时间并占用太多的内存。</li>
<li>能用递归解决的问题都可以用迭代完成，递归仅在某些能够简化问题解法的情况下使用。</li>
</ul>
</li>
</ul>
<h3 id="包">包</h3><ul>
<li>包用于对类进行组织。</li>
<li>包是有层次的，使用包需要先引入。</li>
<li>使用包可以避免命名冲突。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>方法是一个提供程序模块化和可重用性的结构。</li>
<li>方法中不可以再定义方法。  </li>
<li>歧义匹配的最典型例子就是两个方法的名称和参数列表都相同，但其返回值或者修饰符不同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题4.10 4.11 4.12 4.13 4.15 4.16 4.17 4.20 4.21 4.22 4.23 4.24 4.25源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter4/src" target="_blank" rel="external">chapter4</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍了如何编写带返回值和不带返回值的方法以及如何调用]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第三章 控制语句]]></title>
    <link href="http://www.whtis.com/2016/01/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://www.whtis.com/2016/01/10/Java学习总结-第三章-控制语句/</id>
    <published>2016-01-10T13:49:40.000Z</published>
    <updated>2016-01-26T13:27:19.362Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍了java语言中循环（loop）的使用方式。</p>
<h3 id="条件语句">条件语句</h3><ul>
<li>if语句</li>
<li>if…else语句</li>
<li>嵌套if语句</li>
<li>switch语句</li>
<li>条件表达式：符号？和：在条件表示式中同时出现，构成java中唯一的三目运算符<br>例如 <code>(x&gt;y)?x:y</code></li>
</ul>
<h3 id="循环语句">循环语句</h3><ul>
<li>while循环</li>
<li>do-while循环</li>
<li>for循环<br><strong>如果知道循环次数，就选择for循环；如果不知道次数，就选择while循环。</strong></li>
</ul>
<h3 id="关键字break和continue">关键字break和continue</h3><ul>
<li>break: 跳出离它最近的循环体。</li>
<li>continue： 跳出当次循环。</li>
<li>利用语句标号终止循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0</span>;i++)&#123;</span><br><span class="line">  inner:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i*j&gt;<span class="number">50</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i*j);</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>while循环执行最多<code>n</code>次，do-while循环执行次数最多是<code>n+1</code>次。</li>
<li>从jdk1.7开始，switch变量增至6个：<code>byte</code>,<code>int</code>,<code>long</code>,<code>short</code>,<code>enum</code>,<code>String</code>。后两个为新增的。</li>
<li>使用switch语句，可以处理多种情况，简化代码。</li>
<li>for语句可以写为如下形式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样可以在不知道具体循环次数的情况下保证代码的正常运行。</p>
<hr>
<h2 id="编程练习">编程练习</h2><p>3.2 （三个整数排序）：见<a href="http://www.whtis.com/2015/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%E4%B8%AA%E6%95%B4%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/">三个整数进行比较大小的三种方法</a></p>
<p>3.14 （查找两个最高分）编写程序，提示用户输入学生的数量及每个学生的名字和得分，而后显示最高分的学生。<br>解题思路：使用hashMap存入key-value，排序后显示，代码如下：(本题解法，若按照书中顺序，是无法完成的。看书时没有细想，参考了网上的解法。有时间再回来更新吧0.0)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $3<span class="title">_14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println( <span class="string">"请输入学生的数量："</span>);</span><br><span class="line">        <span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入学生的姓名： "</span>);</span><br><span class="line">            String name = scanner.next();</span><br><span class="line">            System.out.println(<span class="string">"请输入该生的成绩： "</span>);</span><br><span class="line">            <span class="keyword">int</span> hh = scanner.nextInt();</span><br><span class="line">            map.put(name, hh);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Map.Entry&lt;String, Integer&gt;&gt; infolds = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Collections.sort(infolds, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (o2.getValue() - o1.getValue());</span><br><span class="line"><span class="comment">//                return (o1.getKey()).toString().compareTo(o2.getKey());</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infolds.size(); i++) &#123;</span><br><span class="line">            String id = infolds.get(i).toString();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>习题3.5 3.7 3.10 3.12 3.13 3.19 3.20 3.21 3.25 3.27 3.28 3.30 3.31 3.34源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter3/src" target="_blank" rel="external">chapter3</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章介绍了java语言中循环（loop）的使用方式。</]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Premiere 学习笔记]]></title>
    <link href="http://www.whtis.com/2015/12/23/Premiere-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.whtis.com/2015/12/23/Premiere-学习笔记/</id>
    <published>2015-12-23T05:24:26.000Z</published>
    <updated>2016-01-10T13:47:21.328Z</updated>
    <content type="html"><![CDATA[<p><strong>视频教程<a href="http://www.bilibili.com/video/av1290353.html" target="_blank" rel="external">看这里</a></strong></p>
<h3 id="导入、图片素材处理、导出视频">导入、图片素材处理、导出视频</h3><ul>
<li>导入： ctrl+I</li>
<li>时间轴缩放： +、-</li>
<li>导出媒体： ctrl+M</li>
</ul>
<h3 id="视频剪辑">视频剪辑</h3><ul>
<li>入点和出点： 标记视频，快捷键（I/O）</li>
<li>剃刀工具： 剪辑标记段视频，快捷键C</li>
<li>子剪辑： 剪辑下来的片段重新存储为素材</li>
</ul>
<h3 id="放机与录机">放机与录机</h3><ul>
<li>全屏幕切换放机与录机： ~</li>
<li>分离视频和音频： 右键→取消链接</li>
<li>详细找素材：<ul>
<li>（加速）倒放： (j)j</li>
<li>暂停： k</li>
<li>（加速）快进： (l)l</li>
<li>放机中的素材插入到录机中的两种操作：<ul>
<li>插入</li>
<li>覆盖<br><strong>编辑视频找素材时，应该在录机和放机中寻找和剪辑，这样能够节约很多时间</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="历史记录、工作区、面板">历史记录、工作区、面板</h3><ul>
<li>历史记录面板： 可以选择记录多少次历史状态</li>
<li>原数据面板： 看素材属性</li>
<li>蓝布棉门帘？</li>
<li>自动保存： 手动以时间另存为</li>
</ul>
<h3 id="界面设置、快捷键">界面设置、快捷键</h3><ul>
<li>时间轴滚动方式<ul>
<li>不滚动</li>
<li>页面滚动</li>
<li>平滑滚动</li>
</ul>
</li>
<li>标识帧： 在视频上定义一个标识位置</li>
</ul>
<h3 id="标记">标记</h3><ul>
<li>连续视频缩览图： 时间轴面板右键可以调出</li>
<li>标记（marker）： 标记时间轴上的某个位置，快捷键M<ul>
<li>下一个标记： shift+M</li>
<li>上一个标记： ctrl+shift+M</li>
<li>可以调出标记面板进行标记的详细说明</li>
<li>标记不仅可以在放机时间轴上使用，还可以在录机时间轴上使用</li>
</ul>
</li>
</ul>
<h3 id="速度设置">速度设置</h3><ul>
<li>鼠标右键→速度/持续时间… 可以调整视频的速度、是否倒放： 快捷键R</li>
<li>编辑区播放头快速定位： ↑ ↓ 箭头</li>
</ul>
<h3 id="节奏、序列、轨道">节奏、序列、轨道</h3><ul>
<li>导入序列的两种方法：<ul>
<li>新建一个序列后直接拖动： 会保留所有原始信息</li>
<li>将序列作为嵌套或个别剪辑插入并覆盖： 仅包含序列整体的信息</li>
</ul>
</li>
<li>轨道： 音频轨道和视频轨道可以分离并重新编辑（鼠标右键→取消链接）</li>
</ul>
<h3 id="画中画">画中画</h3><ul>
<li>效果控件： shift+5 可以更改单个视频轨道的视频位置    </li>
<li>视频的位置和角度可以使用数值进行精确编辑： 效果控件面板中，视频→运动</li>
</ul>
<h3 id="关键帧（keyframe）">关键帧（keyframe）</h3><ul>
<li>效果控件面板，视频→运动下面的选项，都可以点击相应左侧闹钟添加、编辑关键帧</li>
<li>通过控制关键帧的数值操作视频</li>
</ul>
<h3 id="淡入淡出">淡入淡出</h3><ul>
<li>效果控件面板，视频→透明度下面的选项，都可以点击相应左侧闹钟添加、编辑关键帧</li>
<li></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>视频教程<a href="http://www.bilibili.com/video/av1290353.html" target="_blank" rel="external">看这里</a></strong></p>
<h3 id="导入、图片素材处理、]]>
    </summary>
    
      <category term="Premiere" scheme="http://www.whtis.com/tags/Premiere/"/>
    
      <category term="视频制作" scheme="http://www.whtis.com/tags/%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C/"/>
    
      <category term="Premiere" scheme="http://www.whtis.com/categories/Premiere/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第二章 基本数据类型和基本操作]]></title>
    <link href="http://www.whtis.com/2015/12/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.whtis.com/2015/12/22/Java学习总结-第二章-基本数据类型和基本操作/</id>
    <published>2015-12-22T06:10:25.000Z</published>
    <updated>2016-01-30T08:20:59.753Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章对Java中的各种数据类型进行了介绍，并给出了互相转换的方法；本章介绍了Java的语法规则，编写规则和编程错误。</p>
<h3 id="命名标识符的规则">命名标识符的规则</h3><ul>
<li>必须以字母、下划线（_）或美元符号（$）开头，不能用数字开头。</li>
<li>不能是java中的关键字。</li>
<li>Java区分大小写，标识符大小写有区别。<br><strong>java标识符选取应该“见名知意”，命名通常采用“驼峰命名法”。</strong></li>
</ul>
<h3 id="常量和变量">常量和变量</h3><ul>
<li>变量是用来表示特定类型的数据。变量在使用前应该用“=”进行赋值，以减少编程错误。</li>
<li>常量使用<code>final</code>关键字定义表示常量的值一旦生成就不会改变。</li>
</ul>
<h3 id="数值数据类型及其运算">数值数据类型及其运算</h3><ul>
<li>整数除法的结果是整数，5/2结果是2。整型数可以精确存储而浮点数不能。</li>
<li>默认情况下，整型直接量是十进制数。如果要写八进制数，用<code>0</code>开头，要写十六进制数，用<code>0x</code>或者<code>0X</code>开头。</li>
<li>double型的值比float型更精确。</li>
<li>简捷运算符<ul>
<li><code>+=</code>,<code>-=</code>,<code>*=</code>,<code>/=</code>,<code>%=</code></li>
<li>加一和减一（假设i=1）<ul>
<li>a=i++； //执行完本条语句后，a=1,i=2</li>
<li>a=++i； //执行完本条语句后，a=2,i=2</li>
<li>a=i–； //执行完本条语句后，a=1,i=0</li>
<li>a=–i； //执行完本条语句后，a=0,i=0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数值类型转换">数值类型转换</h3><ul>
<li>拓宽类型：将一个小范围类型的变量转换为大范围类型的变量；<br>缩窄类型：将一个大范围类型的变量转换为小范围类型的变量。<br>拓宽类型不需要明确指出，可以自动执行，缩窄类型必须明确指出。</li>
<li>缩窄类型会导致不精确的结果。而且必须得进行显性转换，否则会出现编译错误。</li>
</ul>
<h3 id="字符数据类型及其运算">字符数据类型及其运算</h3><ul>
<li>字符型直接量用单引号扩住：’A’<br>字符串类型直接量用双引号扩住：”A”<br>字符型直接量只能是单个字符，字符串直接量可以有多个字符。</li>
<li>特殊字符的转义： 使用<code>\*</code>，其中，<code>\t</code>是制表符，<code>\b</code>是退格键，<code>\n</code>是指换行</li>
<li>字符型数据与数值型数据之间的转换<ul>
<li>整数转为char型：只使用整数的低16位，其余忽略。</li>
<li>浮点数转为char型：先将浮点数转为int型，再转为char型数据。</li>
<li>char型转换为数值型：字符的Unicode码被转换成指定的数值类型。<br><strong>如果转换结果在目标变量的范围内，可以使用隐式转换（自动转换）。例如： byte b=’0’。在十六进制表示的0到FFFF之间的任何一个正整数，都可以自动转换成char型数据。</strong></li>
<li>当计算<code>a+b</code>时。如果b是一个数字或字符，a将会被转换成Unicode数值。如果b是个字符串，a将会以字符串参与运算。</li>
</ul>
</li>
</ul>
<h3 id="布尔数据类型及其运算">布尔数据类型及其运算</h3><ul>
<li>比较运算符：<code>==</code>,<code>!=</code>,<code>&lt;=</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&gt;</code></li>
<li>逻辑运算符：<code>!</code>,<code>&amp;&amp;</code>,<code>||</code>,<code>^</code></li>
<li>条件和无条件逻辑运算符（布尔运算符，）<ul>
<li><code>&amp;&amp;</code>,<code>||</code> 称为<code>条件</code>运算符或<code>捷径</code>运算符：假设<code>p1&amp;&amp;p2</code>中p1为false，则无需计算p2的真值。</li>
<li><code>&amp;</code>,<code>|</code> 称为<code>无条件</code>运算符或<code>无捷径</code>运算符：假设<code>p1&amp;p2</code>中p1为false，但还是需要计算p2的真值。</li>
</ul>
</li>
<li>布尔类型不能转换为其他类型。</li>
</ul>
<h3 id="运算符的优先级和结合方向">运算符的优先级和结合方向</h3><ul>
<li>赋值运算符是右结合的，双目运算符是左结合的。</li>
<li>双目运算符左边运算对象的计算先于右边运算对象任何一部分的计算。</li>
<li>如果运算对象没有修改变量值的副作用，运算对象的运算顺序是无关紧要的。</li>
<li>运算对象的计算顺序的优先级高于运算符的优先级规则。</li>
</ul>
<h3 id="格式化输出">格式化输出</h3><ul>
<li>格式化输出：<code>System.out.printf(format,items);</code></li>
</ul>
<h3 id="程序错误">程序错误</h3><ul>
<li><code>语法错误（syntax error）</code>：没有遵循语言的规则，它们可以由编译器检查发现。属于编译错误。</li>
<li><code>运行错误（runtime error）</code>：在程序运行过程中，如果环境发现了一个不可能执行的操作，就会出现运行错误。</li>
<li><code>逻辑错误（logic error）</code>：如果程序没有按照预期的方案执行，就会发生逻辑错误。</li>
</ul>
<h3 id="编程风格">编程风格</h3><ul>
<li>适当的注释和注释类型</li>
<li>块的对齐方式<ul>
<li>此行风格</li>
<li>行尾风格</li>
</ul>
</li>
</ul>
<h3 id="调试（debug）">调试（debug）</h3><p>略。</p>
<hr>
<h2 id="复习小结">复习小结</h2><h3 id="闰年的计算方式">闰年的计算方式</h3><ul>
<li>一个年号如果能被4整除但不能被100整除，或者能被400整除，则它是闰年。<br><code>（（year%4==0）&amp;&amp;（year%100！=0））||（year%400==0）</code></li>
</ul>
<h3 id="时间的计算">时间的计算</h3><ul>
<li><p>使用System类中的currentTimeMillis（）方法得到Unix时间戳。使用如下步骤可以计算出当前时间的时、分、秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> totalMilliseconds = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> totalSeconds = totalMilliseconds / <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> seconds = (<span class="keyword">int</span>) (totalSeconds % <span class="number">60</span>);</span><br><span class="line"><span class="keyword">long</span> totalMinutes = totalSeconds / <span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> minutes = (<span class="keyword">int</span>) (totalMinutes % <span class="number">60</span>);</span><br><span class="line"><span class="keyword">long</span> totalHours = totalMinutes / <span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> hours = (<span class="keyword">int</span>) (totalHours % <span class="number">24</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>java currentTimeMillis()和nanoTime()方法辨析<br> currentTimeMillis（）和nanoTime都属于java.lang这个包中，其中：</p>
<ul>
<li>currentTimeMillis() 返回的是当前时间（0区时间）与<code>1970</code>年<code>1</code>月<code>1</code>日<code>0</code>时 相差的时间，返回值是long类型，以毫秒计数。可用于计算当前时间。</li>
<li>nanoTime()返回的是一个随机的纳秒数，与系统当前时间无关，仅用于测量某一个时间段中所用的时间。</li>
</ul>
</li>
</ul>
<h3 id="从控制台获取输入：">从控制台获取输入：</h3><ul>
<li>使用Scanner类:<br><code>Scanner sc = new Scanner(System.in);</code></li>
<li>使用args数组获得输入<br><code>java *.class args[0] args[1]</code></li>
</ul>
<h3 id="直接量">直接量</h3><p>  直接量并非是运算的结果，也不是I/O操作的结果，而是直接写在代码里的数据。</p>
<h3 id="需要注意的几点">需要注意的几点</h3><ul>
<li>int类型转换byte类型可以得到结果，但结果不精确，仅取相应字节的数据。</li>
<li>double转换float类型会得到infinity错误，原因是浮点数存储方式不同。</li>
<li>Java在运算时会自动的提升变量的精度来进行运算。double比float精度高，所以可以自动的从float转化至double再进行运算。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>习题2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 2.10 2.11 2.11程序源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter2/src" target="_blank" rel="external">chapter2</a></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章对Java中的各种数据类型进行了介绍，并给出了互相转]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结--第一章 计算机、程序和Java概述]]></title>
    <link href="http://www.whtis.com/2015/12/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E7%A8%8B%E5%BA%8F%E5%92%8CJava%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.whtis.com/2015/12/20/Java学习总结-第一章-计算机、程序和Java概述/</id>
    <published>2015-12-20T12:42:57.000Z</published>
    <updated>2016-01-26T13:30:53.305Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章简单介绍了计算机和Java有关的知识，让人有初步了解。</p>
<h3 id="二进制与十进制数的转换">二进制与十进制数的转换</h3><p>给定二进制数<img src="http://latex.codecogs.com/gif.latex?b_{n}b_{n-1}b_{n-2}...b_{2}b_{1}b_{0}">,与它相等的十进制数为<br><img src="http://latex.codecogs.com/gif.latex?b_{n}*2^{n}&plus;b_{n-1}*2^{n-1}&plus;b_{n-2}*2^{n-2}&plus;...&plus;b_{2}*2^{2}&plus;b_{1}*2^{1}&plus;b_{0}*2^{0}"><br>把一个十进制数d转换为二进制数，就是求满足<br><img src="http://latex.codecogs.com/gif.latex?d=b_{n}*2^{n}&plus;b_{n-1}*2^{n-1}&plus;b_{n-2}*2^{n-2}&plus;...&plus;b_{2}*2^{2}&plus;b_{1}*2^{1}&plus;b_{0}*2^{0}"><br>的位<img src="http://latex.codecogs.com/gif.latex?b_{n},b_{n-1},b_{n-2},...,b_{2},b_{1},b_{0}">。用2不断的除d，直到商为0为止，余数即为所求的位<img src="http://latex.codecogs.com/gif.latex?b_{0},b_{1},b_{2},...,b_{n-2},b_{n-1},b_{n}">。</p>
<h3 id="十六进制与十进制数的转换">十六进制与十进制数的转换</h3><p>给定十六进制数<img src="http://latex.codecogs.com/gif.latex?h_{n}h_{n-1}h_{n-2}...h_{2}h_{1}h_{0}">,与它相等的十进制数为<br><img src="http://latex.codecogs.com/gif.latex?h_{n}*16^{n}&plus;h_{n-1}*16^{n-1}&plus;h_{n-2}*16^{n-2}&plus;...&plus;h_{2}*16^{2}&plus;h_{1}*16^{1}&plus;h_{0}*16^{0}"><br>把一个十进制数d转换为二进制数，就是求满足<br><img src="http://latex.codecogs.com/gif.latex?d=h_{n}*16^{n}&plus;h_{n-1}*16^{n-1}&plus;h_{n-2}*16^{n-2}&plus;...&plus;h_{2}*16^{2}&plus;h_{1}*16^{1}&plus;h_{0}*16^{0}"><br>的位<img src="http://latex.codecogs.com/gif.latex?h_{n},h_{n-1},h_{n-2},...,h_{2},h_{1},h_{0}">。用16不断的除d，直到商为0为止，余数即为所求的位<img src="http://latex.codecogs.com/gif.latex?h_{0},h_{1},h_{2},...,h_{n-2},h_{n-1},h_{n}">。</p>
<h3 id="二进制数与十六进制数的转换">二进制数与十六进制数的转换</h3><p>要把一个十六进制数转换为二进制数，只需要使用下表，把十六进制数的每一位转换为四位二进制数即可。</p>
<table>
<thead>
<tr>
<th style="text-align:right">十六进制</th>
<th style="text-align:right">二进制</th>
<th style="text-align:right">十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:right">1</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:right">10</td>
<td style="text-align:right">2</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:right">11</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:right">100</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td style="text-align:right">5</td>
<td style="text-align:right">101</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td style="text-align:right">6</td>
<td style="text-align:right">110</td>
<td style="text-align:right">6</td>
</tr>
<tr>
<td style="text-align:right">7</td>
<td style="text-align:right">111</td>
<td style="text-align:right">7</td>
</tr>
<tr>
<td style="text-align:right">8</td>
<td style="text-align:right">1000</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:right">1001</td>
<td style="text-align:right">9</td>
</tr>
<tr>
<td style="text-align:right">A</td>
<td style="text-align:right">1010</td>
<td style="text-align:right">10</td>
</tr>
<tr>
<td style="text-align:right">B</td>
<td style="text-align:right">1011</td>
<td style="text-align:right">11</td>
</tr>
<tr>
<td style="text-align:right">C</td>
<td style="text-align:right">1100</td>
<td style="text-align:right">12</td>
</tr>
<tr>
<td style="text-align:right">D</td>
<td style="text-align:right">1101</td>
<td style="text-align:right">13</td>
</tr>
<tr>
<td style="text-align:right">E</td>
<td style="text-align:right">1110</td>
<td style="text-align:right">14</td>
</tr>
<tr>
<td style="text-align:right">F</td>
<td style="text-align:right">1111</td>
<td style="text-align:right">15</td>
</tr>
</tbody>
</table>
<h3 id="Java的特点">Java的特点</h3><p><strong>简单的(simple)、面向对象的(object-oriented)、分布式的(distributed)、解释性的(interpreted)、健壮的(robust)、安全的(secure)、结构中立的(architecture-neutral)、可移植的(portable)、高效的(high-performance)、多线程的(multithreaded)、动态的(dynamic)。</strong></p>
<h3 id="Java的编译和运行">Java的编译和运行</h3><ul>
<li>编译：cmd下使用javac命令进行编译。</li>
<li>运行：cmd下使用java命令运行。</li>
</ul>
<p>在使用cmd编译运行java程序时，需要注意如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"helloWorld"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果程序中含有包名，使用<code>java test</code>运行时会出现<strong>找不到或无法加载主类 test</strong>，解决这个问题有如下几种方法：</p>
<ul>
<li>方法一： 在编译路径下新建名为test的文件夹，然后将test.class文件拖入该文件夹，在编译路径下使用<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="keyword">test</span>.<span class="keyword">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行程序。<br>比如路径是 <code>C:\Users\ht\Desktop&gt;</code> ,在此路径下我使用了 <code>javac test.java</code>进行了编译，那么这路径就是编译路径，为了成功运行上面的程序，我需要新建一个test文件夹，其路径为<code>C:\Users\ht\Desktop\test</code>，再将test.class文件拖到test文件夹内，然后在<code>C:\Users\ht\Desktop&gt;</code>下使用 <code>java test.test</code>运行。</p>
<ul>
<li>方法二： 使用 <code>javac -d&lt;目录&gt;</code> 方式自动创建class文件路径。同样是上面的例子，在<code>C:\Users\ht\Desktop&gt;</code>路径下，使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d \Users\ht\Desktop test.java</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译，然后使用<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="keyword">test</span>.<span class="keyword">test</span></span><br></pre></td></tr></table></figure></p>
<p>运行即可。</p>
<ul>
<li>方法三： 使用集成开发环境即可避免这类问题。这里推荐<a href="http://www.jetbrains.com/idea/" target="_blank" rel="external">Intellij IDEA</a>。<br><strong>建议初学者先使用cmd进行java的学习，这样可以理解一些基础性的东西，比如上面的问题，其实就是java的classpath的问题，如果懂java编译时如何对class文件定位，解决上述问题就很简单了。</strong></li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>第一章是对Java这门语言的概述，需要了解关键字、类和方法的命名方式、Java程序的编译运行等东西。</li>
<li>Java提供了专门的Math类来处理进制转换。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><p>（略）</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>本章简单介绍了计算机和Java有关的知识，让人有初步了解]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java学习笔记--排序的几种写法]]></title>
    <link href="http://www.whtis.com/2015/12/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/"/>
    <id>http://www.whtis.com/2015/12/03/java学习笔记-排序的几种写法/</id>
    <published>2015-12-03T12:00:08.000Z</published>
    <updated>2016-01-10T13:37:36.579Z</updated>
    <content type="html"><![CDATA[<p>最近学到数组这章，最重要的就是对数组中的元素进行排序。总结一下排序的几种写法。<br><em>java.util.array类中提供了排序的重载方法，可以直接调用相关方法进行排序，详见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#sort-byte:A-" target="_blank" rel="external">API</a></em></p>
<ul>
<li><p>选择排序</p>
<ul>
<li><p>写法一：遍历数组，找到数组中最大的元素，与数组最后的元素进行交换。如此进行n次，数组中的元素就按照升序排列完成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lists.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">double</span> max = lists[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (max &lt; lists[j]) &#123;</span><br><span class="line">                   max = lists[j];</span><br><span class="line">                   index = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//交换list[i]和max所在的list[index]的值</span></span><br><span class="line">           <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">               lists[index] = lists[i];</span><br><span class="line">               lists[i] = max;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写法二：写法一的递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">double</span>[] lists, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//length = lists.length -1</span></span><br><span class="line">       <span class="keyword">double</span> max = lists[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (max &lt; lists[i]) &#123;</span><br><span class="line">               max = lists[i];</span><br><span class="line">               index = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (index != length) &#123;</span><br><span class="line">           lists[index] = lists[length];</span><br><span class="line">           lists[length] = max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           length--;</span><br><span class="line">           selectionSort(lists, length);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写法三：写法一的改进，优点是升序和降序排列只需要简单的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = lists.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (lists[i] &gt; lists[j]) &#123;</span><br><span class="line">                   <span class="keyword">double</span> tmp = lists[i];</span><br><span class="line">                   lists[i] = lists[j];</span><br><span class="line">                   lists[j] = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong> 若要实现降序排列，只需将第三行的<code>&gt;</code>改为<code>&lt;</code>即可。</strong></p>
<ul>
<li>冒泡排序<br>冒泡排序又称为下沉排序，基本思想是在每次的遍历中，连续对相邻元素进行比较，以达到按照特定顺序排序的目的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> changed = <span class="keyword">true</span>;  <span class="comment">//用于控制数组遍历的次数（至多lists.length-1次）</span></span><br><span class="line">       do &#123;</span><br><span class="line">           changed = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (lists[i] &gt; lists[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                   <span class="keyword">double</span> tmp = lists[i];</span><br><span class="line">                   lists[i] = lists[i + <span class="number">1</span>];</span><br><span class="line">                   lists[i + <span class="number">1</span>] = tmp;</span><br><span class="line">                   changed = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (changed);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong> 若要实现降序排列，只需将第三行的<code>&gt;</code>改为<code>&lt;</code>即可。</strong></p>
<ul>
<li>插入排序<br>基本思路是在已排好序的子数列中反复插入一个未排序的元素，直到整个数列全部排好。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">           <span class="keyword">double</span> currentElement = lists[i];</span><br><span class="line">           <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; lists[k] &gt; currentElement) &#123;</span><br><span class="line">               <span class="keyword">double</span> tmp = lists[k + <span class="number">1</span>];</span><br><span class="line">               lists[k + <span class="number">1</span>] = lists[k];</span><br><span class="line">               lists[k] = tmp;</span><br><span class="line">               k--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>最近学到数组这章，最重要的就是对数组中的元素进行排序。总结一下排序的几种写法。<br><em>java.util.array类中提供了排序的重载方法，可以直接调用相关方法进行排序，详见<a href="http://docs.oracle.com/javase/8/docs]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="java学习笔记" scheme="http://www.whtis.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习笔记--三个整数进行比较大小的三种方法]]></title>
    <link href="http://www.whtis.com/2015/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%E4%B8%AA%E6%95%B4%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2015/11/13/Java学习笔记-三个整数进行比较大小的三种方法/</id>
    <published>2015-11-13T12:43:59.000Z</published>
    <updated>2016-01-10T13:37:28.926Z</updated>
    <content type="html"><![CDATA[<ul>
<li>对abc三个整数从小到大进行排序，有以下几种方法：</li>
</ul>
<ul>
<li>方法一：首先对a和b进行比较排序，使得<code>a&lt;=b</code>,再对b和c排序，使得<code>b&lt;=c</code>，最后再对a和b进行比较，就可以得到正确的顺序了。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $3<span class="title">_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = Integer.parseInt(JOptionPane.showInputDialog(<span class="keyword">null</span>, <span class="string">"请输入一个整数："</span>));</span><br><span class="line">        <span class="keyword">int</span> b = Integer.parseInt(JOptionPane.showInputDialog(<span class="keyword">null</span>, <span class="string">"请输入一个整数："</span>));</span><br><span class="line">        <span class="keyword">int</span> c = Integer.parseInt(JOptionPane.showInputDialog(<span class="keyword">null</span>, <span class="string">"请输入一个整数："</span>));</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">            tmp = b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= c) &#123;</span><br><span class="line">            tmp = c;</span><br><span class="line">            c = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">            tmp = b;</span><br><span class="line">            b = a;</span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"the order is "</span> + a + <span class="string">" "</span> + b + <span class="string">" "</span> + c);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：使用嵌套的if循环，讨论当<code>a&gt;=b</code>以及<code>a&lt;b</code>的情况。代码如下：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">$3_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        int a = <span class="type">Integer</span>.parseInt(<span class="type">JOptionPane</span>.showInputDialog(null, <span class="string">"请输入一个整数："</span>));</span><br><span class="line">        int b = <span class="type">Integer</span>.parseInt(<span class="type">JOptionPane</span>.showInputDialog(null, <span class="string">"请输入一个整数："</span>));</span><br><span class="line">        int <span class="built_in">c</span> = <span class="type">Integer</span>.parseInt(<span class="type">JOptionPane</span>.showInputDialog(null, <span class="string">"请输入一个整数："</span>));</span><br><span class="line">        int tmp;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= <span class="built_in">c</span>) &#123;</span><br><span class="line">                <span class="comment">//c&lt;=b&lt;=a</span></span><br><span class="line">                tmp = a;</span><br><span class="line">                a = <span class="built_in">c</span>;</span><br><span class="line">                <span class="built_in">c</span> = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= <span class="built_in">c</span>) &#123;</span><br><span class="line">                    <span class="comment">//b&lt;=c&lt;=a</span></span><br><span class="line">                    tmp = a;</span><br><span class="line">                    a = b;</span><br><span class="line">                    b = <span class="built_in">c</span>;</span><br><span class="line">                    <span class="built_in">c</span> = tmp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//b&lt;=a&lt;=c</span></span><br><span class="line">                    tmp = b;</span><br><span class="line">                    b = a;</span><br><span class="line">                    a = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= <span class="built_in">c</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;= <span class="built_in">c</span>) &#123;</span><br><span class="line">                    <span class="comment">//a&lt;=c&lt;=b</span></span><br><span class="line">                    tmp = <span class="built_in">c</span>;</span><br><span class="line">                    <span class="built_in">c</span> = b;</span><br><span class="line">                    b = tmp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//c&lt;=a&lt;=b</span></span><br><span class="line">                    tmp = b;</span><br><span class="line">                    b = a;</span><br><span class="line">                    a = <span class="built_in">c</span>;</span><br><span class="line">                    <span class="built_in">c</span> = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"the order is "</span> + a + <span class="string">" "</span> + b + <span class="string">" "</span> + <span class="built_in">c</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法三：使用三个boolean类型的值表示<code>a&gt;=b</code>、<code>b&gt;=c</code>、<code>a&gt;=c</code>,并分别进行讨论。八种情况中有两种不成立，故舍去。代码如下：</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> public class <span class="number">$3</span>_2 &#123;</span><br><span class="line">    public static void main(<span class="keyword">String[] </span>args) &#123;</span><br><span class="line">        int a = Integer.parseInt(JOptionPane.showInputDialog(null, <span class="string">"请输入一个整数："</span>))<span class="comment">;</span></span><br><span class="line">        int <span class="keyword">b </span>= Integer.parseInt(JOptionPane.showInputDialog(null, <span class="string">"请输入一个整数："</span>))<span class="comment">;</span></span><br><span class="line">        int c = Integer.parseInt(JOptionPane.showInputDialog(null, <span class="string">"请输入一个整数："</span>))<span class="comment">;</span></span><br><span class="line">        int tmp<span class="comment">;</span></span><br><span class="line">        <span class="keyword">boolean </span><span class="keyword">b1 </span>= a &gt;= <span class="keyword">b;</span><br><span class="line"></span>        <span class="keyword">boolean </span><span class="keyword">b2 </span>= a &gt;= c<span class="comment">;</span></span><br><span class="line">        <span class="keyword">boolean </span><span class="keyword">b3 </span>= <span class="keyword">b </span>&gt;= c<span class="comment">;</span></span><br><span class="line">         <span class="preprocessor">if</span> (<span class="keyword">b1 </span>&amp;&amp; <span class="keyword">b2 </span>&amp;&amp; <span class="keyword">b3) </span>&#123;//<span class="keyword">b3多余 </span>c&lt;<span class="label">=b</span>&lt;<span class="label">=a</span></span><br><span class="line">            tmp = a<span class="comment">;</span></span><br><span class="line">            a = c<span class="comment">;</span></span><br><span class="line">            c = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="preprocessor">if</span> (<span class="keyword">b1 </span>&amp;&amp; <span class="keyword">b2 </span>&amp;&amp; !<span class="keyword">b3) </span>&#123; //<span class="keyword">b&lt;=c&lt;=a</span><br><span class="line"></span>            tmp = a<span class="comment">;</span></span><br><span class="line">            a = <span class="keyword">b;</span><br><span class="line"></span>            <span class="keyword">b </span>= c<span class="comment">;</span></span><br><span class="line">            c = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="preprocessor">if</span> (<span class="keyword">b1 </span>&amp;&amp; !<span class="keyword">b2 </span>&amp;&amp; !<span class="keyword">b3) </span>&#123; //<span class="keyword">b&lt;=a&lt;=c</span><br><span class="line"></span>            tmp = <span class="keyword">b;</span><br><span class="line"></span>            <span class="keyword">b </span>= a<span class="comment">;</span></span><br><span class="line">            a = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="preprocessor">if</span> (!<span class="keyword">b1 </span>&amp;&amp; <span class="keyword">b2 </span>&amp;&amp; <span class="keyword">b3) </span>&#123; //c&lt;<span class="label">=a</span>&lt;<span class="label">=b</span></span><br><span class="line">            tmp = c<span class="comment">;</span></span><br><span class="line">            c = <span class="keyword">b;</span><br><span class="line"></span>            <span class="keyword">b </span>= a<span class="comment">;</span></span><br><span class="line">            a = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="preprocessor">if</span> (!<span class="keyword">b1 </span>&amp;&amp; !<span class="keyword">b2 </span>&amp;&amp; <span class="keyword">b3) </span>&#123; //a&lt;<span class="label">=c</span>&lt;<span class="label">=b</span></span><br><span class="line">            tmp = <span class="keyword">b;</span><br><span class="line"></span>            <span class="keyword">b </span>= c<span class="comment">;</span></span><br><span class="line">            c = tmp<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="preprocessor">if</span> (!<span class="keyword">b1 </span>&amp;&amp; !<span class="keyword">b2 </span>&amp;&amp; !<span class="keyword">b3) </span>&#123; //a&lt;<span class="label">=b</span>&lt;<span class="label">=c</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"the order is "</span> + a + <span class="string">" "</span> + <span class="keyword">b </span>+ <span class="string">" "</span> + c)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>对abc三个整数从小到大进行排序，有以下几种方法：</li>
</ul>
<ul>
<li>方法一：首先对a和b进行比较排序，使得<code>a&lt;=b</code>,再对b和c排序，使得<code>b&lt;=c</code>，最后再对a和b进行比较，就可]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="java学习笔记" scheme="http://www.whtis.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习笔记--double类型的值保留指定小数位的几种方法]]></title>
    <link href="http://www.whtis.com/2015/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-double%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BF%9D%E7%95%99%E6%8C%87%E5%AE%9A%E5%B0%8F%E6%95%B0%E4%BD%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2015/11/13/Java学习笔记-double类型的值保留指定小数位的几种方法/</id>
    <published>2015-11-13T04:56:43.000Z</published>
    <updated>2016-01-10T13:37:43.592Z</updated>
    <content type="html"><![CDATA[<p>在java语言中，double类型的变量使用64bit存储空间进行存储。两个double类型的变量进行除法运算时，如果小数位过多，就需要进行保留位数操作。保留位数操作分为<code>四舍五入</code>型和<code>非四舍五入</code>型两种。本文以保留两位数为例：</p>
<ul>
<li>四舍五入型<br>使用java.text类中的<code>DecimalFormat（）</code>方法可以对double类型的值进行保留位数操作。代码如下：</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> y =<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> z = x / y;</span><br><span class="line">        DecimalFormat decimalFormat = <span class="keyword">new</span> DecimalFormat(<span class="string">"####.##"</span>);</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = decimalFormat.format(z);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> <code>DecimalFormat</code>的<code>serRoundMode（）</code>方法，可以智能的设置小数位的处理方法，详见<a href="http://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html" target="_blank" rel="external">API</a> </strong></p>
<ul>
<li>非四舍五入型<ul>
<li>方法一：使用String类的<code>valueOf()</code>方法将double类型的值转变成String类型，之后使用<code>indexOf()</code>方法，确定小数点的位置，取此位置之后两位的substring即可。代码如下：</li>
</ul>
</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> class test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> y =<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> z = x / y;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">String</span>.valueOf(z);</span><br><span class="line">        <span class="built_in">int</span> situation = <span class="built_in">str</span>.indexOf(<span class="string">"."</span>);   <span class="comment">//查找小数点的位置并将其值赋给situation</span></span><br><span class="line">        <span class="built_in">str</span> = <span class="built_in">str</span>.substring(<span class="number">0</span>, situation + <span class="number">3</span>);</span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：先使double类型的值乘以100，之后转变成int类型再除以100.00，得到包含两位小数的double值。代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> y =<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> z = x / y;</span><br><span class="line">        z = (<span class="keyword">int</span>) (z * <span class="number">100</span>)/<span class="number">100.00</span>;</span><br><span class="line">       System.out.println(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>在java语言中，double类型的变量使用64bit存储空间进行存储。两个double类型的变量进行除法运算时，如果小数位过多，就需要进行保留位数操作。保留位数操作分为<code>四舍五入</code>型和<code>非四舍五入</code>型两种。本文以保留两位数为例：]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="java学习笔记" scheme="http://www.whtis.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo 3.x同时部署到github和gitcafe的方法]]></title>
    <link href="http://www.whtis.com/2015/11/03/hexo-3-x%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%92%8Cgitcafe%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2015/11/03/hexo-3-x同时部署到github和gitcafe的方法/</id>
    <published>2015-11-03T03:24:55.000Z</published>
    <updated>2016-01-10T13:35:57.572Z</updated>
    <content type="html"><![CDATA[<p>详细的hexo博客搭建教程可以参考<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">这里</a></p>
<p>在我按照教程搭建博客的过程中，无意中看到了可以同时将博客部署到<code>github</code>和<code>gitcafe</code>上，以提高国内外的访问速度，具体操作过程可以参考<a href="http://opiece.me/2015/04/28/push-hexo-to-github-and-gitcafe/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">这里</a></p>
<p>当按照教程修改hexo的配置文件<code>_config.yml</code>后，第二个repo里并没有更新代码，经过查阅<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">官方文档</a>，<code>_config.yml</code>正确的配置如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:yourname/yourname.github.io.git,master</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@gitcafe</span>.<span class="attribute">com</span>:yourname/yourname.git,gitcafe-pages</span><br></pre></td></tr></table></figure>
<p>现在使用<code>hexo d</code>，应该就没问题了。</p>
<p><strong>注意，type前面的<code>-</code>不能省略。</strong></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>详细的hexo博客搭建教程可以参考<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">这里</a></p>
<p>在我按照教程搭建博客的过程中，无意中看]]>
    </summary>
    
      <category term="hexo" scheme="http://www.whtis.com/tags/hexo/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="hexo" scheme="http://www.whtis.com/categories/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ubuntu14.04本地安装wordpress中的一些问题总结]]></title>
    <link href="http://www.whtis.com/2015/10/29/ubuntu14-04%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85wordpress%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://www.whtis.com/2015/10/29/ubuntu14-04本地安装wordpress中的一些问题总结/</id>
    <published>2015-10-29T10:13:35.000Z</published>
    <updated>2016-01-20T11:23:03.961Z</updated>
    <content type="html"><![CDATA[<h1 id="1、安装apache2的问题">1、安装apache2的问题</h1><p>当我们使用如下语句安装apache2时：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install apache2</span><br></pre></td></tr></table></figure>
<p>会发现启动报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. <span class="operator"><span class="keyword">Set</span> the <span class="string">'ServerName'</span> directive <span class="keyword">globally</span> <span class="keyword">to</span> suppress this message</span><br><span class="line">                                                                         [ OK ]</span></span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>编辑<code>sudo nano /etc/apache2/apache2.conf</code>，在最后加上</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"><span class="common">ServerName</span></span> localhost：80</span><br></pre></td></tr></table></figure>
<p>再试试，apache2服务器就可以正常启动了。</p>
<p><em><strong>请注意：apache2的默认配置文件不再是apache的httpd，而是apache2的apache2.conf</strong></em></p>
<h1 id="2、安装wordpress时需要注意的问题">2、安装wordpress时需要注意的问题</h1><p>wordpress的下载以及配置，需要注意的只有一点：</p>
<p><em>wordpress的默认根目录是 <strong>/var/www/html</strong> ，而不是 <strong>/var/www</strong></em></p>
<p>因此，假如你想通过localhost访问时，你的目录结构应该是 <strong>/var/www/html/*</strong>，同理，如果你要通过localhost/wordpress访问时，你的目录结构应该是 <strong>/var/www/html/wordpress/*</strong></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><span id="busuanzi_container_page_pv">文章已被阅读<span id="busuanzi_value_page_pv"></span>次</span><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1、安装apache2的问题">1、安装apache2的问题</h1><p>当我们使用如下语句安装apache2时：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter">]]>
    </summary>
    
      <category term="apache2" scheme="http://www.whtis.com/tags/apache2/"/>
    
      <category term="ubuntu" scheme="http://www.whtis.com/tags/ubuntu/"/>
    
      <category term="wordpress" scheme="http://www.whtis.com/tags/wordpress/"/>
    
      <category term="收集整理" scheme="http://www.whtis.com/tags/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="wordpress" scheme="http://www.whtis.com/categories/wordpress/"/>
    
  </entry>
  
</feed>
