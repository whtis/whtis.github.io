<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[whtis's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.whtis.com/"/>
  <updated>2017-10-13T07:12:08.006Z</updated>
  <id>http://www.whtis.com/</id>
  
  <author>
    <name><![CDATA[whtis]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[spring4学习笔记（四）--Spring-4.x新特性：泛型依赖注入]]></title>
    <link href="http://www.whtis.com/2017/10/13/spring4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89--Spring-4-x%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E6%B3%9B%E5%9E%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://www.whtis.com/2017/10/13/spring4学习笔记（四）--Spring-4-x新特性：泛型依赖注入/</id>
    <published>2017-10-13T07:09:57.000Z</published>
    <updated>2017-10-13T07:12:08.006Z</updated>
    <content type="html"><![CDATA[<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.b]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="spring4" scheme="http://www.whtis.com/tags/spring4/"/>
    
      <category term="java web" scheme="http://www.whtis.com/categories/java-web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring4学习笔记（三）--SpEL:Spring表达式语言]]></title>
    <link href="http://www.whtis.com/2017/10/13/spring4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89--SpEL-Spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80/"/>
    <id>http://www.whtis.com/2017/10/13/spring4学习笔记（三）--SpEL-Spring表达式语言/</id>
    <published>2017-10-13T07:03:21.000Z</published>
    <updated>2017-10-13T07:39:54.225Z</updated>
    <content type="html"><![CDATA[<h2 id="spEL:Spring_表达式语言">spEL:Spring 表达式语言</h2><ul>
<li>是一个支持运行时查询和操作对象图的强大的表达式语言。</li>
<li>语法类似于EL：SpEL使用<code>#{...}</code>作为定界符，所有在大框号中的字符都将被认为是<code>SpEL</code></li>
<li>SpEL为Bean的属性进行动态赋值提供了便利。</li>
<li>通过SpEL可以实现：<ul>
<li>通过 bean 的 <code>id</code> 对 bean 进行引用</li>
<li>调用方法以及引用对象中的属性</li>
<li>计算表达式的值</li>
<li>正则表达式的匹配</li>
</ul>
</li>
</ul>
<h3 id="SpEL_可以表示基本的字面值">SpEL 可以表示基本的字面值</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</div><div class="line">  &lt;property name=&quot;user&quot; value=&quot;#&#123;2&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">  &lt;property name=&quot;password&quot; value=&quot;#&#123;3.14&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">  &lt;property name=&quot;driverClass&quot; value=&quot;#&#123;false&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">  &lt;property name=&quot;jdbcUrl&quot; value=&quot;#&#123;“whtis”&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h3 id="SpEL_引用_bean、属性和方法">SpEL 引用 bean、属性和方法</h3><ul>
<li>引用其他对象：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过 value 属性和 SpEL 配置 bean 之间的应用关系 --&gt;</div><div class="line">&lt;property name=&quot;prefix&quot; value=&quot;#&#123;prefixGenerator&#125;&quot;&gt;&lt;/property&gt;</div></pre></td></tr></table></figure>
<ul>
<li>引用其他对象的属性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过 value 属性和 SpEL 配置 bean 之间的应用关系 --&gt;</div><div class="line">&lt;property name=&quot;suffix&quot; value=&quot;#&#123;sequenceGenerator2.suffix&#125;&quot;&gt;&lt;/property&gt;</div></pre></td></tr></table></figure>
<ul>
<li>调用其他方法，还可以链式操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过 value 属性和 SpEL 配置 suffix 属性值为另一个 bean 的方法的返回值 --&gt;</div><div class="line">&lt;property name=&quot;suffix&quot; value=&quot;#&#123;sequenceGenerator2.toString()&#125;&quot;&gt;&lt;/property&gt;</div></pre></td></tr></table></figure>
<ul>
<li>调用静态方法或静态属性：通过<code>T()</code>调用一个类的静态方法，它将返回一个 <code>Class Object</code>，然后再调用相应的方法或属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;initValue&quot; value=#&#123;T(java.lang.Math).PI&#125;&gt;&lt;/property&gt;</div></pre></td></tr></table></figure>
<h3 id="SpEL支持的运算符号">SpEL支持的运算符号</h3><ul>
<li>算数运算符：<code>+，-，×，/，%，^</code></li>
<li>加号还可以用作字符串连接</li>
<li>比较运算符：<code>&lt;，&gt;，==，&lt;=，&gt;=，lt，gt，eq，le，ge</code></li>
<li>逻辑运算符：<code>and，or，not，|</code></li>
<li>if-else运算符：<code>?:(temary),?:(Elvis)</code></li>
<li>if-else的变体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;constructor-arg value=&quot;#&#123;kenny.song:&apos;Greensleeves&apos;&#125;&quot;</div></pre></td></tr></table></figure>
<ul>
<li>正则表达式：<code>matches</code></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="spEL:Spring_表达式语言">spEL:Spring 表达式语言</h2><ul>
<li>是一个支持运行时查询和操作对象图的强大的表达式语言。</li>
<li>语法类似于EL：SpEL使用<code>#{...}</code>作为定界符，所有在大框号中]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="spring4" scheme="http://www.whtis.com/tags/spring4/"/>
    
      <category term="java web" scheme="http://www.whtis.com/categories/java-web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring4学习笔记（二）--spring中Bean的配置]]></title>
    <link href="http://www.whtis.com/2017/10/13/spring4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89--spring%E4%B8%ADBean%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.whtis.com/2017/10/13/spring4学习笔记（二）--spring中Bean的配置/</id>
    <published>2017-10-13T03:54:06.000Z</published>
    <updated>2017-10-18T12:21:44.251Z</updated>
    <content type="html"><![CDATA[<h1 id="配置形式">配置形式</h1><h2 id="基于xml文件的方式">基于xml文件的方式</h2><h3 id="Bean的配置方式">Bean的配置方式</h3><h4 id="通过全类名（反射）">通过全类名（反射）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!--</div><div class="line">  通过全类名配置bean</div><div class="line">  class：bean 的全类名，通过反射的方式在 IOC 容器中创建 Bean。所以要求 Bean 中必须有无参数的构造器。</div><div class="line">  id： 表示容器中的Bean，唯一。</div><div class="line">  &lt;Bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/Bean&gt;</div><div class="line"> --&gt;</div></pre></td></tr></table></figure>
<h4 id="依赖注入的方式">依赖注入的方式</h4><h5 id="构造器注入">构造器注入</h5><ul>
<li>通过构造方法注入 Bean 的属性值或依赖的对象，它保证了 Bean 实例在实例化后就可以使用。</li>
<li>构造器注入在<code>&lt;constructor-arg&gt;</code>元素里声明属性，该元素没有<code>name</code>属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过构造方法来配置 Bean 属性 --&gt;</div><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; &gt;</div><div class="line">  &lt;!-- 使用构造器注入属性值可以指定参数的位置和参数的类型！ 以区分重载的构造器！--&gt;</div><div class="line">  &lt;constructor-arg value=&quot;&quot; (type=&quot;&quot; or index=&quot;&quot;) &gt;&lt;/constructor-arg&gt;</div><div class="line">  &lt;constructor-arg&gt;</div><div class="line">    &lt;!-- 字面值注入，基本数据类型及其封装类、String等类型都可以采取字面值注入的方式 --&gt;</div><div class="line">    &lt;value&gt;250&lt;/value&gt;</div><div class="line">    &lt;!-- 如果字面值包含特殊字符可以使用&lt;![CDATA[]]&gt;包裹起来 --&gt;</div><div class="line">    &lt;&gt;&lt;![CDATA[&lt;beijing&gt;]]&gt;&lt;&gt;</div><div class="line">  &lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h5 id="属性注入">属性注入</h5><ul>
<li>属性注入即通过<code>setter</code>方法注入Bean的属性值或依赖的对象</li>
<li>属性注入使用 <code>&lt;property&gt;</code>元素，使用<code>name</code>属性指定 Bean 的属性名称，<code>value</code> 属性或<code>&lt;value&gt;</code> 子节点指定属性值。</li>
<li>属性注入是实际应用中最常用的注入方式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过全类名的方式来配置 bean --&gt;</div><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; &gt;</div><div class="line">  &lt;property name=&quot;&quot; value=&quot;&quot; &gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h6 id="引用其他_Bean">引用其他 Bean</h6><ul>
<li>在 Bean 的配置文件中，可以通过<code>&lt;ref&gt;</code>元素或者<code>ref</code>属性为Bean的属性或构造器参数指定对Bean的引用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</div><div class="line">  &lt;property name=&quot;&quot; value=&quot;&quot; ref=&quot;&quot;&gt;&lt;/property&gt;</div><div class="line">  &lt;!--</div><div class="line">    &lt;property name=&quot;&quot; value=&quot;&quot; &gt;</div><div class="line">      &lt;ref bean=&quot;&quot;/&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">   --&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ul>
<li>也可以在属性或构造器里包含Bean的声明，这样的Bean称为内部Bean</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</div><div class="line">  &lt;property name=&quot;&quot; &gt;</div><div class="line">  &lt;!-- 内部 Bean，不能被外部引用，只能内部使用 --&gt;</div><div class="line">    &lt;bean class=&quot;&quot; &gt;</div><div class="line">      &lt;constructor-arg value=&quot;&quot; &gt;&lt;/constructor-arg&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">  &lt;/property&gt;  </div><div class="line">&lt;/bean&gt;</div><div class="line">//构造器注入类似</div></pre></td></tr></table></figure>
<h6 id="注入参数详解：null和级联属性">注入参数详解：null和级联属性</h6><ul>
<li>赋<code>null</code>值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;</div></pre></td></tr></table></figure>
<ul>
<li>级联属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 为级联属性赋值。注意：属性（car）需要先初始化才能为级联属性赋值，否则会出错 --&gt;</div><div class="line">&lt;property name=&quot;car.maxPrice&quot; value=&quot;&quot;&gt;&lt;/property&gt;</div></pre></td></tr></table></figure>
<h6 id="集合属性">集合属性</h6><ul>
<li>在Spring中可以通过一组内置的xml标签（<code>&lt;list&gt;、&lt;set&gt;、&lt;map&gt;</code>）来配置集合属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; &gt;</div><div class="line">  &lt;property name=&quot;list&quot;&gt;</div><div class="line">  &lt;!-- 使用list为list类型的成员变量--&gt;</div><div class="line">    &lt;list value=&quot;&quot;&gt;</div><div class="line">      &lt;ref bean=&quot;&quot;/&gt;</div><div class="line">    &lt;/list&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">//set类似</div><div class="line"></div><div class="line">&lt;!-- 配置map属性值 --&gt;</div><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; &gt;</div><div class="line">  &lt;property name=&quot;map&quot;&gt;</div><div class="line">  &lt;!-- 使用map节点及 map 的 entry 子节点配置 Map类型的成员变量 --&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">      &lt;entry key=&quot;&quot; value=&quot;&quot;&gt;&lt;/entry&gt;</div><div class="line">    &lt;/map&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>&lt;props&gt;</code>定义<code>java.util.Properties</code>，该标签使用多个<code>&lt;prop&gt;</code>作为子标签，每个<code>&lt;prop&gt;</code>标签必须定义<code>key</code>属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置properties属性值 --&gt;</div><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; &gt;</div><div class="line">  &lt;property name=&quot;properties&quot;&gt;</div><div class="line">  &lt;!-- 使用props节点及 props 的 prop 子节点配置 props 类型的成员变量 --&gt;</div><div class="line">    &lt;props&gt;</div><div class="line">      &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt;</div><div class="line">      &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;</div><div class="line">      &lt;prop key=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/prop&gt;</div><div class="line">      &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;</div><div class="line">    &lt;/props&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>utility scheme</code>定义集合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置独立的集合 bean，以供多个 bean 使用，需要引入util命名空间 --&gt;</div><div class="line">&lt;util:list id=&quot;list&quot;&gt;</div><div class="line">    &lt;ref bean=&quot;&quot;/&gt;</div><div class="line">&lt;/util:list&gt;</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>p</code>命名空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过p命名空间为 bean 的属性赋值，需要先导入 p 命名空间，相对于传统的配置方法，较简捷 --&gt;</div><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; p:xxx=&quot;&quot; p:zzz-ref=&quot;&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h6 id="使用外部属性文件">使用外部属性文件</h6><ul>
<li>在配置文件里配置 Bean 时，有时需要在Bean的配置里混入<strong>系统部署的细节信息</strong>（例如：文件路径，数据源配置信息等）。而这些部署细节实际上需要和Bean配置分离。</li>
<li>Spring提供了一个<code>PropertyPlaceholderConfigurer</code>的<code>BeanFactory后置处理器</code>，这个处理器允许用户将Bean配置的部分内容外移到<code>属性文件</code>中。可以在Bean配置文件里使用形式为<code>${var}</code>的变量，<code>PropertyPlaceholderConfigurer</code>从属性文件里加载属性，并使用这些属性来替换变量。</li>
<li><p>Spring还允许在属性文件中使用<code>${propName}</code>，以实现属性之间的相互引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 导入属性文件 --&gt;</div><div class="line">&lt;context:property-placeholder location=&quot;classpath&quot;db.properties&quot;/&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</div><div class="line">  &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">  &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driverClass&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">  &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbcUrl&#125;&quot;&gt;&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="工厂方法注入（不常用）">工厂方法注入（不常用）</h5><h4 id="通过工厂方法（静态工厂方法&amp;实例工厂方法）">通过工厂方法（静态工厂方法&amp;实例工厂方法）</h4><h5 id="通过调用静态工厂方法创建Bean">通过调用静态工厂方法创建Bean</h5><ul>
<li>调用静态工厂方法创建Bean是将<code>对象创建的过程封装到静态方法中</code>。当客户端需要对象时，只需要简单地调用静态方法，而不关心创建对象的细节。</li>
<li>要声明通过静态方法创建的Bean，需要在Bean的<code>class</code>属性里指定拥有该工厂的方法的类，同时在<code>factory-method</code>属性里指定工厂方法的名称。最后，使用<code>&lt;constructor-arg&gt;</code>元素为该方法传递方法参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过静态工厂方法来配置 Bean. 注意不是配置静态工厂方法实例，而是配置 bean 实例 --&gt;</div><div class="line">&lt;!--</div><div class="line">    class 属性： 指向静态方法的全类名</div><div class="line">    factory-method: 指向静态工厂方法的名字</div><div class="line">    constructor-arg：如果工厂方法需要传入参数，则使用constructor-arg 来配置参数</div><div class="line"> --&gt;</div><div class="line">&lt;bean id=&quot;&quot; class=&quot;StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;</div><div class="line">  &lt;constructor-arg value=&quot;xxx&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>相应的静态类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticCarFactory &#123;</div><div class="line"></div><div class="line">    static Map&lt;String, Car&gt; carMap = new HashMap();</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        carMap.put(&quot;Audi&quot;, new Car(&quot;Audi&quot;,&quot;300000&quot;));</div><div class="line">        carMap.put(&quot;Ford&quot;, new Car(&quot;Ford&quot;, &quot;400000&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Car getCar(String name) &#123;</div><div class="line">        return carMap.get(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="通过调用实例工厂方法创建Bean">通过调用实例工厂方法创建Bean</h5><ul>
<li>实例工厂方法：<code>将对象的创建过程封装到另外一个对象实例的方法里</code>。当客户端需要请求对象时，只需要简单的调用该实例方法而不需要关心对象的创建细节。</li>
<li>要声明通过实例实例工厂方法创建的Bean<ul>
<li>在bean的<code>factory-bean</code>属性里指定拥有该工厂方法的Bean</li>
<li>在<code>factory-method</code>属性里指定该工厂方法的名称</li>
<li>使用<code>constructor-arg</code>元素为工厂方法传递方法参数</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 配置工厂的实例 --&gt;</div><div class="line">&lt;bean id=&quot;carFactory&quot; class=&quot;InstanceCarFactory&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;!-- 通过实例工厂方法来配置 bean --&gt;</div><div class="line">&lt;!--</div><div class="line">    class 属性： 指向实例方法的 bean</div><div class="line">    factory-method: 指向实例工厂方法的名字</div><div class="line">    constructor-arg：如果工厂方法需要传入参数，则使用constructor-arg 来配置参数</div><div class="line"> --&gt;</div><div class="line">&lt;bean id=&quot;&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot;&gt;</div><div class="line">    &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>相应的实例类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class InstanceCarFactory &#123;</div><div class="line"></div><div class="line">    private Map&lt;String, Car&gt; map = null;</div><div class="line"></div><div class="line">    public InstanceCarFactory() &#123;</div><div class="line">        map = new HashMap&lt;String, Car&gt;();</div><div class="line">        map.put(&quot;Audi&quot;, new Car(&quot;Audi&quot;, &quot;300000&quot;));</div><div class="line">        map.put(&quot;Ford&quot;, new Car(&quot;Ford&quot;, &quot;400000&quot;));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Car getCar(String name) &#123;</div><div class="line">        return map.get(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="FactoryBean">FactoryBean</h4><h4 id="Spring_bean自动装配（装配引用）">Spring bean自动装配（装配引用）</h4><ul>
<li><p>spring IOC容器可以自动装配bean，需要做的仅仅是在<code>&lt;bean&gt;</code>的autowire属性里指定自动装配的模式。</p>
<ul>
<li><code>byType</code>：根据bean的类型和当前bean的属性的类型尽心自动装配。若 IOC 容器中有1个以上的类型匹配的bean，则抛异常。</li>
<li><code>byName</code>：根据bean的名字和当前bean的setter风格的属性名进行自动装配，若有匹配的，则进行自动装配，若没有匹配的，则不装配</li>
<li><code>constructor</code>：不推荐使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在Bean配置文件里设置<code>autowire</code>属性进行自动装配将会装配Bean的所有属性。然而，若只希望装配个别属性时，<code>autowire</code>就不够灵活了。</p>
</li>
<li><code>autowire</code>属性只能选择一种进行配置</li>
<li>一般情况下不建议使用自动装配功能</li>
</ul>
<h4 id="bean_之间的关系：继承；依赖">bean 之间的关系：继承；依赖</h4><h5 id="bean_的继承">bean 的继承</h5><ul>
<li>Spring允许继承bean的配置，被继承的bean称为<code>父bean</code>，继承这个父bean的bean称为<code>子bean</code></li>
<li>子bean从父bean中继承配置，包括bean的属性配置</li>
<li>子bean也可以覆盖从父bean中继承过来的配置</li>
<li>父bean可以作为配置模板，也可以作为Bean实例，若只想把父bean作为模板，可以设置<code>&lt;bean&gt;</code>的<code>abstract</code>属性为<code>true</code>，这样Spring将不会实例化这个Bean</li>
<li>并不是<code>&lt;bean&gt;</code>元素里的所有属性都会被继承，比如：<code>autowire</code>、<code>abstract</code>等</li>
<li>也可以忽略父Bean的class属性，让子bean指定自己的类，而共享相同的属性配置。但此时<strong>abstract必须设置为true</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- bean 配置的继承：使用 bean 的 parent 属性指定哪个 bean 的配置 --&gt;</div><div class="line">&lt;bean id=&quot;&quot; parent=&quot;&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;!-- 抽象bean： bean 的 abstract 属性为 true 的bean。这样的 bean 不能被 IOC 容器实例化，只能用来被继承设置</div><div class="line">若某一个 bean 的 class 属性没有被指定，则该 bean 必须是一个抽象 bean --&gt;</div><div class="line">&lt;bean id=&quot;&quot; abstract=&quot;&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h5 id="bean_的依赖">bean 的依赖</h5><ul>
<li>Spring 允许用户通过<code>depends-on</code>属性设定Bean前置依赖的Bean，前置依赖的Bean会在本Bean实例化之前创建好。</li>
<li>如果前置依赖于多个Bean，则可以通过逗号，空格、或的方式配置Bean的名称。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; depends-on=“”&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h5 id="bean的作用域：singleton；prototype；WEB_环境作用域">bean的作用域：singleton；prototype；WEB 环境作用域</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!--</div><div class="line">  使用 bean 的 scope 属性来配置 bean 的作用域</div><div class="line">  singleton: 默认值。容器初始时创建 bean 的实例，在整个容器的生命周期内只创建这一个 bean。单例的。</div><div class="line">  prototype： 原型的。容器初始化时不创建 bean 的实例。而在每次请求时都创建一个新的 Bean 实例，并返回。</div><div class="line"> --&gt;</div><div class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h2 id="基于注解的方式">基于注解的方式</h2><h3 id="基于注解配置_Bean">基于注解配置 Bean</h3><h4 id="在_classpath_中扫描组件">在 classpath 中扫描组件</h4><ul>
<li>组件扫描：Spring 能够从<code>classpath</code>下自动扫描，侦测和实例化具有特定注解的组件。</li>
<li>特定组件包括：<ul>
<li><code>@Component</code>：基本注解，标识了一个受 Spring 管理的组件</li>
<li><code>@Respository</code>：标识持久层组件</li>
<li><code>@Service</code>：标识服务层（业务层）组件</li>
<li><code>@Controller</code>：标识表现层组件<br><strong>以上均为建议标识内容</strong></li>
</ul>
</li>
<li>对于扫描到的组件，Spring有<code>默认的命名策略</code>：使用非限定类名，第一个字母小写。<code>也可以在注解中通过value属性值标识组件的名称</code>。</li>
<li><p>当在组件类上使用了特定的注解之后，还需要在Spring的配置文件中声明：<code>&lt;context:component-scan&gt;</code>:</p>
<ul>
<li>base-package 属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包里及其子包中的所有类。</li>
<li>当需要扫描多个包时，可以使用逗号分隔。</li>
<li>如果仅希望扫描特定的类而非基包下的所有类，可使用<code>resource-pattern</code>属性过滤特定的类，示例：</li>
<li><code>use-default-filters</code>属性指定是否使用默认的过滤策略。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;context:</div><div class="line">  component-scan base-package=&quot;com.whtis.spring.beans&quot;</div><div class="line">  resource-pattern=&quot;autowire/*.class&quot; use-default-filters=&quot;false&quot;&gt;</div><div class="line">&lt;/context:component-scan&gt;</div></pre></td></tr></table></figure>
<ul>
<li><code>&lt;context:include-filter&gt;</code> 子节点表示要包含的目标类</li>
<li><code>&lt;context:exclude-filter&gt;</code> 子节点表示要排除在外的目标类</li>
<li><code>&lt;context:component-scan&gt;</code> 下可以拥有若干个<code>&lt;context:include-filter&gt;</code>和<code>&lt;context:exclude-filter&gt;</code>子节点</li>
<li><code>&lt;context:include-filter&gt;</code>和<code>&lt;context:exclude-filter&gt;</code>子节点支持多种类型的过滤表达式：<ul>
<li><code>annotation</code>： 所有标注了<code>XxxAnnotation</code>的类。该类型采用目标类是否标注了某个注解进行过滤。</li>
<li><code>assinable</code>：所有继承或扩展<code>XxxService</code>的类。该类型采用目标类是否继承或扩展某个特定类进行过滤。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="组件装配">组件装配</h4><p>如果一个组件中包含其他组件，仅靠配置<code>classpath</code>会导致无法找到组件中的其他组件从而报<code>nullPointException</code>错误。</p>
<ul>
<li><code>&lt;context:component-scan&gt;</code>元素还会自动注册<code>AutowiredAnnotationBeanPostProcessor</code>实例，该实例可以自动装配具有<code>@Autowired</code>和<code>@Resource</code>、<code>@Inject</code>注解的属性。<ul>
<li><code>@Autowired</code>注解自动装配具有兼容类型的单个Bean属性<ul>
<li>构造器，普通字段（即使是非<code>public</code>），一切具有参数的方法都可以应用<code>@Autowired</code>注解。</li>
<li>默认情况下，所有使用<code>@Autowired</code>注解的属性都需要被设置。当<code>Spring</code>找不到匹配的Bean装配属性时，会抛出异常。<strong>若某一属性允许不被设置，可以设置@Autowired注解的<code>required</code>属性为<code>false</code>。</strong></li>
<li>默认情况下，当 IOC 容器里存在多个类型兼容的Bean时，通过类型的自动装配将无法工作。此时可以在<code>@Qualifier</code>注解里提供Bean的名称。Spring允许对方法的入参标注<code>@Qualifiter</code>以指定注入Bean的名称。</li>
<li><code>@Autowired</code> 注解也可以应用在<code>数组类型</code>的属性上，此时Spring将会把所有匹配的Bean进行自动装配</li>
<li><code>@Autowired</code> 注解也可以应用在<code>集合属性</code>上，此时Spring读取该集合的类型信息，然后自动装配所有与之兼容的Bean</li>
<li><code>@Autowired</code> 注解也可以应用在<code>java.util.Map</code>上，若该Map的键值为String，那么Spring将自动装配与Map值类型兼容的Bean，此时Bean的名称作为键值。<ul>
<li>Spring 还支持<code>@Resource</code>和<code>@Inject</code>注解，这两个注解和<code>@Autowired</code>注解的功能类似</li>
</ul>
</li>
<li><code>@Resource</code> 注解要求提供一个 Bean 名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为 Bean 的名称。</li>
<li><code>@Inject</code>和<code>Autowired</code>注解一样也是按类型匹配注入的Bean，但没有<code>required</code>属性。<br><strong>建议使用<code>Autowired</code>注解</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="IOC_容器中_Bean_的生命周期">IOC 容器中 Bean 的生命周期</h1><ul>
<li>Spring IOC 容器可以管理Bean的生命周期，Spring允许在Bean生命周期的特定点执行定制的任务。</li>
<li>管理过程：<ul>
<li>通过构造器或工厂方法创建Bean实例</li>
<li>为Bean的属性设置值和对其他Bean的引用</li>
<li>调用Bean的初始化方法</li>
<li>Bean可以使用了</li>
<li>当容器关闭时，调用Bean的销毁方法</li>
</ul>
</li>
<li>在Bean的声明里设置<code>init-method</code>和<code>destory-method</code>属性，为Bean指定初始化和销毁方法。</li>
<li><p>创建Bean的后置处理器</p>
<ul>
<li>Bean后置处理器允许在调用初始化方法前后对Bean进行额外的处理</li>
<li>Bean后置处理器对IOC容器里的所有Bean实例逐一处理，而非单一实例。其典型应用是：检查Bean属性的正确性或根据特定的标准更改Bean的属性</li>
<li>对Bean后置处理器而言，需要实现<code>org.springframework.beans.factory.config</code>的<code>BeanPostProcessor</code>接口。在初始化方法被调用前后，Spring将每个Bean实例分别传递给上述接口的以下两个方法：<ul>
<li><code>postProcessBeforeInitialization()</code></li>
<li><code>postProcessAfterInitialization()</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!--</div><div class="line">  实现 BeanPostProcessor 接口，并具体实现</div><div class="line">  public Object postProcessBeforeInitialization(Object o, String s) init-method 之前被调用</div><div class="line">  public Object postProcessAfterInitialization(Object o, String s) init-method 之后被调用</div><div class="line">  的实现</div><div class="line"></div><div class="line">  bean: bean 实例本身</div><div class="line">  beanName: IOC 容器配置的 bean 的名字</div><div class="line">  返回值：是实际上返回给用户的那个 Bean，注意： 可以在以上两个方法中修改返回的 bean，甚至返回一个新的 bean</div><div class="line"> --&gt;</div><div class="line">&lt;!-- 配置 Bean 的后置处理器： 不需要配置 id， IOC 容器自动识别是一个 BeanPostProcessor --&gt;</div><div class="line">&lt;bean class=&quot;myBeanPostProcessor&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="配置形式">配置形式</h1><h2 id="基于xml文件的方式">基于xml文件的方式</h2><h3 id="Bean的配置方式">Bean的配置方式</h3><h4 id="通过全类名（反射）">通过全类名（反射）</h4><figure class="h]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="spring4" scheme="http://www.whtis.com/tags/spring4/"/>
    
      <category term="java web" scheme="http://www.whtis.com/categories/java-web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring4 学习笔记（一）--spring 简介]]></title>
    <link href="http://www.whtis.com/2017/10/06/spring4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89--spring%20%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.whtis.com/2017/10/06/spring4学习笔记（一）--spring 简介/</id>
    <published>2017-10-06T11:19:15.000Z</published>
    <updated>2017-10-13T07:34:46.277Z</updated>
    <content type="html"><![CDATA[<h3 id="spring4_HelloWorld">spring4 HelloWorld</h3><ul>
<li>spring 是一个IOC（DI）和AOP容器框架</li>
<li>具体描述<ul>
<li>轻量级：<strong>Spring是非侵入式的</strong>-基于Spring开发的应用中的对象可以不依赖<code>Spring</code>的<code>API</code></li>
<li>依赖注入</li>
<li>面向切面编程（AOP）</li>
<li>容器</li>
<li>框架</li>
<li>一站式</li>
</ul>
</li>
</ul>
<h3 id="IOC和DI">IOC和DI</h3><ul>
<li>IOC（Inversion of Control）：其思想是<strong>反转资源获取的方向</strong>。传统的资源查找方式要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了IOC以后，则是<strong>容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源</strong>。这种行为也成为查找的被动形式。</li>
<li>DI（Dependency Injection）：IOC的另一种表述方式：即：<strong>组件以一些预先定义好的方式（例如：setter方法）接受来自如容器的资源注入</strong>。相对于IOC来说，这种表述更直接。<ul>
<li>IOC<ul>
<li>分离接口与实现</li>
<li>工厂模式</li>
<li>采用反转控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring容器">Spring容器</h3><ul>
<li>在Spring IOC 容器读取Bean配置创建Bean实例之前，必须对它进行实例化。只有在容器实例化后，才可以从IOC容器里获取Bean实例并使用。</li>
<li>Spring提供了两种类型的IOC容器实现<ul>
<li>BeanFactory： IOC容器的基本实现</li>
<li>ApplicationContext：提供了更多的高级特性，是BeanFactory的子接口。</li>
<li>BeanFactory是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都直接使用ApplicationContext而非底层的BeanFactory</li>
<li>无论使用何种方式，配置文件是相同的</li>
</ul>
</li>
</ul>
<h4 id="ApplicationContext的主要实现类">ApplicationContext的主要实现类</h4><ul>
<li>ClassPathXmlApplicationContext:从类路径下加载配置文件</li>
<li>FileSystemXmlApplicationContext： 从文件系统中加载配置文件</li>
<li>ConfigurableApplicationContext扩展于ApplicationContext，新增加两个主要方法：refresh（）和close（），让ApplicationContext具有启动、刷新和关闭上下文的能力。</li>
<li>ApplicationContext在初始化上下文的时候就实例化所有单例的Bean。（Bean的作用域）</li>
<li>WebApplicationContext是专门为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化工作。</li>
</ul>
<h3 id="从_IOC_容器中获取_Bean_实例">从 IOC 容器中获取 Bean 实例</h3><ul>
<li>BeanFactory 中的方法，常用的有两种：<ul>
<li>用id定位到 IOC 容器中的 Bean</li>
<li>利用类型返回　IOC 容器中的 Bean。但要求 IOC 容器中必须只能有一个该类型的bean</li>
</ul>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="spring4_HelloWorld">spring4 HelloWorld</h3><ul>
<li>spring 是一个IOC（DI）和AOP容器框架</li>
<li>具体描述<ul>
<li>轻量级：<strong>Spring是非侵入式的</strong]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="spring4" scheme="http://www.whtis.com/tags/spring4/"/>
    
      <category term="java web" scheme="http://www.whtis.com/categories/java-web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用python爬虫框架scrapy对实时新闻进行抓取并存入数据库]]></title>
    <link href="http://www.whtis.com/2017/07/28/%E4%BD%BF%E7%94%A8python%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6scrapy%E5%AF%B9%E5%AE%9E%E6%97%B6%E6%96%B0%E9%97%BB%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8F%96%E5%B9%B6%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://www.whtis.com/2017/07/28/使用python爬虫框架scrapy对实时新闻进行抓取并存入数据库/</id>
    <published>2017-07-28T14:15:20.000Z</published>
    <updated>2017-07-29T06:36:53.372Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>每天的新闻更新很快，如果要全面了解非常困难，更可恶的是一些门户网站还经常取一些乱七八糟的标题，点进去是文不对题。所以萌生了一个想法：自己抓取不同门户网站的新闻更新信息，然后将这些内容进行整合，推送一些当日的热点新闻。<br>想的很简单，真的做起来，发现自己还是太年轻，到写这篇博客为止，我也就是完成了一个基本的抓取框架，连内容都没有获得多少。不过本来就是抱着学习<code>python</code>的想法使用<code>scrapy</code>来抓取新闻，既然已经有了个差不多的框架，也该写写使用<code>scrapy</code>过程中的遇到的一些问题了。</p>
<h3 id="明确需求和技术路线">明确需求和技术路线</h3><ul>
<li>需求：很简单，抓取每天最新的新闻内容（文本），按照一定的格式存入数据库<code>mysql</code>中。</li>
<li>技术路线：之前一直在使用<code>java</code>语言开发的<code>webmagic</code>开源爬虫框架进行爬虫开发。但一直听说<code>python</code>下有个大名鼎鼎的爬虫框架<code>scrapy</code>,所以抱着学习的态度，使用<code>scrapy</code>进行爬虫的开发。</li>
</ul>
<h3 id="简单的技术介绍和入门">简单的技术介绍和入门</h3><p>之前只是使用<code>python</code>写过一些简单的脚本，这次为了使用<code>scrapy</code>,看了一遍<strong>廖雪峰大大</strong>的<code>python3</code><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">教程</a><br>看完后没记住多少，不过有个概念就是了。然后开始查看一些讲<code>scrapy</code>入门的博客，自己实现博客中的例子，算是对<code>scrapy</code>有个大概的了解。我复现的例子是这个：<a href="http://www.jianshu.com/p/fa614bea98eb" target="_blank" rel="external">【图文详解】scrapy安装与真的快速上手——爬取豆瓣9分榜单</a></p>
<h3 id="需求的再分析及让scrapy与需求相关">需求的再分析及让<code>scrapy</code>与需求相关</h3><ul>
<li>需求分析：新闻内容很多，获取的方式也不同。最笨的方式就是复现浏览器的行为：针对不同的信息源获取不同的页面进行解析；其次好一点的方法：由于某些新闻网站提供了rss订阅接口，因此可以解析此接口页面获得内容。下面分析下这两种方法的优缺点：<ul>
<li>模拟浏览器行为：<ul>
<li>优点：能够精准解析到需要的内容</li>
<li>缺点：解析难度高，主流新闻网站都有一系列反爬虫机制；代码与页面结构高度相关，如页面改版，代码改动较大</li>
</ul>
</li>
<li>rss接口：<ul>
<li>优点：不同网站的接口页面结构基本相同，可以使用一套解析逻辑进行解析</li>
<li>缺点：并不是所有网站都会提供该接口，且该接口返回的数据，有些仅有正文摘要，还需要再进一次网站获取完整的正文内容</li>
</ul>
</li>
</ul>
</li>
<li>明确需求下的<code>scrapy</code>:上一节提到的入门内容如果看完后，应该对<code>scrapy</code>会有一个大概的整体认识。在我这需求下，似乎单独创建一个爬虫无法完成所有的需求。因此我创建了两个爬虫文件：<code>rss_news_spider.py</code>和<code>web_news_spider.py</code>，下面会对这两个文件进行详细解释。</li>
</ul>
<h3 id="开始写爬虫">开始写爬虫</h3><h4 id="使用scrapy基础模板来爬取rss接口的新闻内容">使用scrapy基础模板来爬取rss接口的新闻内容</h4><p>终于，振奋人心的时刻到了。可以开始我们的爬虫了。首先我们创建<code>runRss.py</code>,然后写上如下启动爬虫的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># run rssSpider</span></div><div class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</div><div class="line"></div><div class="line">cmdline.execute(<span class="string">"scrapy crawl rss"</span>.split())</div></pre></td></tr></table></figure>
<p>是不是很熟悉，对，这条命令启动了名为<code>rss</code>的爬虫（<strong>注意，在scrapy中创建的每一个爬虫必须有自己唯一的<code>name</code>，否则无法启动</strong>）。我的<code>rss</code>爬虫位于<code>rss_news_spider.py</code>这个文件当中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RssSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">'rss'</span></div><div class="line">    start_urls = [</div><div class="line">        <span class="string">'http://www.wyzxwk.com/e/web/?type=rss2&amp;classid=0'</span>,</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        <span class="keyword">if</span> response.url.find(<span class="string">'rss'</span>) != <span class="number">-1</span>:</div><div class="line">            <span class="keyword">yield</span> Request(response.url, callback=self.parse_rss)</div><div class="line">        <span class="keyword">elif</span> response.url.find(<span class="string">'Article'</span>) != <span class="number">-1</span>:</div><div class="line">            <span class="keyword">yield</span> Request(response.url, callback=self.parse_details)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.logger.info(<span class="string">'start urls is not useful, please check it!'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_rss</span><span class="params">(self, response)</span>:</span></div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        contents = selector.xpath(<span class="string">'//channel/item'</span>)</div><div class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</div><div class="line">            title = content.xpath(<span class="string">'title/text()'</span>).extract()[<span class="number">0</span>]</div><div class="line">            link = content.xpath(<span class="string">'link/text()'</span>).extract()[<span class="number">0</span>]</div><div class="line">            ……</div><div class="line">            article = ArticleItem()</div><div class="line">            article[<span class="string">'table_name'</span>] = <span class="string">'article_'</span> + table_name.lower()</div><div class="line">            article[<span class="string">'title'</span>] = title</div><div class="line">            article[<span class="string">'url'</span>] = link</div><div class="line">            <span class="keyword">if</span> link <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                <span class="keyword">yield</span> scrapy.http.Request(url=link, meta=&#123;<span class="string">'item'</span>: article&#125;, callback=self.parse_details)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_details</span><span class="params">(self, response)</span>:</span></div><div class="line">        article = response.meta[<span class="string">'item'</span>]</div><div class="line">        selector = scrapy.Selector(response)</div><div class="line">        content = selector.xpath(<span class="string">'//div[@class="m-article s-shadow"]/article/p'</span>).extract().__str__()</div><div class="line">        content = content.replace(<span class="string">"', '"</span>, <span class="string">""</span>).replace(<span class="string">"\\u3000"</span>, <span class="string">"  "</span>).replace(<span class="string">"'"</span>, <span class="string">""</span>).replace(<span class="string">"\\xa0"</span>, <span class="string">""</span>)</div><div class="line">            .replace(<span class="string">"▍"</span>, <span class="string">""</span>)</div><div class="line">        article[<span class="string">'content'</span>] = content</div><div class="line">        <span class="keyword">return</span> article</div></pre></td></tr></table></figure></p>
<p>来认真看下这段代码：</p>
<ul>
<li>设置<code>name</code>、<code>start_urls</code>和<code>parse</code>函数我们都很熟悉。那<code>parse_rss</code>和<code>parse_details</code>是干嘛用的？<ul>
<li>在本文的例子中，我们用了<a href="http://www.wyzxwk.com/" target="_blank" rel="external">乌有之乡</a>的<code>rss</code>接口作为例子。这个<code>rss</code>接口的特点是给出的正文内容是 摘要，如果要查看详细的正文内容需要访问相应的<code>url</code>,因此两个函数的作用就非常明显了：<code>parse_rss</code>函数是处理接口页面的信息并获取正文的链接，然后使用<code>parse_details</code>函数对正文做解析。</li>
<li>这个地方比较重要的是函数之间如何传递参数？也就是我想把<code>parse_rss</code>中解析到的内容传递给<code>parse_details</code>。从代码中可以看出，我们在传递链接的时候使用的<code>scrapy.http.Request</code>中可以附加参数：<code>url</code>是链接；<code>meta</code>是一个字典，可以包含所有希望下一个函数获得的内容；<code>callback</code>是回调函数，用于指定这些内容由哪个函数进行处理。</li>
</ul>
</li>
<li><code>start_urls</code>中注释的url是干啥用的？<ul>
<li>如我们在需求分析中所说，rss接口页面结构是相同的，因此理论上来说，在<code>parse_details</code>之前的逻辑，适用于任何实现了rss接口的网站。</li>
</ul>
</li>
</ul>
<p>现在有个问题？如果我爬取的网站比较多，那么<code>parse_details</code>的逻辑我是不是要根据不同的网站去分别实现？按道理来说是这样的，但<code>scrapy</code>还为我们提供了另外一种实现思路。下面的内容主要参考了如下几篇博客：</p>
<ul>
<li><a href="http://www.code123.cc/1431.html" target="_blank" rel="external">Python爬虫框架Scrapy教程(1)—入门</a></li>
<li><a href="http://www.code123.cc/1432.html" target="_blank" rel="external">Python爬虫框架Scrapy教程(2)—动态可配置</a></li>
<li><a href="http://www.code123.cc/1434.html" target="_blank" rel="external">Python爬虫框架Scrapy教程(3)—使用Redis和SQLAlchemy</a></li>
</ul>
<h4 id="读取数据库配置动态生成爬虫">读取数据库配置动态生成爬虫</h4><p>我们知道，爬虫的核心其实就是发送请求与接收请求。那么如果我们要从网络上获取到新闻内容，浏览器发送这两个请求就可以：<br>1、请求新闻的列表页，解析出每一篇新闻的详细链接<br>2、访问每一篇新闻的详细链接，然后解析返回的内容，就可以得到新闻的标题、发表时间、正文等内容了。<br>（<strong>以上两步其实是爬虫领域很经典的列表+详情页爬取逻辑</strong>）<br>在这个过程中，浏览器（或者代码）的执行步骤是相同的，不同的只是访问的链接，以及对不同链接内容的解析（主要是<code>xpath</code>和<code>正则表达式</code>）。因此假设访问的链接和解析方法都能够动态加载（从数据库中读取），那么我们就可以写一个爬虫来加载这些配置，实现多个网站内容的抓取了。<br>我们创建一个<code>runWeb.py</code>文件，写入下面内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># run webSpider</span></div><div class="line">settings = Settings()</div><div class="line">settings.set(<span class="string">"ITEM_PIPELINES"</span>, &#123;</div><div class="line">    <span class="comment"># 'pipelines.DuplicatesPipeline': 200,</span></div><div class="line">    <span class="comment"># 'pipelines.CountDropPipline': 100,</span></div><div class="line">    <span class="string">'pipelines.DataBasePipeline'</span>: <span class="number">300</span>,</div><div class="line">&#125;)</div><div class="line"><span class="comment"># crawl settings</span></div><div class="line">settings.set(<span class="string">"USER_AGENT"</span>,</div><div class="line">             <span class="string">"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1667.0 Safari"</span></div><div class="line">             <span class="string">"/537.36"</span>)</div><div class="line"></div><div class="line">process = CrawlerProcess(settings)</div><div class="line"></div><div class="line">db = DBSession()</div><div class="line">rules = db.query(Rule).filter(Rule.enable == <span class="number">1</span>)</div><div class="line"><span class="keyword">for</span> rule <span class="keyword">in</span> rules:</div><div class="line">    process.crawl(WebSpider, rule)</div><div class="line">process.start()</div></pre></td></tr></table></figure></p>
<p>加载完自定义<code>settings</code>后，对每一个<code>rule</code>生成一个进程，运行<code>webSpider</code>。我的<code>webSpider</code>在<code>web_news_spider</code>中。可以看下这里面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSpider</span><span class="params">(CrawlSpider)</span>:</span></div><div class="line">    name = <span class="string">"web"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rule)</span>:</span></div><div class="line">        self.rule = rule</div><div class="line">        self.name = rule.site_name</div><div class="line">        self.allowed_domains = rule.allow_domains.split(<span class="string">","</span>)</div><div class="line">        self.start_urls = rule.start_urls.split(<span class="string">","</span>)</div><div class="line">        rule_list = []</div><div class="line">        <span class="comment"># 添加`下一页`的规则</span></div><div class="line">        <span class="keyword">if</span> rule.next_page:</div><div class="line">            rule_list.append(Rule(LinkExtractor(restrict_xpaths=rule.next_page)))</div><div class="line">        <span class="comment"># 添加抽取文章链接的规则</span></div><div class="line">        rule_list.append(Rule(LinkExtractor(</div><div class="line">            allow=[rule.allow_url],</div><div class="line">            restrict_xpaths=[rule.extract_from]),</div><div class="line">            callback=<span class="string">'parse_item'</span>, follow=<span class="keyword">True</span>))</div><div class="line">        self.rules = tuple(rule_list)</div><div class="line">        super(WebSpider, self).__init__()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span><span class="params">(self, response)</span>:</span></div><div class="line">        self.log(<span class="string">'Hi, this is a web page! %s'</span> % response.url)</div><div class="line"></div><div class="line">        content = infos.xpath(self.rule.content_xpath).extract()</div><div class="line">        article[<span class="string">"content"</span>] = content[<span class="number">0</span>] <span class="keyword">if</span> content <span class="keyword">else</span> <span class="string">""</span></div><div class="line"></div><div class="line">        publish_time = infos.xpath(self.rule.publish_time_xpath).extract()</div><div class="line">        article[<span class="string">"publish_time"</span>] = publish_time[<span class="number">0</span>] <span class="keyword">if</span> publish_time <span class="keyword">else</span> <span class="string">""</span></div><div class="line">        ……</div></pre></td></tr></table></figure></p>
<p>其中<code>__init__</code>函数很关键，除了从数据库读取配置外，它使用<code>Rule(LinkExtractor(……))</code>指定了对新闻列表页的解析规则：<code>allow</code>指定了加入下载队列中url的格式；<code>restrict_xpaths</code>指定了寻找url的页面范围;<code>callback</code>指定了处理后续url（新闻详情页）的方法。</p>
<ul>
<li><code>allow</code>和<code>restrict_xpaths</code>从<code>正则表达式</code>和<code>xpath</code>共同对后续帖子详情页url进行限制；</li>
<li><code>callback</code>指定的是解析详情页的方法，顾名思义，列表页的处理是由爬虫自己处理的（使用参数，这也是我没搞懂的地方，因为不是自己处理，在爬虫无法抽取详情页url时很难定位到哪里出错了）</li>
</ul>
<p>如果你的<code>allow</code>和<code>restrict_xpaths</code>设置无误，且列表页返回的信息很完整，你就可以使用<code>parse_item</code>函数制定解析详情页的逻辑了。<br><strong>1、初始接触这种方法时，极其建议使用已经有的例子进行学习，上面提到的博客中的代码，在本文书写时仍能正常运行</strong><br><strong>2、这种方法对动态加载的列表页是无效的</strong></p>
<h3 id="把抓取到的内容存入数据库">把抓取到的内容存入数据库</h3><p>网上大部分使用的<code>mysql</code>驱动是<code>mysqlDb</code>，但是它不支持<code>python3.x</code>。因此本文使用的是<code>pymysql</code>,<code>orm</code>框架是<a href="https://www.sqlalchemy.org/" target="_blank" rel="external"><code>SQLAlchemy</code></a><br>本文仅对一些缺少资料地方进行说明：</p>
<ul>
<li><code>SQLAlchemy</code>连接数据库的方法（参考自官方文档）：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 初始化数据库连接:</span></div><div class="line">engine = create_engine(<span class="string">'mysql+pymysql://user:passwd@localhost:3306/spider?charset=utf8mb4'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建DBSession类型:</span></div><div class="line">DBSession = sessionmaker(bind=engine)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，初始化<code>engine</code>时需要指定数据库。本文使用的代码，数据库信息存储在<code>scrapy</code>的默认<code>settings</code>中。</p>
<ul>
<li>SQLAlchemy存储信息时动态指定表名<br>我们有这个一个需求，不同的网站内容我们需要存储到不同的表当中。但学习<code>SQLAlchemy</code>用法的时候，我们可以看到，在创建<code>model</code>类时就必须指定<code>__tablename__</code>,否则无法存储。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleModel</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'none'</span></div><div class="line"></div><div class="line">    aid = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    title = Column(String)</div><div class="line">    url = Column(String)</div><div class="line">    ……</div></pre></td></tr></table></figure>
</li>
</ul>
<p>那我们总不能创建多个除了<code>__tablename__</code>不同其他都相同的<code>modle</code>类吧。还好，我们可以使用如下方法在向数据库插入数据的时候（pipeline中）动态指定表名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ArticleModel.__table__.name = item[<span class="string">'table_name'</span>]</div><div class="line">a = ArticleModel(title=item[<span class="string">"title"</span>].encode(<span class="string">"utf-8"</span>),</div><div class="line">                 url=item[<span class="string">"url"</span>],</div><div class="line">                 ……</div><div class="line">                ）</div></pre></td></tr></table></figure></p>
<h3 id="其他">其他</h3><p>本来以为<code>mysql</code>中的<code>timestamp</code>对应于<code>python</code>中的<code>date</code>类型，今天向数据库中插入时间戳的时候，才发现对应的是<code>str</code>类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pub_float = time.mktime(time.strptime(pubDate, <span class="string">'%a, %d %b %Y %X %z'</span>))</div><div class="line">timestamp = time.strftime(<span class="string">'%Y-%m-%d %X'</span>, time.localtime(pub_float))</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>type(timestamp) → str</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="后记">后记</h3><p>本文所写内容为这段时间学习成果之记录，开头所提到的需求离实际完成还很远。文中提到的第二种方法在具体到本文中需求中使用时并没有成功，具体原因由于本人水平所限，并未查出来。如果有对这方面感兴趣的可以一同研究学习。本文提到的完整代码可以在我的<a href="https://github.com/whtis/news_scrapy" target="_blank" rel="external">github</a>上找到。</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>每天的新闻更新很快，如果要全面了解非常困难，更可恶的是一些门户网站还经常取一些乱七八糟的标题，点进去是文不对题。所以萌生了一个想法：自己抓取不同门户网站的新闻更新信息，然后将这些内容进行整合，推送一些当日的热点新闻。<br>想的]]>
    </summary>
    
      <category term="python，scrapy，mysql，新闻抓取" scheme="http://www.whtis.com/tags/python%EF%BC%8Cscrapy%EF%BC%8Cmysql%EF%BC%8C%E6%96%B0%E9%97%BB%E6%8A%93%E5%8F%96/"/>
    
      <category term="python" scheme="http://www.whtis.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最近要做的几件事]]></title>
    <link href="http://www.whtis.com/2017/06/30/%E6%9C%80%E8%BF%91%E8%A6%81%E5%81%9A%E7%9A%84%E5%87%A0%E4%BB%B6%E4%BA%8B/"/>
    <id>http://www.whtis.com/2017/06/30/最近要做的几件事/</id>
    <published>2017-06-30T07:12:31.102Z</published>
    <updated>2017-06-19T03:23:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>有时候想到要做一些跟技术有关的东西，但很多时候都会忘记。一直觉得<strong>兴趣是最好的老师</strong>这句话很对，既然有兴趣，那么最好动手做一做。写这篇文章，提醒自己的同时也是希望认识志同道合的朋友，虽然刚开始做的东西很low，但慢慢积累，总能获得成就感不是？<br><br>这篇文章会不断更新，我也想看看，我最后到底能做几件自己喜欢的事情，嘻嘻(●’◡’●)</p>
<h5 id="2016-09-19日凌晨">2016-09-19日凌晨</h5><ul>
<li>学习安卓开发，写一个app，具体需求如下：（已实现第一步）<ul>
<li><del>能够实现实时监测手机短信的功能。当手机A收到新短信后，能立刻调用系统短信app将短信内容发送给B</del></li>
<li>如果有可能，转发这一步调用微信完成（省钱啊）</li>
<li><del>界面，能凑合用就行，别出bug就行（没写。。）</del></li>
</ul>
</li>
<li>给这博客添加几个功能：<ul>
<li><del>添加网易云音乐插件（最终还是觉得不加好一些）</del></li>
<li><del>添加一个新分区，类似于微信朋友圈或者qq空间发状态的功能。（因为自己有时候有些话憋不住，按照博文发出来又太短了=。=）</del></li>
<li><del>之前好像见过博客同步instagram的功能，如果上面两个都完成了，可以在博客上添加一个专门的图片分区（看过效果，类似于图床，没啥实用性，还是直接上传instagram，等积累到一定量直接放链接就行）</del></li>
</ul>
</li>
</ul>
<h5 id="2016-11-07日夜">2016-11-07日夜</h5><ul>
<li><del>续上次的需求，学习微信公众号开发（转发手机短信到公众号再下发）</del></li>
<li><del>学习javascript，自己写一个简易的网站（博客新分区的提高要求）</del></li>
</ul>
<h5 id="2017-6-19">2017-6-19</h5><ul>
<li>接去年11月的需求，学习微信公众号开发，建立自己的微信公众号，提供信息的聚合，包括新闻和招聘信息</li>
<li>学习<code>spring</code>框架，运用所学的知识在腾讯云上搭建一个自己的网站。采用技术为<code>java+spring+mybatis</code></li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>有时候想到要做一些跟技术有关的东西，但很多时候都会忘记。一直觉得<strong>兴趣是最好的老师</strong>这句话很对，既然有兴趣，那么最好动手做一做。写这篇文章，提醒自己的同时也是希望认识志同道合的朋友，虽然刚开始做的东]]>
    </summary>
    
      <category term="待完成" scheme="http://www.whtis.com/tags/%E5%BE%85%E5%AE%8C%E6%88%90/"/>
    
      <category term="未完成" scheme="http://www.whtis.com/categories/%E6%9C%AA%E5%AE%8C%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ubuntu过程中的一些命令集合]]></title>
    <link href="http://www.whtis.com/2017/06/19/%E4%BD%BF%E7%94%A8ubuntu%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
    <id>http://www.whtis.com/2017/06/19/使用ubuntu过程中的一些命令集合/</id>
    <published>2017-06-19T01:57:27.000Z</published>
    <updated>2017-06-19T06:50:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ubuntu命令备忘">ubuntu命令备忘</h1><p>用ubuntu时，经常会用到一些有用的命令，但回头好久不用又忘了。而我又是那种不喜欢查手册的人，百度一下又得费时，所以干脆开篇博客记下来，以后直接来这查好了。</p>
<h2 id="ubuntu使用tar命令备份系统命令合集"><code>ubuntu</code>使用<code>tar</code>命令备份系统命令合集</h2><p>这里的备份和恢复都是针对同一硬盘下的备份与恢复。</p>
<h3 id="备份">备份</h3><ul>
<li><code>tar cvpzf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys /</code></li>
<li>或者是 <code>tar cvpjf backup.tgz.gz2 --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys /</code><br>两条命令的区别在于第二条的压缩率高于第一条。</li>
</ul>
<h3 id="恢复">恢复</h3><ul>
<li><code>tar xvpfz backup.tgz -C /</code> or <code>tar xvpfj backup.tar.bz2 -C /</code></li>
</ul>
<h2 id="ubuntu使用dd命令备份硬盘命令合集"><code>ubuntu</code>使用<code>dd</code>命令备份硬盘命令合集</h2><p>这里的备份和恢复可以在不同硬盘下进行，但是要注意硬盘大小的问题，即恢复的硬盘大小不得小于备份的硬盘大小。这些操作请在<code>live CD</code>环境下进行。</p>
<h3 id="备份-1">备份</h3><ul>
<li><code>fdisk -u -l</code> 查看磁盘信息</li>
<li><code>dd if=/dev/sda of=/ubuntu/media/xxx/ghost.img</code> 备份到外接u盘中</li>
<li><code>kill -USR1 `pgrep ^dd` </code>显示上一条命令的进度（请在另外的终端中运行）</li>
<li><code>dd if=/ubuntu/media/xxx/ghost.img of=/dev/sda</code> 恢复到指定的硬盘中<tab> kill -USR1 <code>pgrep ^dd</code> </tab>

</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ubuntu命令备忘">ubuntu命令备忘</h1><p>用ubuntu时，经常会用到一些有用的命令，但回头好久不用又忘了。而我又是那种不喜欢查手册的人，百度一下又得费时，所以干脆开篇博客记下来，以后直接来这查好了。</p>
<h2 id="ubuntu使用ta]]>
    </summary>
    
      <category term="ubuntu" scheme="http://www.whtis.com/tags/ubuntu/"/>
    
      <category term="收集整理" scheme="http://www.whtis.com/tags/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="ubuntu" scheme="http://www.whtis.com/categories/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ubuntu16.04删除当前用户密码文件/etc/shadow后无法进入系统的解决方法]]></title>
    <link href="http://www.whtis.com/2017/04/08/ubuntu16-04%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E6%96%87%E4%BB%B6-etc-shadow%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2017/04/08/ubuntu16-04删除当前用户密码文件-etc-shadow后无法进入系统的解决方法/</id>
    <published>2017-04-08T07:48:02.000Z</published>
    <updated>2017-04-08T08:55:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>最近项目用到了dspace，在windows中向dspace中导入item时会报解压错误的<code>error</code>,后来经过排查，确定是windows平台编码问题导致。于是转战ubuntu，在安装了16.04版本，配置了<code>java</code>环境、安装编译器等等一系列工作、差不多可以进行开发的时候，我手贱删除了这个文件<code>/etc/shadow</code>，为什么会删除它，这就涉及到安装shadowsocks了，这里不详说。反正是在编辑<code>/etc/shadowsocks.json</code>文件时，我觉得<code>/etc/shadow</code>可能是个临时文件，就用root权限删除了。这样一删不要紧，重启机器以后傻眼了，输入正确的用户名密码后，无法登陆到图形界面，提示也是说密码不对。类似于下图：<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//558d1f9e0e1dcda9c9001b15c0b4d63d.png" alt="ubuntu密码错误"></p>
<h4 id="原因">原因</h4><p>解决这个问题之前，需要了解下ubuntu登陆图形界面时的用户认证过程。以下是个人理解，可能会有错误，还请指正。</p>
<ul>
<li>ubuntu会在<code>/etc</code>目录下保存用户的登陆信息，当然是加密后的，但是不像我们认为的那样只有一个文件，而是包含两个文件：<code>/etc/passwd</code>、<code>/etc/shadow</code>，登陆时ubuntu会自动比对两个文件的信息，如果一直则允许用户登陆，否则就会拒绝。我因为删除了<code>/etc/shadow</code>这个文件，所以在比对时会出错。</li>
</ul>
<h4 id="解决">解决</h4><p>找到了原因，就很好办了。网上有很多遗忘了ubuntu密码后找回的教程，但是很遗憾，我所能找到的没有一个教程是完全正确的，因为大多数都是互相抄，这种现象确实可悲。以下解决思路是我本人亲测，转载时请附带ubuntu版本信息及出处。</p>
<ul>
<li><del>第一种解决方法：既然我是误删了<code>/etc/shadow</code>，那么我想办法在命令行登陆，拷贝<code>/etc/passwd</code>文件为<code>/etc/shadow</code>不就可以绕过俩文件校验了么？（事实证明这个想法行不通，如果你查看两个文件的内容，你会发现实际上两个文件的内容是不同的，但登陆时具体怎么校验的，没有深入研究过）</del></li>
<li><del>第二种方法：想办法在命令行登陆，使用命令行更改用户密码，然后就可以使用原用户名+新密码登陆了（这种方法看似可行，而且命令行中更改密码时也会提示更改成功，但仍然无法登陆图形界面。ps：此时可以在shell中登陆）</del></li>
<li>第三种方法：想办法在命令行登陆，然后创建一个新的用户，将老用户文件拷贝到新用户目录下，重启后就可以使用新用户登陆了。（事实证明这种方法可行，唯一的问题是之前用户的某些配置会丢失，这也没办法了。。）</li>
</ul>
<h5 id="实际操作">实际操作</h5><p>可能有人注意到，上面的解决方法都有一点是相同的，<strong>想办法在命令行登陆</strong>。但当机器出现这问题时，<code>CTRL+ALT+F2~F6</code>都已经无法进入命令行了。下面说下正确的做法，截图来自网络。<br>1、开机按ESC，出现如下界面<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//ef0ff36421090d6e1227c8c3cdfabefb.png" alt="ubuntu开机画面"></p>
<p>2、按回车键进入如下界面，然后选中有recovery mode的选项<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//5ce0970a7d9d6cc2bcd68b4ae256fb47.png" alt="ubuntu-recovery-mode"></p>
<p>3、这一步不要按回车，按下<code>e</code>进行编辑状态，找到图中红色框的<code>recovery nomodeset</code>并删除，修改<code>ro</code>为<code>rw</code>（不改的话进入命令行无法输入命令）,并在后面输入<code>quiet splash rw init=/bin/bash</code>后，按<code>F10</code>或<code>CTRL+X</code>重启<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//e512c666c1780ade758e424890e8973c.png" alt="edit-grub"><br><strong>注意，网上大多数教程就是这一步操作不对，导致重启后要么无法进入命令行，要么无法编辑</strong></p>
<p>4、重启后如果看到下图，则说明我们可以开始尝试上面提到的三种方法了。<br><img src="http://7xnttb.com1.z0.glb.clouddn.com//4c37c3c29de17d562411db499f3a3bd1.png" alt="root-temp"></p>
<h4 id="后记">后记</h4><ul>
<li>请注意本文全程的解决是基于ubuntu没有开启<code>root</code>用户图形界面登陆的前提，关于如何开启root用户登陆，可以自行<code>google</code>。如果开启了<code>root</code>用户，则以上的讨论都可以省略，因为以<code>root</code>用户登陆后，更改用户等操作都不会遇到任何困难。因此强烈建议：<code>使用ubuntu桌面版时请开启root用户登陆，方便遇到问题后能及时解决。</code></li>
<li>附上我在测试以上三种方法时，使用的一些<code>ubuntu</code>指令：<ul>
<li>递归拷贝用户目录：<code>sudo cp -r sourceFold_path targetFold_path</code></li>
<li>递归指定用户目录所有者：<code>sudo chown user usergroup</code></li>
<li>增加用户并且在<code>/home</code>目录下生成相应文件夹：<code>sudo adduser user</code>，该命令会自动创建用户主目录，创建用户同名的组</li>
<li>修改密码：<code>sudo passwd</code>，然后输入两次密码即可。如果要修改特定用户的密码，可以在后面加上用户名 <code>sudo passwd user</code></li>
</ul>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>最近项目用到了dspace，在windows中向dspace中导入item时会报解压错误的<code>error</code>,后来经过排查，确定是windows平台编码问题导致。于是转战ubuntu，在安装了16.04版本，配]]>
    </summary>
    
      <category term="ubuntu" scheme="http://www.whtis.com/tags/ubuntu/"/>
    
      <category term="搜集整理" scheme="http://www.whtis.com/tags/%E6%90%9C%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="ubuntu" scheme="http://www.whtis.com/categories/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个可以链式使用正则的类]]></title>
    <link href="http://www.whtis.com/2017/03/23/%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E9%93%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E7%9A%84%E7%B1%BB/"/>
    <id>http://www.whtis.com/2017/03/23/一个可以链式使用正则的类/</id>
    <published>2017-03-23T07:52:01.000Z</published>
    <updated>2017-06-19T01:58:35.000Z</updated>
    <content type="html"><![CDATA[<p>最近使用webMgaic爬虫框架的时候，发现链式调用真的很好用，能省掉很多套路性的代码，所以也自己动手写了一个可以链式调用进行正则筛选的工具类。下面上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.regex.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by wht on 2017/3/18.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RexString</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>  String string = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RexString</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RexString</span><span class="params">(String string)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.string = string;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> RexString <span class="title">getRex</span><span class="params">(String rex)</span> </span>&#123;</div><div class="line">        Pattern p = Pattern.compile(rex);</div><div class="line">        Matcher m = p.matcher(string);</div><div class="line">        <span class="keyword">if</span> (m.find()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RexString(m.group());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RexString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.string;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RexString rexString = <span class="keyword">new</span> RexString(<span class="string">"xxx"</span>);</div><div class="line">RexString rs = rexString.getRex(rex1).getRex(rex2).getRex(rex3) ···</div><div class="line">String result = rs.toString();</div></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近使用webMgaic爬虫框架的时候，发现链式调用真的很好用，能省掉很多套路性的代码，所以也自己动手写了一个可以链式调用进行正则筛选的工具类。下面上代码：</p>
<figure class="highlight java"><table><tr><td class="g]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="总结，原创" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93%EF%BC%8C%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo博客主题--material折腾笔记]]></title>
    <link href="http://www.whtis.com/2016/11/20/hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98-material%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.whtis.com/2016/11/20/hexo博客主题-material折腾笔记/</id>
    <published>2016-11-20T12:56:17.000Z</published>
    <updated>2016-11-20T13:21:22.000Z</updated>
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;好久没怎么照看博客了，昨天突然发现，以前用的<code>Next</code>主题挂了。因为用的别人的东西，不知道问题。本着折腾的想法，重新换了一个主题<code>material</code>。该主题算是满足了我大部分的需求吧。但还是有吐槽的地方……（虽然不会写js，不妨碍我吐槽。。原作者看到估计会气的吐血）</p>
<h4 id="添加谷歌和百度统计代码">添加谷歌和百度统计代码</h4><p>按照<a href="https://material.vss.im/expert/" target="_blank" rel="external">使用文档</a>可以自行添加代码，但我添加百度统计代码时报错，所以直接把百度统计代码写到<code>layout/_partial/head.ejs</code>文件中了。</p>
<h4 id="在文章详情页添加回主页的方法">在文章详情页添加回主页的方法</h4><ul>
<li>可以直接点击缩略图返回首页</li>
<li>分享按钮下增加回主页</li>
</ul>
<h4 id="此主题的一些想法">此主题的一些想法</h4><ul>
<li>好的方面<ul>
<li>背景支持bing图片，这个想法点赞</li>
<li>每篇文章都提供缩略图<code>thumbnail</code>的设置，很棒</li>
</ul>
</li>
<li>可以改进的地方<ul>
<li>侧边栏很不完美。包括样式和调出方式（鼠标点击改为鼠标滑过会好很多，尝试过更改，然而太菜，没有找到正确修改的方法）</li>
<li>缺少文章分类页，看github上的issue，感觉作者根本没想到这个需求，但我之前用的主题都有，强迫症伤不起</li>
</ul>
</li>
</ul>
<p>突然想到，改了作者的文件，以后<code>pull</code>的时候又有得折腾了。anyway，自己菜就得忍受这些问题了。</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<p>&nbsp;&nbsp;好久没怎么照看博客了，昨天突然发现，以前用的<code>Next</code>主题挂了。因为用的别人的东西，不知道问题。本着折腾的想法，重新换了一个主题<code>material</code>。该主题算是满足了我大部分的需求吧。但还是有吐槽的地方…]]>
    </summary>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="hexo" scheme="http://www.whtis.com/tags/hexo/"/>
    
      <category term="hexo" scheme="http://www.whtis.com/categories/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将百度搜索结果的长url链接转换为真实的url地址]]></title>
    <link href="http://www.whtis.com/2016/09/19/%E5%B0%86%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E9%95%BFurl%E9%93%BE%E6%8E%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%9C%9F%E5%AE%9E%E7%9A%84url%E5%9C%B0%E5%9D%80/"/>
    <id>http://www.whtis.com/2016/09/19/将百度搜索结果的长url链接转换为真实的url地址/</id>
    <published>2016-09-18T16:37:15.000Z</published>
    <updated>2017-06-19T01:58:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p>最近写爬虫的时候，想调用百度的搜索结果，于是有了这个问题。需要注意的是，本篇内容转化是仅针对百度跳转到非百度链接的，百度内部链接的跳转，如百度搜索主入口跳转到百度知道、百度文库等情况不再讨论之列。</p>
<h3 id="问题描述">问题描述</h3><ul>
<li>百度搜索入口：<code>https://www.baidu.com/s?wd=</code>,后面加上需要的搜索内容即可。如需要进行更加精确的搜索，可以使用百度的<a href="http://imgs.xinhuanet.com/js/baidu/gj.htm" target="_blank" rel="external">高级搜索</a>功能。</li>
<li>百度搜索结果示例：<code>https://www.baidu.com/link?url=NsJrxOylR5il9kO2p7IJZu9RdvqdWgobSo1W7n29FIu&amp;amp;wd=&amp;amp;eqid=e4c01daf0006800b0000000357debb6c</code>,实际的url为<code>www.whtis.com</code>。</li>
<li>原因：百度为什么要实行加密跳转，网上有很多有意思的文章，感兴趣可以看看。这里仅从技术角度进行说明。<br><br>百度的这种跳转采用的是302重定向。虽然有时候状态码不是302，但原理差不多一样：当你点击了百度的加密链接后，会向百度内部的服务器发送请求，这个时候服务器会根据你提交的百度链接使用重定向技术自动跳转到相应的真实url。</li>
</ul>
<h3 id="拿到真实的URL链接">拿到真实的URL链接</h3><p>网上有很多博客都提到过这事，既然知道了302跳转的原理，那么可以采用这种思路拿到真实的URL：模拟一个请求，在百度服务器进行重定向的时候获得重定向的地址即可。<br><br>原理很简单，但是我在网上找了很多，基本都是互相抄，抄的代码怎么说呢，用的工具都是httpclient，但是都是httpclient已经废弃的方法，虽然不报错，但是没法实现这功能了。所以这也告诉我们写博客的人，一定要注明自己的代码基于的是哪个版本的工具，虽然这只是一点小事，但却能让自己和他人节约很多时间。<br><br>下面上代码：</p>
<p><strong>使用版本：httpclient 4.3.3</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealUrl</span><span class="params">(String url)</span> </span>&#123;</div><div class="line"></div><div class="line">        String realUrl = <span class="string">""</span>;</div><div class="line"></div><div class="line">        HttpClient client = HttpClientBuilder.create().build();</div><div class="line">        RequestConfig config = RequestConfig.custom()</div><div class="line">        <span class="comment">//禁止自动重定向</span></div><div class="line">                .setRedirectsEnabled(<span class="keyword">false</span>)</div><div class="line">                .build();</div><div class="line"><span class="comment">//302跳转</span></div><div class="line">        HttpGet get = <span class="keyword">new</span> HttpGet(url);</div><div class="line">        get.setConfig(config);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//对url进行utf-8解码</span></div><div class="line">            url = URLDecoder.decode(url, <span class="string">"utf-8"</span>);</div><div class="line">            HttpResponse rs = client.execute(get);</div><div class="line">            Header h = rs.getFirstHeader(<span class="string">"Location"</span>);</div><div class="line">            realUrl = h.getValue().trim();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printstacktrace();</div><div class="line">            <span class="keyword">return</span> url;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (realUrl.equals(<span class="string">""</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> url;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> realUrl;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p>最近写爬虫的时候，想调用百度的搜索结果，于是有了这个问题。需要注意的是，本篇内容转化是仅针对百度跳转到非百度链接的，百度内部链接的跳转，如百度搜索主入口跳转到百度知道、百度文库等情况不再讨论之列。</p>
<h3 id="问题描]]>
    </summary>
    
      <category term="java，原创" scheme="http://www.whtis.com/tags/java%EF%BC%8C%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PostgreSQL使用手记]]></title>
    <link href="http://www.whtis.com/2016/09/14/PostgreSQL%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/"/>
    <id>http://www.whtis.com/2016/09/14/PostgreSQL使用手记/</id>
    <published>2016-09-14T14:29:13.000Z</published>
    <updated>2017-03-23T09:58:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3><p><blockcode><br>&emsp;&emsp;因为项目需要，要将本来的<code>mybatis+mysql</code>改为<code>mybatis+postgresql</code>,使用途中难免遇到坑，以下是我遇到的，记录下来供参考。好久没写blog，感觉都快长草了，目前在想要不要开一个分类，写点日常废话😂<br></blockcode><br>&emsp;&emsp;好了，言归正传。</p>
<h3 id="为什么要用PostgreSQL">为什么要用PostgreSQL</h3><p>为什么要用呢,上面已经说了，项目需要。postgresql经常被拿来和mysql进行比较，postgresql可以用来存储较大的对象数据（文本、视频、图片等），符合项目要求。</p>
<h3 id="什么是PostgreSQL">什么是PostgreSQL</h3><p>念都不知道怎么念的一个词，确实第一感觉没有mysql好。看下官方的说法：</p>
<blockquote>
<p>PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。(摘自百度百科)</p>
</blockquote>
<h3 id="使用版本">使用版本</h3><p>本文总结基于PostgreSQL 9.4版本</p>
<h3 id="安装及使用">安装及使用</h3><p>推荐下阮一峰写的这篇博客<a href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html" target="_blank" rel="external">PostgreSQL新手入门</a></p>
<h3 id="使用中出现的错误及解决方案">使用中出现的错误及解决方案</h3><h4 id="错误一：_java-sql-SQLException:_No_suitable_driver_found_for_jdbc:postgresql://yourhost:port">错误一： <code>java.sql.SQLException: No suitable driver found for jdbc:postgresql://yourhost:port</code></h4><ul>
<li>可能的错误原因：<ul>
<li>使用的postgresql的驱动与当前使用的jdk版本不兼容。具体兼容情况参见官方文档，本文仅作摘录：</li>
<li>系统环境没有配置classpath路径，使的程序无法找到驱动的位置。（使用java IDE编写代码时一般不会出现这种情况）</li>
<li><strong>连接jdbc时url没写正确，一定要再三检查下正确的url</strong>（这一条很恶心，url错误时的提示我遇到过两种，一种是本条目列出的错误，另一种是提示字符编码有问题）</li>
</ul>
</li>
</ul>
<h4 id="错误二：_Error_querying_database-_Cause:_org-postgresql-util-PSQLException:_ERROR:_CREATE_DATABASE_cannot_run_inside_a_transaction_block">错误二： <code>Error querying database.  Cause: org.postgresql.util.PSQLException: ERROR: CREATE DATABASE cannot run inside a transaction block</code></h4><ul>
<li><p>可能的错误原因：</p>
<ul>
<li><p>根据网上查到的资料，单独使用postgresql时，出现这个错误的原因是因为没有打开自动提交。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c = DriverManager.getConnection(<span class="string">"jdbc:postgresql://yourhost"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>);</div><div class="line">     c.setAutoCommit(<span class="keyword">true</span>); <span class="comment">// 把自动提交设置为true</span></div></pre></td></tr></table></figure>
</li>
<li><p>我在项目中单独使用Mybatis进行事务管理，管理<code>PostgreSQL</code>时也会出现这个错误，因为Mybatis封装了<code>java.sql.*</code>相关的类,因此无法按照上面方式进行更改，在Mybatis中打开一个会话时，也应该将其设置为自动提交（mysql无需设置）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>总结：出现这个问题，网上给的解决方法大多是因为没有打开自动提交，但是仅仅在portgresql控制台上执行<code>SET AUTOCOMMIT = on</code>是无用的，至于为什么需要打开自动提交才能创建数据库，这个不太清楚，可能跟<code>PostgreSQL</code>自己的事务管理逻辑有关，而且这样改动后，暂时不知道会不会对之后的数据库操作造成影响</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="错误三：在拷贝excel中数据到pgsql中时，使用语句时有以下问题需要注意：">错误三：在拷贝excel中数据到pgsql中时，使用语句时有以下问题需要注意：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COPY excel.csv FROM <span class="string">'address'</span> WITH (FORMAT CSV, HEADER TRUE, QUOTE <span class="string">'"'</span>, DELIMITER <span class="string">','</span>, ENCODING <span class="string">'UTF8'</span> );</div></pre></td></tr></table></figure>
<ul>
<li><code>ERROR: must be superuser to COPY to or from a file,建议：Anyone can COPY to stdout or from stdin. psql&#39;s copy command also works for anyone.</code><ul>
<li>这是因为当前登陆pgsql的用户不具有向数据库copy数据的权限所致。需要切换到superuser进行此操作。</li>
</ul>
</li>
<li><code>ERROR: invalid input syntax for integer:</code><ul>
<li>这个错误是网上使用<code>COPY excel.csv FROM &#39;address&#39; WITH DELIMITER &#39;,&#39;</code>所致，如果在copy命令中指定选项header为true. 另外，将format指定为csv, 文件格式指定为utf8，就能避免这错误。</li>
</ul>
</li>
</ul>
<h3 id="使用PostgreSQL存储大文件">使用PostgreSQL存储大文件</h3><p>待编辑</p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="写在前面">写在前面</h3><p><blockcode><br>&emsp;&emsp;因为项目需要，要将本来的<code>mybatis+mysql</code>改为<code>mybatis+postgresql</code>,使用途中难免遇到坑，以下是我遇]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="数据库，PostgreSQL" scheme="http://www.whtis.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8CPostgreSQL/"/>
    
      <category term="SQL" scheme="http://www.whtis.com/categories/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习笔记--设置代理及打开外部程序]]></title>
    <link href="http://www.whtis.com/2016/05/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E5%8F%8A%E6%89%93%E5%BC%80%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.whtis.com/2016/05/29/Java学习笔记-设置代理及打开外部程序/</id>
    <published>2016-05-29T12:14:59.000Z</published>
    <updated>2016-09-14T15:50:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="设置系统代理">设置系统代理</h3><ul>
<li><p>系统设置全局代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.getProperties().setProperty(<span class="string">"proxySet"</span>, <span class="string">"true"</span>);</div><div class="line">System.getProperties().setProperty(<span class="string">"http.proxyHost"</span>, <span class="string">"ip"</span>);</div><div class="line">System.getProperties().setProperty(<span class="string">"http.proxyPort"</span>, port);</div></pre></td></tr></table></figure>
</li>
<li><p>使用了selenium的chrome驱动，webdriver设置代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"webdriver.chrome.driver"</span>, <span class="string">"filepath"</span>);</div><div class="line">String proxyIpAndPort = ip + <span class="string">":"</span> + port;</div><div class="line"></div><div class="line"><span class="comment">// 代理配置</span></div><div class="line">DesiredCapabilities cap = <span class="keyword">new</span> DesiredCapabilities();</div><div class="line">org.openqa.selenium.Proxy proxy = <span class="keyword">new</span> org.openqa.selenium.Proxy();</div><div class="line"></div><div class="line"><span class="comment">// 配置http、ftp、ssl代理（注：当前版本只支持所有的协议公用http协议，下述代码等同于只配置http）</span></div><div class="line">proxy.setHttpProxy(proxyIpAndPort)</div><div class="line">        .setFtpProxy(proxyIpAndPort)</div><div class="line">        .setSslProxy(proxyIpAndPort);</div><div class="line"></div><div class="line"><span class="comment">// 以下三行是为了避免localhost和selenium driver的也使用代理，务必要加，否则无法与iedriver通讯</span></div><div class="line">cap.setCapability(CapabilityType.ForSeleniumServer.AVOIDING_PROXY, <span class="keyword">true</span>);</div><div class="line">cap.setCapability(CapabilityType.ForSeleniumServer.ONLY_PROXYING_SELENIUM_TRAFFIC, <span class="keyword">true</span>);</div><div class="line">System.setProperty(<span class="string">"http.nonProxyHosts"</span>, <span class="string">"localhost"</span>);</div><div class="line"></div><div class="line">cap.setCapability(CapabilityType.PROXY, proxy);</div><div class="line"></div><div class="line">WebDriver webDriver = <span class="keyword">new</span> ChromeDriver(cap);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="打开外部程序">打开外部程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Process p = Runtime.getRuntime().exec(<span class="string">"cmd command"</span>);</div></pre></td></tr></table></figure>
<p><strong>如果外部程序放在一个单独的线程中执行，需要注意的是：该线程执行完并不代表着外部程序也执行完相应的任务。</strong></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="设置系统代理">设置系统代理</h3><ul>
<li><p>系统设置全局代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</d]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="java学习笔记" scheme="http://www.whtis.com/tags/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HttpClient4.x使用中出现的几个问题及解决方法]]></title>
    <link href="http://www.whtis.com/2016/05/05/HttpClient4-x%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://www.whtis.com/2016/05/05/HttpClient4-x使用中出现的几个问题及解决方法/</id>
    <published>2016-05-05T14:38:39.000Z</published>
    <updated>2016-09-14T15:46:45.000Z</updated>
    <content type="html"><![CDATA[<p>最近才开始接触这个工具包，官网上目前已经更新到<a href="http://hc.apache.org/downloads.cgi" target="_blank" rel="external">HttpClient4.5.2</a>了。google的时候看到HttpClient从4.0版本改了底层，因此使用时会出现一些方法不再适用的问题，这里记录出现的一些问题以及相应替代的方法。</p>
<p>1、 创建HttpClient时使用下面的语句，会出现<code>org.apache.http.impl.client.DefaultHttpClient&#39; is deprecated</code><br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</div></pre></td></tr></table></figure></p>
<p>   可以使用如下语句代替：<a href="http://stackoverflow.com/questions/15336477/deprecated-java-httpclient-how-hard-can-it-be" target="_blank" rel="external">来源</a><br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpClient httpClient = HttpClientBuilder.create().build();</div></pre></td></tr></table></figure></p>
<p>   或者<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建HttpClientBuilder</span></div><div class="line">HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();</div><div class="line"><span class="comment">// HttpClient</span></div><div class="line">CloseableHttpClient httpClient = httpClientBuilder.build();</div></pre></td></tr></table></figure></p>
<p>2、 设置代理，HttpClient4.5.2版本可以使用如下语句：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建代理</span></div><div class="line">HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">"your proxy IP"</span>, port);</div><div class="line">RequestConfig config = RequestConfig.custom().setProxy(proxy).build();</div><div class="line"></div><div class="line"><span class="comment">//设置HttpPost/HttpGet使用代理</span></div><div class="line">httpost.setConfig(config);</div></pre></td></tr></table></figure></p>
<p>3、get或post时，如果访问的网站是https协议的，可以用如下方式访问：信任所有证书，如果可以具体到每个证书，就更好了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">            SSLContext sslContext = <span class="keyword">new</span> SSLContextBuilder().loadTrustMaterial(<span class="keyword">null</span>, <span class="keyword">new</span> TrustStrategy() &#123;</div><div class="line">                <span class="comment">//信任所有</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTrusted</span><span class="params">(X509Certificate[] chain,</span></span></div><div class="line">                                         String authType) <span class="keyword">throws</span> CertificateException &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;).build();</div><div class="line">            SSLConnectionSocketFactory sslsf = <span class="keyword">new</span> SSLConnectionSocketFactory(sslContext);</div><div class="line">            <span class="keyword">return</span> HttpClients.custom().setSSLSocketFactory(sslsf).build();</div><div class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (KeyStoreException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> HttpClients.createDefault();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>最近才开始接触这个工具包，官网上目前已经更新到<a href="http://hc.apache.org/downloads.cgi" target="_blank" rel="external">HttpClient4.5.2</a>了。google的时候看到HttpCl]]>
    </summary>
    
      <category term="HttpClient" scheme="http://www.whtis.com/tags/HttpClient/"/>
    
      <category term="Web相关" scheme="http://www.whtis.com/categories/Web%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java阶段性总结]]></title>
    <link href="http://www.whtis.com/2016/04/21/Java%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://www.whtis.com/2016/04/21/Java阶段性总结/</id>
    <published>2016-04-21T10:29:08.000Z</published>
    <updated>2016-09-14T15:50:25.000Z</updated>
    <content type="html"><![CDATA[<p>花了大半年的时间，算是彻底从头看了一遍Java的基本知识，参考书籍是《Java语言程序设计》原书第五版，作者为Y.daniel Liang，基础篇和提高篇中的重要内容都摘录在了之前的文章中。本文就是对之前的Java总结做个分类，方便自己以后回顾。</p>
<h3 id="第一篇_程序设计基础（1~5章）">第一篇 程序设计基础（1~5章）</h3><h5 id="第一章_计算机、程序和Java概述"><a href="http://www.whtis.com/2015/12/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E7%A8%8B%E5%BA%8F%E5%92%8CJava%E6%A6%82%E8%BF%B0/">第一章 计算机、程序和Java概述</a></h5><h5 id="第二章_基本数据类型和基本操作"><a href="http://www.whtis.com/2015/12/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">第二章 基本数据类型和基本操作</a></h5><h5 id="第三章_控制语句"><a href="http://www.whtis.com/2016/01/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/">第三章 控制语句</a></h5><h5 id="第四章_方法"><a href="http://www.whtis.com/2016/01/11/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%B9%E6%B3%95/">第四章 方法</a></h5><h5 id="第五章_数组"><a href="http://www.whtis.com/2016/01/20/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E7%BB%84/">第五章 数组</a></h5><h3 id="第二篇_面向对象程序设计（6~10章）">第二篇 面向对象程序设计（6~10章）</h3><h5 id="第六章_对象和类"><a href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/">第六章 对象和类</a></h5><h5 id="第七章_字符串"><a href="http://www.whtis.com/2016/01/26/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/">第七章 字符串</a></h5><h5 id="第八章_继承和多态"><a href="http://www.whtis.com/2016/01/27/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">第八章 继承和多态</a></h5><h5 id="第九章_抽象类和接口"><a href="http://www.whtis.com/2016/01/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">第九章 抽象类和接口</a></h5><h5 id="第十章_面向对象建模"><a href="http://www.whtis.com/2016/01/29/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/">第十章 面向对象建模</a></h5><h3 id="第三篇_图形用户界面设计（11~13章）">第三篇 图形用户界面设计（11~13章）</h3><h5 id="第十一章_图形用户界面程序设计"><a href="http://www.whtis.com/2016/02/05/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">第十一章 图形用户界面程序设计</a></h5><h5 id="第十二章_事件驱动程序"><a href="http://www.whtis.com/2016/02/09/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/">第十二章 事件驱动程序</a></h5><h5 id="第十三章_创建图形用户界面"><a href="http://www.whtis.com/2016/02/15/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/">第十三章 创建图形用户界面</a></h5><h3 id="第四篇_异常处理、I/O（15~16章）">第四篇 异常处理、I/O（15~16章）</h3><h5 id="第十五章_异常和断言"><a href="http://www.whtis.com/2016/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%AD%E8%A8%80/">第十五章 异常和断言</a></h5><h5 id="第十六章_简单输入输出"><a href="http://www.whtis.com/2016/02/18/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%AE%80%E5%8D%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">第十六章 简单输入输出</a></h5><h3 id="第五篇_数据结构与集合架构">第五篇 数据结构与集合架构</h3><h5 id="第十七章_面向对象数据结构"><a href="http://www.whtis.com/2016/03/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">第十七章 面向对象数据结构</a></h5><h5 id="第十八章_Java集合架构"><a href="http://www.whtis.com/2016/04/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-Java%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84/">第十八章 Java集合架构</a></h5><h3 id="第六篇_多线程">第六篇 多线程</h3><h5 id="第十九章_多线程"><a href="http://www.whtis.com/2016/04/10/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">第十九章 多线程</a></h5><h3 id="网络">网络</h3><h5 id="第二十八章_网络"><a href="http://www.whtis.com/2016/04/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E7%BD%91%E7%BB%9C/">第二十八章 网络</a></h5><hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>花了大半年的时间，算是彻底从头看了一遍Java的基本知识，参考书籍是《Java语言程序设计》原书第五版，作者为Y.daniel Liang，基础篇和提高篇中的重要内容都摘录在了之前的文章中。本文就是对之前的Java总结做个分类，方便自己以后回顾。</p>
<h3 id="第]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第二十八章 网络]]></title>
    <link href="http://www.whtis.com/2016/04/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.whtis.com/2016/04/16/Java学习总结-第二十八章-网络/</id>
    <published>2016-04-16T13:43:48.000Z</published>
    <updated>2016-09-14T15:47:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p><code>基于套接字的通信</code>可以使程序通过指定的套接字进行通信。<code>套接字（socket）</code>是两个主机之间逻辑连接的端点，可以用于发送和接收数据。<br>Java支持流套接字和数据报套接字。<code>流套接字（stream socket）</code>使用传输控制协议（Transmission Control Protocol，TCP）进行数据传输，而<code>数据报套接字（datagram socket）</code>使用的是用户数据报协议（User Datagram Protocol，UDP）。</p>
<h3 id="客户/服务器计算模式">客户/服务器计算模式</h3><ul>
<li>服务器和客户一旦建立连接，客户和服务器就可以通过套接字进行通信。</li>
<li><p>创建<code>服务器套接字（server socket）</code>，并把它附加到一个端口上，服务器从端口监听连接。端口标识套接字上的TCP服务，端口号的范围从0到65536，但是0到1024号是为特权服务保留的端口。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</div><div class="line"><span class="comment">//监听</span></div><div class="line">Socket socket = serverSocket.accept();</div></pre></td></tr></table></figure>
<p><strong>如果企图在已经使用的端口上创建服务器套接字，将会引起<code>java.net.BindException</code>异常。</strong></p>
</li>
<li><p>服务器的监听语句会一直等待，直到一个客户与服务器套接字建立连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket socket = <span class="keyword">new</span> Socket(serverName,port);</div></pre></td></tr></table></figure>
<p>serverName是服务器的域名或IP地址。</p>
</li>
<li><p>通过得到socket的输入输出流，接可以进行数据传输了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InputStream input = socket.getInputStream();</div><div class="line">OutputStream output = socket.getOutputStream();</div></pre></td></tr></table></figure>
<p><strong>建议使用二进制I/O在服务器和客户间进行数据传输，以便提高效率。</strong></p>
</li>
</ul>
<h3 id="网络地址类InetAddress">网络地址类InetAddress</h3><ul>
<li><p>可以使用类InetAddress来求得客户的主机名和IP地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">InetAddress inetAddress = socket.getInetAddress();</div><div class="line">String hostname = inetAddress.getHostName();</div><div class="line">String ip = inetAddress.getHostAddress();</div></pre></td></tr></table></figure>
</li>
<li><p>可以使用静态方法getByName通过主机名或IP地址创建InetAddress的一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InetAddress address = InetAddress.getByName(<span class="string">"www.google.com"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多客户服务">多客户服务</h3><ul>
<li><p>可以使用线程处理服务器上多个客户的同步问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">	Socket socket = serverSocket.accept();</div><div class="line">	Thread thread = <span class="keyword">new</span> ThreadClass(socket);</div><div class="line">	thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务器套接字可以有多个连接。while循环的每次迭代创建一个新的连接。</p>
</li>
</ul>
<h3 id="发送和接收对象">发送和接收对象</h3><ul>
<li>可以在套接字流上使用ObjectInputStream和ObjectOutputStream接收和发送对象。为了能够进行传输，这些对象必须实现<code>Serializable</code>接口。</li>
</ul>
<h3 id="从Web服务器上读取文件">从Web服务器上读取文件</h3><ul>
<li>可以创建一个<code>java.net.URL</code>对象，然后打开一个输入流：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"www.whtis.com"</span>);</div><div class="line">InputStream inputStream = url.openStream();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JEditorPanel类">JEditorPanel类</h3><ul>
<li>Swing提供了一个名叫javax.swing.JEditorPanel的GUI组件，它能够自动地显示普通文本文件、HTML文件和RTF文件。 </li>
<li><p>要显示文件的内容，可以使用setPage（URL）方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPage</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException</span></div></pre></td></tr></table></figure>
</li>
<li><p>当单击编辑窗格中的一个超链接时，JEditorPanel产生<code>javax.swing.event.HyperLink Event</code>事件，通过该事件，我们可以得到超链接的URL，并使用setPage(url)方法显示它。</p>
</li>
</ul>
<h3 id="数据报套接字">数据报套接字</h3><ul>
<li>我们编写的有些网络通信不要求TCP提供可靠的、点对点的通道，这种情况下，数据报通信效率更高。</li>
<li>数据是用<code>分组（packet，或称为包）</code>进行传输的。数据报套接字使用<code>用户数据报协议（User Datagram Protocol，UDP）</code>，该协议不能保证分组不会丢失、或者不会重复接收、或者接收的顺序与发送的顺序不同。</li>
<li><code>数据报（datagram）</code>是独立的，包含自身网络上的传输信息，它的到达、到达的时间和内容都没有保证。</li>
</ul>
<h4 id="DatagramPacket类和DatagramSocket类">DatagramPacket类和DatagramSocket类</h4><ul>
<li>DatagramPacket表示数据报的分组。要为来自客户的传送创建DatagramPacket对象，可以使用构造方法<code>DatagramPacket(byte[] buf,int length,InetAddress host,int prot)</code>。要创建其他所有的DatagramPacket对象，使用构造方法<code>DatagramPacket(byte[] buf,int length)</code>。一旦创建了一个数据报分组，就可以使用getData()方法和setData()方法获取和设置分组中的数据。</li>
<li>数据报套接字类DatagramSocket表示发送和接收数据报分组的套接字。数据报套接字是分组传输服务的发送和接收点。每个在套接字上发送和接收的分组都是独立编址和路由的。<ul>
<li>要创建服务器上的数据报套接字，使用构造方法DatagramSocket(int port),它将套接字绑定到本地主机指定的端口上。</li>
<li>要创建客户上的数据报套接字，使用构造方法DatagramSocket()，它将套接字绑定到本地主机任意一个可用的端口上。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>流套接字的端口号和数据报套接字的端口号是互不相关的。流套接字和数据报套接字能够同时使用同一个端口号。</li>
<li>数据报套接字使用<code>send(DatagramSocket)</code>发送分组，使用<code>receive(DatagramSocket)</code>接收分组。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题28.1 28.3 28.6 28.8 28.9 28.10源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter28/src" target="_blank" rel="external">chapter28</a></li>
<li><p>习题28.6 </p>
<ul>
<li><p>服务器端的输入输出流应该和客户端的对应。</p>
<ul>
<li><p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</div></pre></td></tr></table></figure>
</li>
<li><p>相应的，服务器端的顺序应该为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如何判断ObjectInputStream类中readObject()方法是否到达末尾:</p>
<ul>
<li><p>readObject()方法读取数据流到末尾时会抛出<code>java.io.EOFException</code>异常，可以捕获到这个异常并由此判断对象数据读取完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"Address.dat"</span>);</div><div class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        ObjectInputStream InFromFile = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            lists.add(InFromFile.readObject());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (EOFException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">        jTextArea.append(<span class="string">"Data read completed!"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>可以在数据流中添加标识，当读取到标识后，则关闭输出流。例如：可以在写入数据完成后附加<code>null</code>作为标识。</p>
</li>
</ul>
</li>
<li>异常<code>java.io.StreamCorruptedException: invalid type code: AC</code>的出现原因及解决方案<ul>
<li>原因：新建一个ObjecOutputStream类后，在第一次写入时，会附加一个头文件信息，随后的数据不会附加头文件。新建一个ObjectInputStream，在第一次读取时会寻找头文件，之后读取时就不会寻找头文件直接读取数据。如果写入数据时每次都附加头文件，而读取时仅第一次读取头文件，就会抛出上述异常。</li>
<li>解决方案：写文件和读文件要统一，写文件时不能每次都附带头文件，也就是用一个输出流写数据，不要每次写入对象都新建一个输出流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p><code>基于套接字的通信</code>可以使程序通过]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java学习总结-第十九章 多线程]]></title>
    <link href="http://www.whtis.com/2016/04/10/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.whtis.com/2016/04/10/java学习总结-第十九章-多线程/</id>
    <published>2016-04-10T15:17:34.000Z</published>
    <updated>2016-09-14T15:48:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java支持<code>多线程（multithreading）</code>。多线程是指在一个程序中允许同时运行多个任务的能力。</p>
<h3 id="线程的概念">线程的概念</h3><ul>
<li><code>一个线程（thread）</code>是指程序中完成一个任务的有始有终的执行流。使用Java，可以在一个程序中并发的运行多个线程。</li>
<li>多线程可以使程序反应更快，交互性更强，执行效率更高。</li>
<li>Java对多线程程序的开发和运行提供了非常好的支持，包括锁定资源以避免冲突。</li>
<li>每个新线程都是一个对象，它的类实现<code>Runnable</code>接口或者扩展实现了<code>Runnable</code>接口，这种新对象称为<code>可运行对象（runnable object）</code>。</li>
</ul>
<h3 id="创建线程的两种方式">创建线程的两种方式</h3><h4 id="扩展Thread类创建线程">扩展Thread类创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//do something</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现runnable接口创建线程">实现runnable接口创建线程</h4><ul>
<li><p>实现接口：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">	<span class="meta">@override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> run &#123;</div><div class="line">		<span class="comment">//do something</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建线程：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnThread());</div><div class="line">t.start();</div></pre></td></tr></table></figure>
</li>
<li><p>如果用户线程要实现多继承，应该选择实现Runnable接口这种方式。</p>
</li>
</ul>
<h3 id="线程的控制与通信">线程的控制与通信</h3><ul>
<li>Thread类中提供的控制线程的方法：<ul>
<li>start()</li>
<li>interrupt()  中断该线程。如果该线程处于阻塞状态，它就进入重新运行的就绪状态</li>
<li>isAlive()  该方法判断线程是否正处于运行状态</li>
<li>setPriority(int p)</li>
<li>join()  等待该线程结束</li>
<li>sleep(long millis)  </li>
<li>yield()  让该线程暂停执行，允许其他线程开始运行</li>
<li>isinterrupted()</li>
<li>currentThread()  返回当前正在运行的线程对象的引用<br><strong>Thread类还包含stop()、suspend()和resume()。但是这些线程具有内在的不安全因素，因此不建议使用。要替代stop()方法，可以给线程变量赋值为null，指明要停止它的运行。</strong></li>
</ul>
</li>
<li>方法wait()、notify()、notifyAll()定义在Object类中，也可以用于促进活动线程之间的通信。<ul>
<li>wait()  该方法强迫线程等待，直到对调用wait方法的对象调用notify或notifyAll方法。</li>
</ul>
</li>
</ul>
<h4 id="线程的状态">线程的状态</h4><ul>
<li>线程有五种状态：新建、就绪、运行、阻塞或结束。<br><img src="线程的状态.jpg" alt="线程的状态"></li>
<li>有几种原因会使线程进入<code>阻塞状态（Blocked state）</code>：<ul>
<li>可能是它自己调用了join()、sleep()或wait()方法</li>
<li>可能是其他方法调用了如上方法</li>
<li>可能是该线程在等待一个I/O操作的完成</li>
</ul>
</li>
<li>方法interrupt按下列方式中断一个线程：当线程处于就绪状态或运行状态时，给它设置一个中断标志；当线程处于阻塞状态时，它将会被唤醒并进入就绪状态，同时抛出异常java.lang.InterruptedException。即：<strong>中断不仅打断执行过程，也可以打断不执行过程。</strong></li>
</ul>
<h4 id="线程的优先级">线程的优先级</h4><ul>
<li>Java给每个线程指定一个优先级。</li>
<li>Thread类有int型常量MIN_PRIOTITY、NORM_PRIORITY和MAX_PRIORITY，分别代表1、5、10、主线程的优先级是Thread.NORM_PRIORITY。<br><strong>如果总有一个优先级较高的线程在运行，或者有一个相同优先级的线程不退出，那么一个线程可能永远也没有运行的机会。这种情况称为<code>竞争（contention）</code>或<code>资源缺乏（starvation）</code>状态。</strong></li>
</ul>
<h3 id="线程组">线程组</h3><ul>
<li>一个<code>线程组（thread group）</code>是线程的一个集合。可以同时对一个线程组进行唤醒和挂起操作。</li>
<li>可以把一个线程组添加到另一个线程组，构成一个树形结构，除了起始组以外，树中的每个线程组都有一个父线程组。</li>
<li>每个线程都属于一个线程组。</li>
<li>线程组的创建：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ThreadGroup g = <span class="keyword">new</span> ThreadGroup(<span class="string">"thread group"</span>);  <span class="comment">//组名必须是唯一的字符串</span></div><div class="line">Thread t = <span class="keyword">new</span> Thread(g,<span class="keyword">new</span> ThreadClass(),<span class="string">"label for the thread"</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>线程组里的线程必须分别启动</strong></p>
<h3 id="线程之间的同步与协作">线程之间的同步与协作</h3><p>多个线程同时访问一个共享资源会引起<code>资源冲突（race condition）</code>。如果一个类的对象在多线程程序中没有引起资源冲突，则称这样的类为<code>线程安全的（thread-safe）</code>。</p>
<h4 id="同步化实例与静态方法">同步化实例与静态方法</h4><ul>
<li>为避免资源冲突，应该防止多个线程同时进入程序的某一特定部分，程序中这样的部分称为<code>临界区（critical region）</code>。</li>
<li>可以使用关键字<code>Synchronized</code>来使方法的通信同步，以便一次只有一个线程可以访问该方法。</li>
<li>一个同步方法在执行前需要加锁：对于实例方法，要给调用该方法的对象加锁；对于静态方法，要给这个类加锁。</li>
</ul>
<h4 id="同步语句">同步语句</h4><ul>
<li><p>当执行方法中某一个代码块（也成为体）时，同步语句不仅仅可以用于获准给该对象加锁，而且可以用于要求对任何对象加锁。这个代码块称为<code>同步块（synchronized block）</code>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (expr) &#123;  <span class="comment">//表达式expr必须能求出对象的引用</span></div><div class="line">	语句组；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>同步语句允许对任何对象加锁，所以可以同步地访问一个对象而不仅仅是一个方法。</p>
</li>
<li><p>任何同步的实例方法都可以转化为同步语句。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">xMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//方法体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		<span class="comment">//方法体</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="线程之间的协作">线程之间的协作</h4><ul>
<li>通过在临界区上多个线程的相互排斥，线程同步完全可以避免资源冲突的发生，但是有时候我们还需要线程之间的相互协作。</li>
<li>wait、notify和notifyAll方法可以用来实现线程之间的相互通信。这些方法必须在同步方法中调用，或者在接受这些方法的对象的同步块中调用；否则会抛出异常<code>IllegalMonitorStateException</code>。</li>
</ul>
<h4 id="死锁">死锁</h4><ul>
<li>使用一种名为<code>资源排序（resource ordering）</code>的简单技术可以轻易的避免死锁的发生。该技术是给每一个需要锁定的对象定义一个顺序，确保每个线程都按这个顺序来锁定对象。</li>
</ul>
<h3 id="进程条JProcessBar">进程条JProcessBar</h3><ul>
<li>进程条JProcessBar是一个图形组件，用来以图示的方式显示有界区间内的一个值。</li>
<li>进程条的常用属性有orientation、minimum、value和maximum等。</li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>线程对象从来不会直接引用run方法，到了执行某个线程的时候，Java虚拟机调用该线程的run方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li><p>习题19.2 19.3 19.4 19.6 19.7 19.8 19.9 19.11源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter19/src" target="_blank" rel="external">chapter19</a></p>
</li>
<li><p>习题19.7要求使用同步集合解决习题19.6多线程出现异常java.util.ConcurrentModificationException的问题。当完成这个题并且多次执行时，会出现下面这个问题，暂时不知道是否是错误：<br>向规则集添加数字时使用如下语句：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hashSet.add(((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>)) + <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>  控制台输出为以下结果：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">8</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>也就是说，随机数在规则集内被重新排序了，并且在使用迭代算子遍历时被打印到控制台。排序的原因猜测是同步规则集的方法导致的：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.synchronizedSet(hashSet);</div></pre></td></tr></table></figure>
</li>
<li><p>习题19.9要求写一个死锁程序，形成死锁的条件如下：</p>
<ul>
<li><blockquote>
<p>互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。</p>
</blockquote>
</li>
<li><blockquote>
<p>不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。</p>
</blockquote>
</li>
<li><blockquote>
<p>占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。</p>
</blockquote>
</li>
<li><blockquote>
<p>循环等待条件。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。</p>
</blockquote>
</li>
</ul>
<p>根据这个原则，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $19<span class="title">_9</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      DeadThread t1 = <span class="keyword">new</span> DeadThread();</div><div class="line">      DeadThread t2 = <span class="keyword">new</span> DeadThread();</div><div class="line">      t1.flag = <span class="number">0</span>;</div><div class="line">      t2.flag = <span class="number">1</span>;</div><div class="line">      t1.start();</div><div class="line">      t2.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">  * 线程1锁定o1后休眠1s，使得有机会执行线程2，线程2锁定o2后，等待线程1释放o1，线程1此时锁定了o1，等待线程2</div><div class="line">  * 释放o2，形成死锁。</div><div class="line">  *</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (flag==<span class="number">0</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"flag="</span> + flag);</div><div class="line">          <span class="keyword">synchronized</span> (o1) &#123;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  Thread.sleep(<span class="number">1000</span>);</div><div class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">synchronized</span> (o2) &#123;</div><div class="line">                  System.out.println(<span class="string">"o2 locked"</span>);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (flag==<span class="number">1</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"flag="</span> + flag);</div><div class="line">          <span class="keyword">synchronized</span> (o2) &#123;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  Thread.sleep(<span class="number">1000</span>);</div><div class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">synchronized</span> (o1) &#123;</div><div class="line">                  System.out.println(<span class="string">"o2 locked"</span>);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>Java支持<code>多线程（multithreadi]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第十八章 Java集合架构]]></title>
    <link href="http://www.whtis.com/2016/04/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-Java%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.whtis.com/2016/04/01/Java学习总结-第十八章-Java集合架构/</id>
    <published>2016-04-01T03:41:32.000Z</published>
    <updated>2016-09-14T15:49:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数组线性表和链表是Java中的预定义结构。除此之外，Java还引入了几种可以有效组织和处理数据的接口和类，这些接口和类组成了<code>Java集合架构（Java Collection Framework）</code>。<br>一个<code>集合（collection）</code>就是一个存储一组对象的容器，一般将这些对象称为集合的<code>元素（element）</code>。Java集合构架支持三种类型的集合：<code>规则集（set）、线性表（list）和图（map）</code>，它们分别定义在接口Set、List与Map中。Set的实例存储一组互不相同的元素，List的实例存储一组顺序排列的元素，Map的实例存储一组对象，每个对象都有一个关联的键值。</p>
<p><img src="Set&amp;List类.png" alt="Set和List接口是Collection接口的子接口"><br><img src="Map类.png" alt="Map的实例存储一组对象以及与它们关联的键值"></p>
<h3 id="Collection接口和AbstractCollection类">Collection接口和AbstractCollection类</h3><ul>
<li>Collection接口是处理对象集合的根接口。它的方法详见<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="external">API</a>。AbstractCollection类是提供对Collection接口部分实现的便利类。除了size方法和iterator方法之外，它实现了Collection接口中的所有方法。</li>
<li>Iterator接口提供next（）方法，可以依次访问集合中存储的元素。<br><strong>Collection接口中有些方法不能在具体子类中实现。这种情况下，这些方法会抛出异常<code>java.lang.UnsupportedOperationException</code>，该异常是RuntimeException异常的一个子类。</strong></li>
</ul>
<h3 id="规则集Set">规则集Set</h3><ul>
<li>Set接口扩展Collection接口，它没有引入新的方法和常量，只规定它的实例不能包含相同的元素。</li>
<li>AbstractSet类是一个便利类，它扩展了AbstractCollection类并实现了Set接口。</li>
<li>Set接口的三个具体类是HashSet、LinkedHashSet和TreeSet。</li>
</ul>
<h4 id="散列集HashSet">散列集HashSet</h4><ul>
<li>HashSet类可以用来存储互不相同的任何元素。考虑效率的因素，添加到散列集之中的对象必须实现hashCode方法，适当地散列分布散列码。</li>
<li>两个不等的对象可能有相同的散列码。</li>
</ul>
<h4 id="链式散列集LinkedHashSet">链式散列集LinkedHashSet</h4><ul>
<li>在HashSet中元素是没有顺序的，而在LinkedHashSet中，可以按元素插入集合的顺序进行提取。</li>
<li>LinkedHashSet中的元素存储时保持插入的顺序，要想自定义顺序，可以使用<code>TreeHashSet</code>。<br><strong>如果不需要使元素按其插入的顺序进行存储，应该使用HashSet，它的效率要比LinkedHashSet高。</strong></li>
</ul>
<h4 id="树形集TreeSet">树形集TreeSet</h4><p>SortSet是Set的一个子接口，它保证规则集中的元素是有序的。TreeSet是实现SortedSet接口的一个具体类。只有当对象之间可以互相比较是，才可以将它们添加到树形集TreeSet中。</p>
<ul>
<li>有两种方法实现对象的比较：<ul>
<li>使用Comparable接口。如果添加到规则集中的对象是Comparable的实例，就可以使用compareTo方法来比较。这种方法定义的序通常称为<code>自然顺序（natural order）</code>。<strong>参见习题18.7</strong></li>
<li>如果该类不支持Comparable接口，或者在实现Comparable接口的类中不想使用compareTo方法进行比较，可以给规则集的元素创建一个比较器。这种方法定义的序称为<code>比较器顺序（order by comparator）</code>。</li>
</ul>
</li>
<li>创建树形集的好的方法是使用构造方法<code>TreeSet(Collection c)</code>，这样只需要对规则集进行一次排序，效率较高。<br>**如果向树形集添加一个与集合中已有元素不可比的对象，将会发生运行错误<code>ClassCastException</code>。</li>
</ul>
<h3 id="比较器接口Comparator">比较器接口Comparator</h3><ul>
<li>有时想把不同类型的元素添加到同一个树形集内，可以定义一个比较器来比较这些元素。可以创建一个<code>java.util.Comparator</code>接口的类。其方法如下：<ul>
<li>public int compare(Object element1,Object element2)  </li>
<li>public boolean equals(Object element)<br>**Object类也定义了equals方法，因此实现接口时不实现equals方法也不会报错，但是实现该方法可以快速的判断，提高效率。</li>
</ul>
</li>
<li>树形集要想使用一个比较器，必须使用构造方法TreeSet（Comparator comparator）来创建一个有序集。</li>
</ul>
<h3 id="线性表List">线性表List</h3><p>线性表允许在一个集合中存储重复的元素。</p>
<ul>
<li>List接口扩展Collection接口，添加了<code>面向位置（position-oriented）</code>的操作，并且添加了能够双向遍历线性表的新迭代探子。（ListIterator）</li>
</ul>
<h4 id="数组线性表ArrayList和链表LinkedList">数组线性表ArrayList和链表LinkedList</h4><ul>
<li>如果需要使用下标随机访问元素，并且处理在末尾之外，不在其他位置插入或删除元素，使用ArrayList。</li>
<li>如果需要在线性表的任意位置上插入或删除元素，应该选择LinkedList。</li>
<li>如不要求在线性表中插入或删除元素，数组是效率最高的数据结构。</li>
</ul>
<h4 id="向量类Vector">向量类Vector</h4><ul>
<li>Vector类除了包含用于访问和修改向量的同步方法外，它与ArrayList是相同的。同步方法用于防止两个或多个线程同时访问向量时引起数据冲突。</li>
<li>当不需要同步时，最好使用ArrayList，它比Vector快得多。</li>
</ul>
<h4 id="栈类stack">栈类stack</h4><p>栈类stack是最为Vector类的扩展实现的。</p>
<h3 id="一般类型的使用">一般类型的使用</h3><ul>
<li>所有的集合都支持一般类型，可以用记号<code>&lt;&gt;</code>给任一集合中的元素指定一个特定的类型。</li>
<li>从一个只有一种指定元素类型的集合中取值时，不需要进行类型转换。</li>
</ul>
<h3 id="图Map">图Map</h3><ul>
<li>Map接口建立元素和键值的一个映射关系。键值就是下标。</li>
<li>一个图中不能有重复的键值，每个键值对应一个值。</li>
<li>AbstractMap类是一个实现Map接口的便利类，除了entrySet()方法外，它实现了Map接口中的其他方法。SortedMap接口扩展Map接口，其中的映像是以键值升序的方式排列的。</li>
<li>散列图HashMap、链式散列图LinkedHashMap和树形图TreeMap三种类是实现Map接口的具体类。</li>
</ul>
<h4 id="HashMap">HashMap</h4><p>对于定位查找一个值、插入一个映像或删除一个映像，HashMap的效率是很高的。</p>
<h4 id="LinkedHashMap">LinkedHashMap</h4><ul>
<li>它支持图中元素排序。在LinkedHashMap中，元素既可以按照它们插入的顺序排序（称为<code>插入排序（insertion order）</code>），也可以按它们最后一次访问时间的顺序，从最早到最晚（称为<code>访问顺序（access order）</code>）。<ul>
<li>无参构造方法是以插入顺序创建LinkedHashMap对象的。</li>
<li>使用构造方法LinkedHashMap（initialCapacity，loadFactor，true）可以以访问顺序创建LinkedHashMap对象。</li>
</ul>
</li>
</ul>
<h4 id="TreeMap">TreeMap</h4><ul>
<li>它实现了SortedMap接口，它可以按照键值排好的顺序遍历图。键值可以使用Comparable接口或Comparator接口来排序。</li>
<li>构造方法：<ul>
<li>TreeMap（）如果实现了Comparable接口，就可以使用compareTo方法来对集合内中的元素进行排序。</li>
<li>TreeMap（Comparator comparator）可以使用指定比较器来对图中元素进行排序。</li>
</ul>
</li>
</ul>
<p><strong>Map接口不含有迭代探子，为遍历一个图，可以用Map接口的方法<code>enrtySet()</code>来创建一个映像的规则集。该规则集内的每个元素都是一个字符串，它是由代表键值对象的字符串与其对应的映像用等号连接而成的。</strong></p>
<h3 id="Collections类">Collections类</h3><p>Collections类包含管理集合与图、创建同步集合类、创建只读集合类等<code>静态方法</code>。</p>
<h3 id="Arrays类">Arrays类</h3><p>Arrays类中包含对数组进行排序、查找、比较和填充元素的各种<code>静态方法</code>。它还包含了将数组转为线性表的方法。</p>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>Java集合架构中的所有具体类都实现了Cloneable和Serializable接口，所以它们的实例都是可复制和可复制的。</li>
<li>Collections类和Arrays类提供的方法都是静态方法。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题18.1 18.2 18.3 18.5 18.6 18.7 18.9源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter18/src" target="_blank" rel="external">chapter18</a></li>
<li><p>18.5按字典升序显示单词的实现思路：使用线性表存储每个单词，使用构造方法sort（Comparator comparator）对表中的对象排序，比较器的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DicComparable</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">        String s1 = ((String) (o1)).toLowerCase();</div><div class="line">        String s2 = ((String) (o2)).toLowerCase();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (s1.compareTo(s2) &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1.compareTo(s2) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>18.7将单词按出现频率升序显示，实现思路：创建一个实现Comparable接口的类Wordoccurrence,该类包含两个域word和count，使用compareTo方法来比较单词的出现次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordOccurrence</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</div><div class="line"></div><div class="line">    String word;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordOccurrence</span><span class="params">(String word, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.word = word;</div><div class="line">        <span class="keyword">this</span>.count = count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (count &gt; ((WordOccurrence) o).count) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; ((WordOccurrence) o).count) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数组线性表和链表是Java中的预定义结构。除此之外，Ja]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java学习总结-第十七章 面向对象数据结构]]></title>
    <link href="http://www.whtis.com/2016/03/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.whtis.com/2016/03/22/Java学习总结-第十七章-面向对象数据结构/</id>
    <published>2016-03-22T15:44:38.000Z</published>
    <updated>2016-09-14T15:48:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数据结构是按某种方式组织的数据集合。用面向对象的观点来看，一个数据结构就是一个存储着其他对象的对象，存储在数据结构内的对象称为数据或元素。因此数据结构又被称为<code>容器对象（container object）</code>或<code>集合对象（collection object）</code>。<br>本章介绍线性表、堆栈、队列和二叉树等四种动态数据结构。</p>
<h3 id="线性表">线性表</h3><ul>
<li>线性表是存储顺序排列的数据时最常用的数据结构。</li>
<li>线性表可以由数组或者链表实现。这两种类具有相同的操作，但是具有不同的数据域，这些相同的操作可以由接口或抽象类生成。在设计时同时提供接口与抽象类是把它们的优点结合到一起的好策略，这样的抽象类称为<code>便利类</code>。</li>
<li>数组线性表<ul>
<li>数组是一种固定大小的数据结构。但仍然可以采用如下方法实现动态改变：当数组不能再存储线性表中的新元素时，创建一个更大的数组来代替当前数组。这样的数组线性表是一个动态的数据结构。</li>
</ul>
</li>
<li>链表<ul>
<li>由数据创建的线性表，在特定位置进行插入和删除操作效率是很低的，因此可以采用链表结构来提高效率。</li>
<li>链表的遍历：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Node temp = first;</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</div><div class="line">     temp = temp.next;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="栈和队列">栈和队列</h3><ul>
<li>栈（stack）可以看做是一种特殊的线性表，访问、插入和删除它的元素只能在栈的一端（栈顶）进行。队列可以表示一个排队等待的队伍。它可以看做是一种特殊的线性表，它的元素只能从队列的末端（队列尾）插入，从开始端（队列头）访问和删除。</li>
<li>栈：使用数组线性表来实现栈效率较高。</li>
<li>队列：用链表实现。</li>
</ul>
<h3 id="二叉树">二叉树</h3><ul>
<li>线性表、栈和队列都是由一列元素构成的线型结构。二叉树是一个层次结构，它要么是空集，要么由一个被称为<code>根（root）</code>的元素和两棵不同的子树组成，这两个子树分别称为<code>左子树（left subtree）</code>和<code>右子树（right subtree）</code>。</li>
<li>一个结点的左（右）子树的根节点称为该结点的<code>左（右）孩子（left（right）child）</code>。没有孩子的结点称为<code>叶结点（leaf）</code>。<code>二叉搜索树（binary search tree）</code>是一种常用的特殊二叉树。二叉搜索树的特征是：对它的每一个结点来说，左子树中结点的值都小于该结点的值，右子树中的结点的值都大于该节点的值。</li>
</ul>
<h4 id="二叉树的遍历">二叉树的遍历</h4><ul>
<li><p><code>中序遍历（inorder）:</code>首先访问当前结点的左子树，然后访问当前结点，最后访问该结点的右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       inorder(root.left);</div><div class="line">       System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">       inorder(root.right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>后序遍历（postorder）：</code>首先访问当前结点的左子树，然后访问该结点的右子树，最后访问该结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">       postorder(root.left);</div><div class="line">       postorder(root.right);</div><div class="line">       System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>前序遍历（preorder）：</code>首先访问当前结点，然后访问该结点的左子树，最后访问该结点的右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">       System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">       preorder(root.left);</div><div class="line">       preorder(root.right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>深度优先遍历（depth-first）：</code>与前序遍历相同。</p>
</li>
<li><code>广度遍历法（breadth-first）：</code>一层一层的访问树的结点。<br><strong>如果元素的插入顺序不同，树看起来可能不一样，但是只要元素的集合相同，中序序列是一样的。</strong></li>
</ul>
<hr>
<h2 id="复习小结">复习小结</h2><ul>
<li>基本类型的数据不能作为对象存储，但是可以给基本数据类型值创建对应包装类的对象。</li>
</ul>
<hr>
<h2 id="编程练习">编程练习</h2><ul>
<li>习题17.1、17.2、17.3、17.6源代码见我的Github： <a href="https://github.com/whtis/Java-Exercises/tree/master/chapter17/src" target="_blank" rel="external">chapter17</a></li>
<li>写双向链表时，在执行下列方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    TreeNode current = first;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</div><div class="line">        current = current.next;</div><div class="line">    &#125;</div><div class="line">    TreeNode target = current.next;</div><div class="line">    target.pravious.next = target.next;</div><div class="line">    target.next.pravious = target.pravious;</div><div class="line">    size--;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>执行到第7行语句时：list的状态是<code>Method threw &#39;java.lang.NullPointerException&#39; exception. Cannot evaluate _17_3.DoubleLinkedList.toString()</code>,但是整个方法执行完后，不会报错，原因暂时不知道。</p>
<ul>
<li>习题17.6中需要写一个方法，返回二叉树的深度，深度是指二叉树最长路径的结点个数。代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> left = treeDepth(root.left);</div><div class="line">    <span class="keyword">int</span> right = treeDepth(root.right);</div><div class="line">    <span class="keyword">return</span> left &gt; right ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 本文总结源自《Java语言程序设计》原书第五版，作者为Y.daniel Liang，习题及编程练习均参照此书。</strong></p>
<hr>
<h2 id="主要内容">主要内容</h2><p>数据结构是按某种方式组织的数据集合。用面向对象的观点来看]]>
    </summary>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="原创" scheme="http://www.whtis.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="总结" scheme="http://www.whtis.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[base64编码和解码示例代码]]></title>
    <link href="http://www.whtis.com/2016/03/05/base64%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.whtis.com/2016/03/05/base64编码和解码示例代码/</id>
    <published>2016-03-05T15:55:01.000Z</published>
    <updated>2016-09-14T15:46:10.000Z</updated>
    <content type="html"><![CDATA[<p>写密码管理器时，一直在找一种加密方式，除了自己实现外，我还在网上发现了一个不错的方法，<a href="http://www.q3060.com/list6/list144/2717.html" target="_blank" rel="external">源地址在这里</a>。这里仅作抄录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sun.misc.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.regex.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ht on 2016/2/24.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testorigin</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">        TransformBS1 transformBS = <span class="keyword">new</span> TransformBS1();</div><div class="line">        transformBS.testS2B();</div><div class="line">        transformBS.testB2S();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 今天在网上看到一个程序游戏，只要目的是为了能够将文件中的01二进制数据读取到程序然后通过base64解码，再转换成程序</div><div class="line"> * 所以，自己写了个程序：（1）将一段字符串进行base64处理，然后转换成二进制输出。（2）将一段二进制数据转换成字符串，然后base64解码到对应的字符串</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransformBS1</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @ see 字符串进行base64编码后转换为二进制形式,如：（h(原字符)-&gt;a(编码后)-&gt;01100001010000010011110100111101(二进制形式)）</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testS2B</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"=========字符串到二进制！============="</span>);</div><div class="line">        BASE64Encoder e = <span class="keyword">new</span> BASE64Encoder();</div><div class="line"><span class="comment">//编码器</span></div><div class="line">        String s = <span class="string">"我爱你"</span>;</div><div class="line">        System.out.println(<span class="string">"尚未编码的数据："</span> + s);</div><div class="line">        s = e.encode(s.getBytes());</div><div class="line"><span class="comment">//获得base64编码后的字符串</span></div><div class="line">        System.out.println(<span class="string">"编码后的数据："</span> + s);</div><div class="line">        System.out.print(<span class="string">"二进制数据："</span>);</div><div class="line">        String s1 = <span class="string">"whtis\n"</span> + <span class="string">"我爱你\n"</span> + s;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1.toCharArray()) &#123;</div><div class="line"><span class="comment">//对字符串中的字符逐个转换成二进制数据</span></div><div class="line">            String binaryStr = Integer.toBinaryString(c);</div><div class="line"><span class="comment">//单个字符转换成的二进制字符串</span></div><div class="line">            String format = String.format(<span class="string">"%8s"</span>, binaryStr);</div><div class="line"><span class="comment">//因为上面转换成二进制后的位数不够8位所以不足的前面补空格，这里是考虑到能够从数据文件批量读取。</span></div><div class="line">            format = format.replace(<span class="string">" "</span>, <span class="string">"0"</span>);</div><div class="line"><span class="comment">//高位空格替换成0，其实编码后的数据最大范围为2的6次方，首位一定是空格，不然就要用format.startWith(" ");来判断</span></div><div class="line">            System.out.print(format);</div><div class="line"><span class="comment">//输出</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"\n=========字符串到二进制结束！============="</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @ see 二进制形式转换为字符串后进行base64解码的字符串如：(01100001010000010011110100111101-&gt;a-&gt;h)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB2S</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"=========二进制到字符串开始！============="</span>);</div><div class="line">        StringBuffer results = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="comment">//保存尚未解码的数据结果</span></div><div class="line">        String binaryStr = <span class="string">"01110111011010000111010001101001011100110000101011000100001000111100100011000110011110110000000001010001101010110111101101001010100100011010100110100011010010111100000110101010011000011001001100111"</span>;</div><div class="line"><span class="comment">//二进制数据，这里是取用上面程序的最后结果</span></div><div class="line">        System.out.println(<span class="string">"二进制数据："</span> + binaryStr);</div><div class="line"><span class="comment">//这里采用正则表达式来匹配8位长度的数据，然后一个个find()</span></div><div class="line">        Matcher matcher = Pattern.compile(<span class="string">"\\d&#123;8&#125;"</span>).matcher(binaryStr);</div><div class="line"><span class="comment">//定义匹配模式并，获取模式</span></div><div class="line">        BASE64Decoder d = <span class="keyword">new</span> BASE64Decoder();</div><div class="line"><span class="comment">//解码器</span></div><div class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</div><div class="line"><span class="comment">//在binaryStr中找到了8位长度的数据，依次往后面找</span></div><div class="line">            <span class="keyword">int</span> intVal = Integer.valueOf(matcher.group(), <span class="number">2</span>);</div><div class="line"><span class="comment">//matcher.group()中存储了找到匹配模式的数据，这里以2进制的形式转换为整数</span></div><div class="line">            results.append((<span class="keyword">char</span>) intVal);</div><div class="line"><span class="comment">//将整数转换为对应的字符，并添加到结果中</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"尚未解码的数据："</span> + results);</div><div class="line"><span class="comment">//输出尚未解码的数据</span></div><div class="line">        String s = <span class="keyword">new</span> String(d.decodeBuffer(results.toString()));</div><div class="line"><span class="comment">//得到解码后的数据</span></div><div class="line">        System.out.println(<span class="string">"解码后的数据："</span> + s);</div><div class="line"><span class="comment">//输出解码后的数据</span></div><div class="line">        System.out.println(<span class="string">"=========二进制到字符串结束！============="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<div align="center" style="color:red;width=80px;height:90px;" onmouseout="this.style.border='1px solid blue'" onmouseover="this.style.border='none'"><br><p style="font-weight:bold;font-style:italic;">本文章首发<a href="http://www.whtis.com">www.whtis.com</a>，转载请注明出处</p><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>写密码管理器时，一直在找一种加密方式，除了自己实现外，我还在网上发现了一个不错的方法，<a href="http://www.q3060.com/list6/list144/2717.html" target="_blank" rel="external">源地址在这里</]]>
    </summary>
    
      <category term="收集整理" scheme="http://www.whtis.com/tags/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
      <category term="java" scheme="http://www.whtis.com/tags/java/"/>
    
      <category term="java" scheme="http://www.whtis.com/categories/java/"/>
    
  </entry>
  
</feed>
